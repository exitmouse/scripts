From: Marc Dionne <marc.c.dionne@gmail.com>
Date: Fri, 2 Sep 2011 21:56:58 +0000 (-0400)
Subject: Linux: 3.1: adapt to fsync changes
X-Git-Url: http://git.openafs.org/?p=openafs.git;a=commitdiff_plain;h=81f28004415ae07f2e3a1320da632cbd52c96b25;hp=ef492dc1e1a1809a910fbf07140b26c4924957c5

Linux: 3.1: adapt to fsync changes

The fsync file operation gets new arguments to specify a range.
Add a configure test to check for the API change.

The inode lock is also pushed down into the operation, so we need
to take it ourselves to keep the original behaviour.

Reviewed-on: http://gerrit.openafs.org/5332
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Simon Wilkinson <sxw@inf.ed.ac.uk>
Reviewed-by: Derrick Brashear <shadow@dementix.org>
(cherry picked from commit cbaefa266d433af3b9a082a360e23a42f161d80f)

Change-Id: Idb6770204b014c62a8611548509240f8b5f950bc
---

diff --git a/acinclude.m4 b/acinclude.m4
index 3ff4551..35f2200 100644
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -920,6 +920,7 @@ case $AFS_SYSNAME in *_linux* | *_umlinux*)
 	  	 LINUX_DOP_D_REVALIDATE_TAKES_NAMEIDATA
 	  	 LINUX_FOP_F_FLUSH_TAKES_FL_OWNER_T
 	  	 LINUX_FOP_F_FSYNC_TAKES_DENTRY
+		 LINUX_FOP_F_FSYNC_TAKES_RANGE
 	  	 LINUX_AOP_WRITEBACK_CONTROL
 		 LINUX_FS_STRUCT_FOP_HAS_SPLICE
 		 LINUX_KERNEL_POSIX_LOCK_FILE_WAIT_ARG
diff --git a/src/afs/LINUX/osi_vnodeops.c b/src/afs/LINUX/osi_vnodeops.c
index 696146b..019b568 100644
--- a/src/afs/LINUX/osi_vnodeops.c
+++ b/src/afs/LINUX/osi_vnodeops.c
@@ -425,6 +425,8 @@ afs_linux_release(struct inode *ip, struct file *fp)
 static int
 #if defined(FOP_FSYNC_TAKES_DENTRY)
 afs_linux_fsync(struct file *fp, struct dentry *dp, int datasync)
+#elif defined(FOP_FSYNC_TAKES_RANGE)
+afs_linux_fsync(struct file *fp, loff_t start, loff_t end, int datasync)
 #else
 afs_linux_fsync(struct file *fp, int datasync)
 #endif
@@ -433,9 +435,15 @@ afs_linux_fsync(struct file *fp, int datasync)
     struct inode *ip = FILE_INODE(fp);
     cred_t *credp = crref();
 
+#if defined(FOP_FSYNC_TAKES_RANGE)
+    mutex_lock(&ip->i_mutex);
+#endif
     AFS_GLOCK();
     code = afs_fsync(VTOAFS(ip), credp);
     AFS_GUNLOCK();
+#if defined(FOP_FSYNC_TAKES_RANGE)
+    mutex_unlock(&ip->i_mutex);
+#endif
     crfree(credp);
     return afs_convert_code(code);
 
diff --git a/src/cf/linux-test4.m4 b/src/cf/linux-test4.m4
index 2292f81..35082b3 100644
--- a/src/cf/linux-test4.m4
+++ b/src/cf/linux-test4.m4
@@ -414,6 +414,22 @@ struct dentry _d;
 ])
 
 
+int (*fsync) (struct file *, loff_t start, loff_t end, int datasync);
+
+AC_DEFUN([LINUX_FOP_F_FSYNC_TAKES_RANGE], [
+  AC_CHECK_LINUX_BUILD([whether file_operations.fsync takes a range],
+		       [ac_cv_linux_func_f_fsync_takes_range],
+		       [#include <linux/fs.h>],
+[struct inode _inode;
+struct file _file;
+loff_t start, end;
+(void)_inode.i_fop->fsync(&_file, start, end, 0);],
+		       [FOP_FSYNC_TAKES_RANGE],
+		       [define if your fops.fsync takes range arguments],
+		       [])
+])
+
+
 AC_DEFUN([LINUX_HAVE_KMEM_CACHE_T], [
   AC_CHECK_LINUX_BUILD([whether kmem_cache_t exists],
 		       [ac_cv_linux_have_kmem_cache_t],
