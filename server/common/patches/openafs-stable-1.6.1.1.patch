diff --git a/Makefile.in b/Makefile.in
index f1995c7..3a901b8 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -97,7 +97,7 @@ dpkg:
 packages: dest
 	@case ${SYS_NAME} in \
 	*_darwin_* ) \
-		${COMPILE_PART1} packaging/MacOS && sh ./buildpkg.sh ${DEST} ;; \
+		${COMPILE_PART1} packaging/MacOS && bash ./buildpkg.sh ${DEST} ;; \
 	hp_ux110 ) \
 		${COMPILE_PART1} packaging/HP-UX && swpackage -s  psf-1.2.10-transarc-paths-11.00 ;; \
 	hp_ux11i ) \
diff --git a/acinclude.m4 b/acinclude.m4
index 6e2c9ae..c14977a 100644
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -458,13 +458,13 @@ else
 			vm=${v#*.}
 			AFS_SYSNAME="amd64_obsd${vM}${vm}"
 			;;
-		i?86-*-freebsd?.*)
+		i?86-*-freebsd*.*)
 			v=${host#*freebsd}
 			vM=${v%.*}
 			vm=${v#*.}
 			AFS_SYSNAME="i386_fbsd_${vM}${vm}"
 			;;
-		x86_64-*-freebsd?.*)
+		x86_64-*-freebsd*.*)
 			v=${host#*freebsd}
 			vM=${v%.*}
 			vm=${v#*.}
@@ -793,6 +793,7 @@ case $AFS_SYSNAME in *_linux* | *_umlinux*)
 		 AC_CHECK_LINUX_STRUCT([backing_dev_info], [name],
 				       [backing-dev.h])
 		 AC_CHECK_LINUX_STRUCT([ctl_table], [ctl_name], [sysctl.h])
+		 AC_CHECK_LINUX_STRUCT([dentry_operations], [d_automount], [dcache.h])
 		 AC_CHECK_LINUX_STRUCT([inode], [i_alloc_sem], [fs.h])
 		 AC_CHECK_LINUX_STRUCT([inode], [i_blkbits], [fs.h])
 		 AC_CHECK_LINUX_STRUCT([inode], [i_blksize], [fs.h])
@@ -840,6 +841,9 @@ case $AFS_SYSNAME in *_linux* | *_umlinux*)
 #include <linux/page-flags.h>],
 				     [struct page *_page;
                                       int bchecked = PageFsMisc(_page);])
+		 AC_CHECK_LINUX_FUNC([clear_inode],
+				     [#include <linux/fs.h>],
+				     [clear_inode(NULL);])
 		 AC_CHECK_LINUX_FUNC([current_kernel_time],
 				     [#include <linux/time.h>],
 			             [struct timespec s;
@@ -887,6 +891,10 @@ case $AFS_SYSNAME in *_linux* | *_umlinux*)
 				     [#include <linux/fs.h>
 				      #include <linux/namei.h>],
 				     [path_lookup(NULL, 0, NULL);])
+		 AC_CHECK_LINUX_FUNC([putname],
+				     [#include <linux/fs.h>
+				      #include <linux/namei.h>],
+				     [putname(NULL);])
 		 AC_CHECK_LINUX_FUNC([rcu_read_lock],
 				     [#include <linux/rcupdate.h>],
 				     [rcu_read_lock();])
@@ -955,6 +963,13 @@ case $AFS_SYSNAME in *_linux* | *_umlinux*)
 		 LINUX_D_COUNT_IS_INT
 		 LINUX_IOP_MKDIR_TAKES_UMODE_T
 		 LINUX_IOP_CREATE_TAKES_UMODE_T
+		 LINUX_EXPORT_OP_ENCODE_FH_TAKES_INODES
+		 LINUX_KMAP_ATOMIC_TAKES_NO_KM_TYPE
+		 LINUX_DENTRY_OPEN_TAKES_PATH
+		 LINUX_D_ALIAS_IS_HLIST
+		 LINUX_IOP_I_CREATE_TAKES_BOOL
+		 LINUX_DOP_D_REVALIDATE_TAKES_UNSIGNED
+		 LINUX_IOP_LOOKUP_TAKES_UNSIGNED
 
 		 dnl If we are guaranteed that keyrings will work - that is
 		 dnl  a) The kernel has keyrings enabled
@@ -1319,7 +1334,7 @@ AC_CHECK_FUNCS(snprintf strlcat strlcpy flock getrlimit strnlen tsearch)
 AC_CHECK_FUNCS(setprogname getprogname sigaction mkstemp vsnprintf strerror strcasestr)
 AC_CHECK_FUNCS(setvbuf vsyslog getcwd)
 AC_CHECK_FUNCS(regcomp regexec regerror)
-AC_CHECK_FUNCS(fseeko64 ftello64 pread preadv pwrite pwritev preadv64 pwritev64)
+AC_CHECK_FUNCS(fseeko64 ftello64 poll pread preadv pwrite pwritev preadv64 pwritev64)
 AC_CHECK_FUNCS([setenv unsetenv])
 
 case $AFS_SYSNAME in
diff --git a/configure-libafs.ac b/configure-libafs.ac
index bf2f34d..ea83846 100644
--- a/configure-libafs.ac
+++ b/configure-libafs.ac
@@ -5,7 +5,7 @@ AC_CONFIG_SRCDIR(src/libafs/Makefile.common.in)
 AM_INIT_AUTOMAKE
 
 AC_CONFIG_HEADER(src/config/afsconfig.h)
-MACOS_VERSION=1.6.1
+MACOS_VERSION=1.6.1.1
 
 AC_SUBST(MACOS_VERSION)
 
diff --git a/configure.ac b/configure.ac
index bd8b7e9..2f3631d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -5,8 +5,8 @@ AC_CONFIG_SRCDIR([src/config/stds.h])
 AM_INIT_AUTOMAKE
 
 AC_CONFIG_HEADER(src/config/afsconfig.h)
-MACOS_VERSION=1.6.1
-LINUX_PKGVER=1.6.1
+MACOS_VERSION=1.6.1.1
+LINUX_PKGVER=1.6.1.1
 
 dnl Debian wants the release candidate version in the main upstream version,
 dnl and wants ~ before it.
@@ -55,6 +55,7 @@ AS_IF([test x"$KRB5_LIBS" != x],
         add_to_error_table \
         encode_krb5_enc_tkt_part \
         encode_krb5_ticket \
+	krb5_524_conv_principal \
         krb5_allow_weak_crypto \
         krb5_c_encrypt \
         krb5_decode_ticket \
@@ -68,6 +69,9 @@ AS_IF([test x"$KRB5_LIBS" != x],
              [AC_CHECK_LIB([krb524], [krb524_convert_creds_kdc],
                  [LIBS="-lkrb524 $LIBS"
                   KRB5_LIBS="-lkrb524 $KRB5_LIBS"
+		  AC_CHECK_LIB([krb524], [krb5_524_conv_principal],
+		  [AC_DEFINE([HAVE_KRB5_524_CONV_PRINCIPAL], 1,
+		     [Define to 1 if you have the `krb5_524_conv_principal' function.])])
                   AC_DEFINE([HAVE_KRB524_CONVERT_CREDS_KDC], 1,
                      [Define to 1 if you have the `krb524_convert_creds_kdc' function.])])])])
      AC_CHECK_HEADERS([kerberosIV/krb.h])
diff --git a/doc/man-pages/NTMakefile b/doc/man-pages/NTMakefile
index a00781d..cd4013c 100644
--- a/doc/man-pages/NTMakefile
+++ b/doc/man-pages/NTMakefile
@@ -37,6 +37,7 @@ PODS = \
         pod1\dlog.pod                  \
         pod1\fs.pod                    \
         pod1\fs_apropos.pod            \
+        pod1\fs_bypassthreshold.pod    \
         pod1\fs_checkservers.pod       \
         pod1\fs_checkvolumes.pod       \
         pod1\fs_chgrp.pod              \
@@ -352,6 +353,10 @@ clean::
         $(CD) html
         $(DEL) /s *.html
         $(CD) ..
+        $(DEL) pod1\fs_listquota.pod
+        $(DEL) pod1\fs_quota.pod
+        $(DEL) pod1\fs_setquota.pod
+        $(DEL) pod1\fs_setvol.pod
         $(DEL) pod1\pts_adduser.pod
         $(DEL) pod1\pts_chown.pod
         $(DEL) pod1\pts_creategroup.pod
@@ -370,8 +375,15 @@ clean::
         $(DEL) pod1\pts_setmax.pod
         $(DEL) pod1\pts_sleep.pod
         $(DEL) pod1\pts_source.pod
+        $(DEL) pod1\vos.pod
         $(DEL) pod1\vos_addsite.pod
+        $(DEL) pod1\vos_clone.pod
         $(DEL) pod1\vos_copy.pod
+        $(DEL) pod1\vos_create.pod
+        $(DEL) pod1\vos_examine.pod
+        $(DEL) pod1\vos_move.pod
+        $(DEL) pod1\vos_partinfo.pod
+        $(DEL) pod1\vos_shadow.pod
         $(DEL) pod1\vos_zap.pod
         $(DEL) pod8\dafileserver.pod
         $(DEL) pod8\dasalvager.pod
diff --git a/doc/man-pages/pod1/.gitignore b/doc/man-pages/pod1/.gitignore
index 1a1d4d6..97eb6d3 100644
--- a/doc/man-pages/pod1/.gitignore
+++ b/doc/man-pages/pod1/.gitignore
@@ -2,6 +2,10 @@
 #     git ls-files -i --exclude-standard
 # to check that you haven't inadvertently ignored any tracked files.
 
+/fs_listquota.pod
+/fs_quota.pod
+/fs_setquota.pod
+/fs_setvol.pod
 /pts_adduser.pod
 /pts_chown.pod
 /pts_creategroup.pod
@@ -20,6 +24,13 @@
 /pts_setmax.pod
 /pts_sleep.pod
 /pts_source.pod
+/vos.pod
 /vos_addsite.pod
 /vos_copy.pod
+/vos_clone.pod
+/vos_create.pod
+/vos_examine.pod
+/vos_move.pod
+/vos_partinfo.pod
+/vos_shadow.pod
 /vos_zap.pod
diff --git a/doc/man-pages/pod1/fragments/volsize-caution.pod b/doc/man-pages/pod1/fragments/volsize-caution.pod
new file mode 100644
index 0000000..a3d0759
--- /dev/null
+++ b/doc/man-pages/pod1/fragments/volsize-caution.pod
@@ -0,0 +1,5 @@
+Currently, the maximum quota for a volume is 2 terabytes (2^41 bytes). Note
+that this only affects the volume's quota; a volume may grow much larger if
+the volume quota is disabled. However, volumes over 2 terabytes in size may
+be impractical to move, and may have their size incorrectly reported by some
+tools, such as L<fs_listquota(1)>.
diff --git a/doc/man-pages/pod1/fs.pod b/doc/man-pages/pod1/fs.pod
index 0a4dd14..266505b 100644
--- a/doc/man-pages/pod1/fs.pod
+++ b/doc/man-pages/pod1/fs.pod
@@ -57,6 +57,7 @@ and L<B<fs whichcell>|fs_whichcell(1)>.
 =item *
 
 Commands to administer the local client cache and related information:
+L<B<fs bypassthreshold>|fs_bypassthreshold(1)>,
 L<B<fs checkvolumes>|fs_checkvolumes(1)>,
 L<B<fs cscpolicy>|fs_cscpolicy(1)>,
 L<B<fs flush>|fs_flush(1)>,
diff --git a/doc/man-pages/pod1/fs_bypassthreshold.pod b/doc/man-pages/pod1/fs_bypassthreshold.pod
new file mode 100644
index 0000000..51ab54e
--- /dev/null
+++ b/doc/man-pages/pod1/fs_bypassthreshold.pod
@@ -0,0 +1,99 @@
+=head1 NAME
+
+fs_bypassthreshold - get/set Cache Bypass file size threshold
+
+=head1 SYNOPSIS
+
+=for html
+<div class="synopsis">
+
+B<fs bypassthreshold> S<<< [B<-size> <I<file size>>] >>> [B<-help>]
+
+B<fs bypassthresh> S<<< [B<-s> <I<file size>>] >>> [B<-h>]
+
+=for html
+</div>
+
+=head1 DESCRIPTION
+
+The B<fs bypassthreshold> command either changes the AFS client Cache
+Bypass file size threshold, or reports the current threshold. Normally,
+when an application tries to read data via the OpenAFS client, the client
+will fetch the required data from the fileserver, store the results in
+the local cache, and then serve the application request from the local
+cache. When the Cache Bypass feature is enabled, certain files will be
+read directly from the network, and the data will not be saved to the
+local cache. In some scenarios, this can provide a significant
+performance improvement, especially if the data is only read once.
+
+Currently, the only way to specify which files should bypass the cache
+and which files should not, is by file size. In the future, different
+mechanisms may exist for specifying which files should bypass the local
+cache and which should not.
+
+If B<-size> is not specified, B<fs bypassthreshold> just reports the
+current threshold and exits.
+
+=head1 CAUTIONS
+
+Cache Bypass is still considered an experimental feature. Even in stable
+releases of OpenAFS, it is not considered as stable as the rest of OpenAFS.
+
+=head1 OPTIONS
+
+=over 4
+
+=item B<-size> <I<file size>>
+
+Specifies how large a file must be in order to enable Cache Bypass mode.
+If a file is larger than the specified file size (in bytes), reading from
+that file will bypass the local cache and be read directly from the
+network. A file size of -1 indicates that Cache Bypass should be disabled
+complete, so no files will enable Cache Bypass mode, no matter how large
+they are.
+
+By default, Cache Bypass is disabled.
+
+=item B<-help>
+
+Prints the online help for this command. All other valid options are
+ignored.
+
+=back
+
+=head1 OUTPUT
+
+The output format is identical whether or not B<-size> was specified. If
+B<-size> is specified, the bypass threshold is changed, and the output
+represents the new, changed, threshold. Otherwise the output represents
+the current threshold.
+
+=head1 EXAMPLES
+
+The following example turns on Cache Bypass with a threshold of 4KiB:
+
+   % fs bypassthreshold 4096
+   Cache bypass threshold 4096
+
+The following example disables Cache Bypass:
+
+   % fs bypassthreshold -1
+   Cache bypass threshold -1 (disabled)
+
+The following example examines the current Cache Bypass threshold:
+
+   % fs bypassthreshold
+   Cache bypass threshold 4096
+
+=head1 PRIVILEGE REQUIRED
+
+To set the bypass threshold, the issuer must be logged in as the local
+superuser C<root>. Otherwise, no privilege is required.
+
+=head1 COPYRIGHT
+
+Copyright 2012 Sine Nomine Associates
+
+This documentation is covered by the BSD License as written in the
+doc/LICENSE file. This man page was written by Andrew Deason for
+OpenAFS.
diff --git a/doc/man-pages/pod1/fs_listquota.pod b/doc/man-pages/pod1/fs_listquota.pod
deleted file mode 100644
index 385a449..0000000
--- a/doc/man-pages/pod1/fs_listquota.pod
+++ /dev/null
@@ -1,124 +0,0 @@
-=head1 NAME
-
-fs_listquota - Displays quota information for a volume
-
-=head1 SYNOPSIS
-
-=for html
-<div class="synopsis">
-
-B<fs listquota> S<<< [B<-path> <I<dir/file path>>+] >>> [B<-human>] [B<-help>]
-
-B<fs listq> S<<< [B<-p> <I<dir/file path>>+] >>> [B<-hu>] [B<-he>]
-
-B<fs lq> S<<< [B<-p> <I<dir/file path>>+] >>> [B<-hu>] [B<-he>]
-
-=for html
-</div>
-
-=head1 DESCRIPTION
-
-The B<fs listquota> command displays information about the volume
-containing each specified directory or file (its name, quota, and amount
-of disk space used), along with an indicator of the percentage of space
-used on the host partition.
-
-To display more information about the host partition, use the B<fs
-examine> command.
-
-To set volume quota, use the B<fs setquota> or B<fs setvol> command.
-
-=head1 CAUTIONS
-
-Currently, the maximum size of a volume is 2 terabytes (2^31 bytes).
-
-=head1 OPTIONS
-
-=over 4
-
-=item B<-path> <I<dir/file path>>+
-
-Names a file or directory that resides in the volume about which to
-produce output. Partial pathnames are interpreted relative to the current
-working directory, which is also the default value if this argument is
-omitted.
-
-=item B<-human>
-
-Print space in a "human-readable" format. Instead of always printing space
-in kilobytes, show disk space in kilobytes, megabytes, gigabytes,
-terabytes, or petabytes, as appropriate.
-
-=item B<-help>
-
-Prints the online help for this command. All other valid options are
-ignored.
-
-=back
-
-=head1 OUTPUT
-
-The output displays information about the volume that houses each
-specified directory or file, in a tabular format that uses the following
-headers:
-
-=over 4
-
-=item Volume Name
-
-The name of the volume.
-
-=item Quota
-
-The volume's quota in kilobytes, or the string C<no limit> to indicate an
-unlimited quota.
-
-=item Used
-
-The amount of space used. If B<-human> is not specified, this value is in
-kilobytes.
-
-=item % Used
-
-The percentage of the volume's quota that is used (the C<Used> statistic
-divided by the C<Quota> statistic, times 100).
-
-=item Partition
-
-The percentage of space used on the partition that houses the
-volume. Although not directly related to how much of the user's quota is
-used, it is reported because a full partition can cause writing of data
-back to the volume to fail even when the volume has not reached its quota.
-
-=back
-
-=head1 EXAMPLES
-
-The following example shows the output for the volume C<user.smith>:
-
-   % fs listquota -path /afs/abc.com/usr/smith
-   Volume Name     Quota    Used    % Used   Partition
-   user.smith      15000    5071       34%         86%
-
-=head1 PRIVILEGE REQUIRED
-
-The issuer must have the C<r> (read) permission on the ACL of the root
-directory of the volume that houses the file or directory named by the
-B<-path> argument, and C<l> (list) permission on the ACL of each 
-directory that precedes it in the pathname.
-
-=head1 SEE ALSO
-
-L<fs_diskfree(1)>,
-L<fs_examine(1)>,
-L<fs_quota(1)>,
-L<fs_setquota(1)>,
-L<fs_setvol(1)>
-
-=head1 COPYRIGHT
-
-IBM Corporation 2000. <http://www.ibm.com/> All Rights Reserved.
-
-This documentation is covered by the IBM Public License Version 1.0.  It was
-converted from HTML to POD by software written by Chas Williams and Russ
-Allbery, based on work by Alf Wachsmann and Elizabeth Cassell.
diff --git a/doc/man-pages/pod1/fs_listquota.pod.in b/doc/man-pages/pod1/fs_listquota.pod.in
new file mode 100644
index 0000000..6628c2b
--- /dev/null
+++ b/doc/man-pages/pod1/fs_listquota.pod.in
@@ -0,0 +1,124 @@
+=head1 NAME
+
+fs_listquota - Displays quota information for a volume
+
+=head1 SYNOPSIS
+
+=for html
+<div class="synopsis">
+
+B<fs listquota> S<<< [B<-path> <I<dir/file path>>+] >>> [B<-human>] [B<-help>]
+
+B<fs listq> S<<< [B<-p> <I<dir/file path>>+] >>> [B<-hu>] [B<-he>]
+
+B<fs lq> S<<< [B<-p> <I<dir/file path>>+] >>> [B<-hu>] [B<-he>]
+
+=for html
+</div>
+
+=head1 DESCRIPTION
+
+The B<fs listquota> command displays information about the volume
+containing each specified directory or file (its name, quota, and amount
+of disk space used), along with an indicator of the percentage of space
+used on the host partition.
+
+To display more information about the host partition, use the B<fs
+examine> command.
+
+To set volume quota, use the B<fs setquota> or B<fs setvol> command.
+
+=head1 CAUTIONS
+
+=include fragments/volsize-caution.pod
+
+=head1 OPTIONS
+
+=over 4
+
+=item B<-path> <I<dir/file path>>+
+
+Names a file or directory that resides in the volume about which to
+produce output. Partial pathnames are interpreted relative to the current
+working directory, which is also the default value if this argument is
+omitted.
+
+=item B<-human>
+
+Print space in a "human-readable" format. Instead of always printing space
+in kilobytes, show disk space in kilobytes, megabytes, gigabytes,
+terabytes, or petabytes, as appropriate.
+
+=item B<-help>
+
+Prints the online help for this command. All other valid options are
+ignored.
+
+=back
+
+=head1 OUTPUT
+
+The output displays information about the volume that houses each
+specified directory or file, in a tabular format that uses the following
+headers:
+
+=over 4
+
+=item Volume Name
+
+The name of the volume.
+
+=item Quota
+
+The volume's quota in kilobytes, or the string C<no limit> to indicate an
+unlimited quota.
+
+=item Used
+
+The amount of space used. If B<-human> is not specified, this value is in
+kilobytes.
+
+=item % Used
+
+The percentage of the volume's quota that is used (the C<Used> statistic
+divided by the C<Quota> statistic, times 100).
+
+=item Partition
+
+The percentage of space used on the partition that houses the
+volume. Although not directly related to how much of the user's quota is
+used, it is reported because a full partition can cause writing of data
+back to the volume to fail even when the volume has not reached its quota.
+
+=back
+
+=head1 EXAMPLES
+
+The following example shows the output for the volume C<user.smith>:
+
+   % fs listquota -path /afs/abc.com/usr/smith
+   Volume Name     Quota    Used    % Used   Partition
+   user.smith      15000    5071       34%         86%
+
+=head1 PRIVILEGE REQUIRED
+
+The issuer must have the C<r> (read) permission on the ACL of the root
+directory of the volume that houses the file or directory named by the
+B<-path> argument, and C<l> (list) permission on the ACL of each
+directory that precedes it in the pathname.
+
+=head1 SEE ALSO
+
+L<fs_diskfree(1)>,
+L<fs_examine(1)>,
+L<fs_quota(1)>,
+L<fs_setquota(1)>,
+L<fs_setvol(1)>
+
+=head1 COPYRIGHT
+
+IBM Corporation 2000. <http://www.ibm.com/> All Rights Reserved.
+
+This documentation is covered by the IBM Public License Version 1.0.  It was
+converted from HTML to POD by software written by Chas Williams and Russ
+Allbery, based on work by Alf Wachsmann and Elizabeth Cassell.
diff --git a/doc/man-pages/pod1/fs_newcell.pod b/doc/man-pages/pod1/fs_newcell.pod
index 2f5554e..3f31ba5 100644
--- a/doc/man-pages/pod1/fs_newcell.pod
+++ b/doc/man-pages/pod1/fs_newcell.pod
@@ -76,6 +76,42 @@ ignored.
 
 =back
 
+=head1 WINDOWS
+
+The B<fs newcell> command on Windows differs from the Unix version in a few ways.
+
+B<fs newcell> with no arguments discards the existing cell information.
+The Windows client will reload a cell's information the next time it
+needs the server list for a cell.
+
+Secondly, in addition to accepting the Unix options, B<fs newcell> on
+Windows accepts the following options:
+
+=over 4
+
+=item B<-dns>
+
+Adds the new cell to the cache manager, and obtains the VLDB server
+information from DNS.
+
+=item B<-registry>
+
+Adds the new cell to the cache manager, and also saves the cell
+configuration data in the registry for use the next time the service
+restarts.
+
+=item B<-vlport> <I<cell VLDB server port>>
+
+Specifies an alternate port number at which the cell's volume location
+database servers are listening.
+
+=item B<-fsport> <I<cell fileserver port>>
+
+Specifies an alternate port number at which the cell's file servers are
+listening.
+
+=back
+
 =head1 EXAMPLES
 
 The following example changes the machine's kernel-resident list of
diff --git a/doc/man-pages/pod1/fs_quota.pod b/doc/man-pages/pod1/fs_quota.pod
deleted file mode 100644
index d5c6afa..0000000
--- a/doc/man-pages/pod1/fs_quota.pod
+++ /dev/null
@@ -1,92 +0,0 @@
-=head1 NAME
-
-fs_quota - Displays the quota used in the volume containing a directory or file
-
-=head1 SYNOPSIS
-
-=for html
-<div class="synopsis">
-
-B<fs quota> S<<< [B<-path> <I<dir/file path>>+] >>> [B<-help>]
-
-B<fs q> S<<< [B<-p> <I<dir/file path>>+] >>> [B<-h>]
-
-=for html
-</div>
-
-=head1 DESCRIPTION
-
-The B<fs quota> command displays the percent of quota consumed in the
-volume that contains each specified directory or file.
-
-To display more detailed information about the volume and the partition it
-resides on, use the B<fs examine> and B<fs listquota> commands.
-
-To set volume quota, use the B<fs setquota> or B<fs setvol> command.
-
-=head1 CAUTIONS
-
-Currently, the maximum size of a volume is 2 terabytes (2^31 bytes).
-
-=head1 OPTIONS
-
-=over 4
-
-=item B<-path> <I<dir/file path>>
-
-Names each file or directory for which to display the quota consumed in
-its parent volume. Partial pathnames are interpreted relative to the
-current working directory, which is also the default value if this
-argument is omitted.
-
-=item B<-help>
-
-Prints the online help for this command. All other valid options are
-ignored.
-
-=back
-
-=head1 OUTPUT
-
-The output reports the percent of volume quota used, in the following
-format:
-
-   <percent>% of quota used.
-
-=head1 EXAMPLES
-
-The following command lists the percent quota used of the volume housing
-the current working directory:
-
-   % fs quota
-   17% of quota used.
-
-The following command lists the percent quota used of both the volume
-housing the current working directory's parent directory and the volume
-housing the directory F</afs/abc.com/usr/smith>:
-
-   % fs quota -path .. /afs/abc.com/usr/smith
-   43% of quota used.
-   92% of quota used.
-
-=head1 PRIVILEGE REQUIRED
-
-The issuer must have the C<r> (read) permission on the ACL of the root
-directory of the volume that houses the file or directory named by the
-B<-path> argument, and C<l> (list) permission on the ACL of each 
-directory that precedes it in the pathname.
-
-=head1 SEE ALSO
-
-L<fs_examine(1)>,
-L<fs_listquota(1)>,
-L<fs_setquota(1)>,
-L<fs_setvol(1)>
-
-=head1 COPYRIGHT
-
-IBM Corporation 2000. <http://www.ibm.com/> All Rights Reserved.
-
-This documentation is covered by the IBM Public License Version 1.0.  It was
-converted from HTML to POD by software written by Chas Williams and Russ
-Allbery, based on work by Alf Wachsmann and Elizabeth Cassell.
diff --git a/doc/man-pages/pod1/fs_quota.pod.in b/doc/man-pages/pod1/fs_quota.pod.in
new file mode 100644
index 0000000..b11337b
--- /dev/null
+++ b/doc/man-pages/pod1/fs_quota.pod.in
@@ -0,0 +1,92 @@
+=head1 NAME
+
+fs_quota - Displays the quota used in the volume containing a directory or file
+
+=head1 SYNOPSIS
+
+=for html
+<div class="synopsis">
+
+B<fs quota> S<<< [B<-path> <I<dir/file path>>+] >>> [B<-help>]
+
+B<fs q> S<<< [B<-p> <I<dir/file path>>+] >>> [B<-h>]
+
+=for html
+</div>
+
+=head1 DESCRIPTION
+
+The B<fs quota> command displays the percent of quota consumed in the
+volume that contains each specified directory or file.
+
+To display more detailed information about the volume and the partition it
+resides on, use the B<fs examine> and B<fs listquota> commands.
+
+To set volume quota, use the B<fs setquota> or B<fs setvol> command.
+
+=head1 CAUTIONS
+
+=include fragments/volsize-caution.pod
+
+=head1 OPTIONS
+
+=over 4
+
+=item B<-path> <I<dir/file path>>
+
+Names each file or directory for which to display the quota consumed in
+its parent volume. Partial pathnames are interpreted relative to the
+current working directory, which is also the default value if this
+argument is omitted.
+
+=item B<-help>
+
+Prints the online help for this command. All other valid options are
+ignored.
+
+=back
+
+=head1 OUTPUT
+
+The output reports the percent of volume quota used, in the following
+format:
+
+   <percent>% of quota used.
+
+=head1 EXAMPLES
+
+The following command lists the percent quota used of the volume housing
+the current working directory:
+
+   % fs quota
+   17% of quota used.
+
+The following command lists the percent quota used of both the volume
+housing the current working directory's parent directory and the volume
+housing the directory F</afs/abc.com/usr/smith>:
+
+   % fs quota -path .. /afs/abc.com/usr/smith
+   43% of quota used.
+   92% of quota used.
+
+=head1 PRIVILEGE REQUIRED
+
+The issuer must have the C<r> (read) permission on the ACL of the root
+directory of the volume that houses the file or directory named by the
+B<-path> argument, and C<l> (list) permission on the ACL of each
+directory that precedes it in the pathname.
+
+=head1 SEE ALSO
+
+L<fs_examine(1)>,
+L<fs_listquota(1)>,
+L<fs_setquota(1)>,
+L<fs_setvol(1)>
+
+=head1 COPYRIGHT
+
+IBM Corporation 2000. <http://www.ibm.com/> All Rights Reserved.
+
+This documentation is covered by the IBM Public License Version 1.0.  It was
+converted from HTML to POD by software written by Chas Williams and Russ
+Allbery, based on work by Alf Wachsmann and Elizabeth Cassell.
diff --git a/doc/man-pages/pod1/fs_setquota.pod b/doc/man-pages/pod1/fs_setquota.pod
deleted file mode 100644
index e79deee..0000000
--- a/doc/man-pages/pod1/fs_setquota.pod
+++ /dev/null
@@ -1,99 +0,0 @@
-=head1 NAME
-
-fs_setquota - Sets the quota for the volume containing a file or directory
-
-=head1 SYNOPSIS
-
-=for html
-<div class="synopsis">
-
-B<fs setquota> S<<< [B<-path> <I<dir/file path>>] >>>
-    S<<< B<-max> <I<max quota in kbytes>> >>> [B<-help>]
-
-B<fs setq> S<<< [B<-p> <I<dir/file path>>] >>> S<<< B<-m> <I<max quota>> >>> [B<-h>]
-
-B<fs sq> S<<< [B<-p> <I<dir/file path>>] >>> S<<< B<-m> <I<max quota>> >>> [B<-h>]
-
-=for html
-</div>
-
-=head1 DESCRIPTION
-
-The B<fs setquota> command sets the quota (maximum possible size) of the
-read/write volume that contains the directory or file named by the
-B<-path> argument.
-
-To set the quota on multiple volumes at the same time, use the B<fs
-setvol> command.
-
-To display a volume's quota, use the B<fs examine>, B<fs listquota>, or
-B<fs quota> command.
-
-=head1 CAUTIONS
-
-Currently, the maximum size of a volume is 2 terabytes (2^31 bytes).
-
-=head1 OPTIONS
-
-=over 4
-
-=item B<-path> <I<dir/file path>>
-
-Names the directory or file for which to set the host volume's
-quota. Partial pathnames are interpreted relative to the current working
-directory, which is also the default value if this argument is omitted.
-
-Specify the read/write path to the file or directory, to avoid the failure
-that results from attempting to change a read-only volume. By convention,
-the read/write path is indicated by placing a period before the cell name
-at the pathname's second level (for example, F</afs/.abc.com>). For
-further discussion of the concept of read/write and read-only paths
-through the filespace, see the B<fs mkmount> reference page.
-
-=item B<-max> <I<max quota>>
-
-Sets the maximum amount of file server disk space the volume can occupy.
-The quota value should be a positive integer followed by an optional
-suffix: C<K> for kibibytes (1024 bytes, the default), C<M> for mebibytes
-(1024 kibibytes), C<G> for gibibytes (1024 mebibytes), and C<T> for
-tebibytes (1024 gibibytes).  A value of C<0> sets an unlimited quota, but
-the size of the disk partition that houses the volume places an absolute
-limit on the volume's size.
-
-If the B<-path> argument is omitted (to set the quota of the volume
-housing the current working directory), the B<-max> switch must be
-included with this argument.
-
-=item B<-help>
-
-Prints the online help for this command. All other valid options are
-ignored.
-
-=back
-
-=head1 EXAMPLES
-
-The following command imposes a maximum quota of 3000 kilobytes on the
-volume that houses the F</afs/abc.com/usr/smith> directory:
-
-   % fs setquota -path /afs/abc.com/usr/smith -max 3000
-
-=head1 PRIVILEGE REQUIRED
-
-The issuer must belong to the system:administrators group.
-
-=head1 SEE ALSO
-
-L<fs_examine(1)>,
-L<fs_listquota(1)>,
-L<fs_quota(1)>,
-L<fs_mkmount(1)>,
-L<fs_setvol(1)>
-
-=head1 COPYRIGHT
-
-IBM Corporation 2000. <http://www.ibm.com/> All Rights Reserved.
-
-This documentation is covered by the IBM Public License Version 1.0.  It was
-converted from HTML to POD by software written by Chas Williams and Russ
-Allbery, based on work by Alf Wachsmann and Elizabeth Cassell.
diff --git a/doc/man-pages/pod1/fs_setquota.pod.in b/doc/man-pages/pod1/fs_setquota.pod.in
new file mode 100644
index 0000000..bffd992
--- /dev/null
+++ b/doc/man-pages/pod1/fs_setquota.pod.in
@@ -0,0 +1,99 @@
+=head1 NAME
+
+fs_setquota - Sets the quota for the volume containing a file or directory
+
+=head1 SYNOPSIS
+
+=for html
+<div class="synopsis">
+
+B<fs setquota> S<<< [B<-path> <I<dir/file path>>] >>>
+    S<<< B<-max> <I<max quota in kbytes>> >>> [B<-help>]
+
+B<fs setq> S<<< [B<-p> <I<dir/file path>>] >>> S<<< B<-m> <I<max quota>> >>> [B<-h>]
+
+B<fs sq> S<<< [B<-p> <I<dir/file path>>] >>> S<<< B<-m> <I<max quota>> >>> [B<-h>]
+
+=for html
+</div>
+
+=head1 DESCRIPTION
+
+The B<fs setquota> command sets the quota (maximum possible size) of the
+read/write volume that contains the directory or file named by the
+B<-path> argument.
+
+To set the quota on multiple volumes at the same time, use the B<fs
+setvol> command.
+
+To display a volume's quota, use the B<fs examine>, B<fs listquota>, or
+B<fs quota> command.
+
+=head1 CAUTIONS
+
+=include fragments/volsize-caution.pod
+
+=head1 OPTIONS
+
+=over 4
+
+=item B<-path> <I<dir/file path>>
+
+Names the directory or file for which to set the host volume's
+quota. Partial pathnames are interpreted relative to the current working
+directory, which is also the default value if this argument is omitted.
+
+Specify the read/write path to the file or directory, to avoid the failure
+that results from attempting to change a read-only volume. By convention,
+the read/write path is indicated by placing a period before the cell name
+at the pathname's second level (for example, F</afs/.abc.com>). For
+further discussion of the concept of read/write and read-only paths
+through the filespace, see the B<fs mkmount> reference page.
+
+=item B<-max> <I<max quota>>
+
+Sets the maximum amount of file server disk space the volume can occupy.
+The quota value should be a positive integer followed by an optional
+suffix: C<K> for kibibytes (1024 bytes, the default), C<M> for mebibytes
+(1024 kibibytes), C<G> for gibibytes (1024 mebibytes), and C<T> for
+tebibytes (1024 gibibytes).  A value of C<0> sets an unlimited quota, but
+the size of the disk partition that houses the volume places an absolute
+limit on the volume's size.
+
+If the B<-path> argument is omitted (to set the quota of the volume
+housing the current working directory), the B<-max> switch must be
+included with this argument.
+
+=item B<-help>
+
+Prints the online help for this command. All other valid options are
+ignored.
+
+=back
+
+=head1 EXAMPLES
+
+The following command imposes a maximum quota of 3000 kilobytes on the
+volume that houses the F</afs/abc.com/usr/smith> directory:
+
+   % fs setquota -path /afs/abc.com/usr/smith -max 3000
+
+=head1 PRIVILEGE REQUIRED
+
+The issuer must belong to the system:administrators group.
+
+=head1 SEE ALSO
+
+L<fs_examine(1)>,
+L<fs_listquota(1)>,
+L<fs_quota(1)>,
+L<fs_mkmount(1)>,
+L<fs_setvol(1)>
+
+=head1 COPYRIGHT
+
+IBM Corporation 2000. <http://www.ibm.com/> All Rights Reserved.
+
+This documentation is covered by the IBM Public License Version 1.0.  It was
+converted from HTML to POD by software written by Chas Williams and Russ
+Allbery, based on work by Alf Wachsmann and Elizabeth Cassell.
diff --git a/doc/man-pages/pod1/fs_setvol.pod b/doc/man-pages/pod1/fs_setvol.pod
deleted file mode 100644
index f09afbd..0000000
--- a/doc/man-pages/pod1/fs_setvol.pod
+++ /dev/null
@@ -1,113 +0,0 @@
-=head1 NAME
-
-fs_setvol - Set quota and messages for a volume containing a file or directory
-
-=head1 SYNOPSIS
-
-=for html
-<div class="synopsis">
-
-B<fs setvol> S<<< [B<-path> <I<dir/file path>>+] >>>
-    S<<< [B<-max> <I<disk space quota in 1K units>>] >>>
-    S<<< [B<-offlinemsg> <I<offline message>>] >>> [B<-help>]
-
-B<fs setv> S<<< [B<-p> <I<dir/file path>>+] >>>
-    S<<< [B<-ma> <I<disk space quota in 1K units>>] >>>
-    S<<< [B<-o> <I<offline message>>] >>> [B<-h>]
-
-B<fs sv> S<<< [B<-p> <I<dir/file path>>+] >>>
-    S<<< [B<-ma> <I<disk space quota in 1K units>>] >>>
-    S<<< [B<-o> <I<offline message>>] >>> [B<-h>]
-
-=for html
-</div>
-
-=head1 DESCRIPTION
-
-The B<fs setvol> command sets the quota (maximum possible size) of the
-read/write volume that contains each directory or file named by the
-B<-path> argument. To associate a message with the volume which then
-appears in the output of the B<fs examine> command, include the
-B<-offlinemsg> argument.
-
-To display all of the settings made with this command, use the B<fs
-examine> command. The B<fs listquota> command reports a fileset's quota,
-and the B<fs quota> command the percent of quota used.
-
-To set quota on one volume at a time, use the B<fs setquota> command.
-
-=head1 CAUTIONS
-
-Currently, the maximum size of a volume is 2 terabytes (2^31 bytes).
-
-=head1 OPTIONS
-
-=over 4
-
-=item B<-path> <I<dir/file path>>+
-
-Names each file or directory for which to set the host volume's quota and
-offline message. Partial pathnames are interpreted relative to the current
-working directory, which is also the default value if this argument is
-omitted.
-
-Specify the read/write path to the file or directory, to avoid the failure
-that results from attempting to change a read-only volume. By convention,
-the read/write path is indicated by placing a period before the cell name
-at the pathname's second level (for example, F</afs/.abc.com>). For
-further discussion of the concept of read/write and read-only paths
-through the filespace, see the B<fs mkmount> reference page.
-
-=item B<-max> <I<disk space quota in 1K units>>
-
-Sets the maximum amount of file server disk space the volume can
-occupy. Provide a positive integer to indicate the number of one-kilobyte
-blocks (C<1024> is one megabyte). A value of C<0> sets an unlimited quota,
-but the size of the disk partition that houses the volume places an
-absolute limit on the volume's size.
-
-If the B<-path> argument is omitted (so that the command sets the quota of
-the volume housing the current working directory), the B<-max> switch must
-be provided.
-
-=item B<-offlinemsg>
-
-Associates a message with the volume which then appears in the output of
-the B<fs examine> command. Its intended use is to explain why the volume
-is currently offline.
-
-=item B<-help>
-
-Prints the online help for this command. All other valid options are
-ignored.
-
-=back
-
-=head1 EXAMPLES
-
-The following command imposes a 6500 kilobyte quota on the volumes mounted
-at the home directories F</afs/abc.com/usr/smith> and
-F</afs/abc.com/usr/pat>:
-
-   % cd /afs/abc.com/usr
-   % fs setvol -path smith pat -max 6500B<>
-
-=head1 PRIVILEGE REQUIRED
-
-The issuer must belong to the system:administrators group.
-
-=head1 SEE ALSO
-
-L<fs_examine(1)>,
-L<fs_listquota(1)>,
-L<fs_mkmount(1)>,
-L<fs_quota(1)>,
-L<fs_setquota(1)>
-
-=head1 COPYRIGHT
-
-IBM Corporation 2000. <http://www.ibm.com/> All Rights Reserved.
-
-This documentation is covered by the IBM Public License Version 1.0.  It was
-converted from HTML to POD by software written by Chas Williams and Russ
-Allbery, based on work by Alf Wachsmann and Elizabeth Cassell.
diff --git a/doc/man-pages/pod1/fs_setvol.pod.in b/doc/man-pages/pod1/fs_setvol.pod.in
new file mode 100644
index 0000000..7ebcc31
--- /dev/null
+++ b/doc/man-pages/pod1/fs_setvol.pod.in
@@ -0,0 +1,113 @@
+=head1 NAME
+
+fs_setvol - Set quota and messages for a volume containing a file or directory
+
+=head1 SYNOPSIS
+
+=for html
+<div class="synopsis">
+
+B<fs setvol> S<<< [B<-path> <I<dir/file path>>+] >>>
+    S<<< [B<-max> <I<disk space quota in 1K units>>] >>>
+    S<<< [B<-offlinemsg> <I<offline message>>] >>> [B<-help>]
+
+B<fs setv> S<<< [B<-p> <I<dir/file path>>+] >>>
+    S<<< [B<-ma> <I<disk space quota in 1K units>>] >>>
+    S<<< [B<-o> <I<offline message>>] >>> [B<-h>]
+
+B<fs sv> S<<< [B<-p> <I<dir/file path>>+] >>>
+    S<<< [B<-ma> <I<disk space quota in 1K units>>] >>>
+    S<<< [B<-o> <I<offline message>>] >>> [B<-h>]
+
+=for html
+</div>
+
+=head1 DESCRIPTION
+
+The B<fs setvol> command sets the quota (maximum possible size) of the
+read/write volume that contains each directory or file named by the
+B<-path> argument. To associate a message with the volume which then
+appears in the output of the B<fs examine> command, include the
+B<-offlinemsg> argument.
+
+To display all of the settings made with this command, use the B<fs
+examine> command. The B<fs listquota> command reports a fileset's quota,
+and the B<fs quota> command the percent of quota used.
+
+To set quota on one volume at a time, use the B<fs setquota> command.
+
+=head1 CAUTIONS
+
+=include fragments/volsize-caution.pod
+
+=head1 OPTIONS
+
+=over 4
+
+=item B<-path> <I<dir/file path>>+
+
+Names each file or directory for which to set the host volume's quota and
+offline message. Partial pathnames are interpreted relative to the current
+working directory, which is also the default value if this argument is
+omitted.
+
+Specify the read/write path to the file or directory, to avoid the failure
+that results from attempting to change a read-only volume. By convention,
+the read/write path is indicated by placing a period before the cell name
+at the pathname's second level (for example, F</afs/.abc.com>). For
+further discussion of the concept of read/write and read-only paths
+through the filespace, see the B<fs mkmount> reference page.
+
+=item B<-max> <I<disk space quota in 1K units>>
+
+Sets the maximum amount of file server disk space the volume can
+occupy. Provide a positive integer to indicate the number of one-kilobyte
+blocks (C<1024> is one megabyte). A value of C<0> sets an unlimited quota,
+but the size of the disk partition that houses the volume places an
+absolute limit on the volume's size.
+
+If the B<-path> argument is omitted (so that the command sets the quota of
+the volume housing the current working directory), the B<-max> switch must
+be provided.
+
+=item B<-offlinemsg>
+
+Associates a message with the volume which then appears in the output of
+the B<fs examine> command. Its intended use is to explain why the volume
+is currently offline.
+
+=item B<-help>
+
+Prints the online help for this command. All other valid options are
+ignored.
+
+=back
+
+=head1 EXAMPLES
+
+The following command imposes a 6500 kilobyte quota on the volumes mounted
+at the home directories F</afs/abc.com/usr/smith> and
+F</afs/abc.com/usr/pat>:
+
+   % cd /afs/abc.com/usr
+   % fs setvol -path smith pat -max 6500B<>
+
+=head1 PRIVILEGE REQUIRED
+
+The issuer must belong to the system:administrators group.
+
+=head1 SEE ALSO
+
+L<fs_examine(1)>,
+L<fs_listquota(1)>,
+L<fs_mkmount(1)>,
+L<fs_quota(1)>,
+L<fs_setquota(1)>
+
+=head1 COPYRIGHT
+
+IBM Corporation 2000. <http://www.ibm.com/> All Rights Reserved.
+
+This documentation is covered by the IBM Public License Version 1.0.  It was
+converted from HTML to POD by software written by Chas Williams and Russ
+Allbery, based on work by Alf Wachsmann and Elizabeth Cassell.
diff --git a/doc/man-pages/pod1/vos.pod b/doc/man-pages/pod1/vos.pod
deleted file mode 100644
index fb100c5..0000000
--- a/doc/man-pages/pod1/vos.pod
+++ /dev/null
@@ -1,321 +0,0 @@
-=head1 NAME
-
-vos - Introduction to the vos command suite
-
-=head1 DESCRIPTION
-
-The commands in the B<vos> command suite are the administrative interface
-to the Volume Server and Volume Location (VL) Server. System
-administrators use B<vos> commands to create, move, delete, replicate,
-back up and examine volumes, among other operations. The VL Server
-automatically records in the Volume Location Database (VLDB) changes in
-volume status and location that result from B<vos> commands.
-
-The operations invoked by most B<vos> commands are idempotent, meaning
-that if an operation is interrupted by a network, server machine, or
-process outage, then a subsequent attempt at the same operation continues
-from the interruption point, rather than starting over at the beginning of
-the operation. Before executing a command, the Volume and VL Servers check
-the current state of the volumes and VLDB records to be altered by the
-command. If they are already in the desired end state (or a consistent
-intermediate state), there is no need to repeat the internal steps that
-brought them there. Idempotency does not apply if the command issuer
-explicitly interrupts the operation with the Ctrl-C command or another
-interrupt signal. In that case, the volume is left locked and the
-administrator must use the L<B<vos unlock>|vos_unlock(1)> command to
-unlock it before proceeding.
-
-It is important that the VLDB accurately indicate the status of the
-volumes on file server machines at all times. L<vldb.DB0(5)> and
-L<afs_volume_header(5)> describe the information recorded in the VLDB and
-volume headers, respectively. If a B<vos> command changes volume status,
-it automatically records the change in the corresponding VLDB entry. The
-most common cause of discrepancies between the VLDB and volume status on
-file server machines is interrupted operations; to restore consistency,
-use the L<B<vos syncserv>|vos_syncserv(1)> and
-L<B<vos syncvldb>|vos_syncvldb(1)> commands.
-
-There are several categories of commands in the vos command suite:
-
-=over 4
-
-=item *
-
-Commands to create, move, and rename volumes:
-L<B<vos backup>|vos_backup(1)>,
-L<B<vos backupsys>|vos_backupsys(1)>,
-L<B<vos changeloc>|vos_changeloc(1)>,
-L<B<vos create>|vos_create(1)>,
-L<B<vos move>|vos_move(1)>,
-and L<B<vos rename>|vos_rename(1)>.
-
-=item *
-
-Commands to remove VLDB volume records or volumes or both:
-L<B<vos delentry>|vos_delentry(1)>,
-L<B<vos remove>|vos_remove(1)>,
-and L<B<vos zap>|vos_zap(1)>.
-
-=item *
-
-Commands to edit or display VLDB server entries:
-L<B<vos changeaddr>|vos_changeaddr(1)>,
-L<B<vos listaddrs>|vos_listaddrs(1)>
-and L<B<vos setaddrs>|vos_setaddrs(1)>.
-
-=item *
-
-Commands to create, size, and restore dump files:
-L<B<vos dump>|vos_dump(1)>,
-L<B<vos restore>|vos_restore(1)>,
-and L<B<vos size>|vos_size(1)>.
-
-=item *
-
-Commands to administer replicated volumes:
-L<B<vos addsite>|vos_addsite(1)>,
-L<B<vos release>|vos_release(1)>,
-and L<B<vos remsite>|vos_remsite(1)>.
-
-=item *
-
-Commands to display VLDB records, volume headers, or both:
-L<B<vos examine>|vos_examine(1)>,
-L<B<vos listvldb>|vos_listvldb(1)>,
-and L<B<vos listvol>|vos_listvol(1)>.
-
-=item *
-
-Commands to display information about partitions that house volumes:
-L<B<vos listpart>|vos_listpart(1)>
-and L<B<vos partinfo>|vos_partinfo(1)>.
-
-=item *
-
-Commands to restore consistency between the VLDB and volume headers:
-L<B<vos syncserv>|vos_syncserv(1)>
-and L<B<vos syncvldb>|vos_syncvldb(1)>.
-
-=item *
-
-Commands to lock and unlock VLDB entries:
-L<B<vos lock>|vos_lock(1)>,
-L<B<vos unlock>|vos_unlock(1)>,
-and L<B<vos unlockvldb>|vos_unlockvldb(1)>.
-
-=item *
-
-A command to report Volume Server status:
-L<B<vos status>|vos_status(1)>.
-
-=item *
-
-A command to end Volume Server transactions:
-L<B<vos endtrans>|vos_endtrans(1)>.
-
-=item *
-
-A command to change volume fields:
-L<B<vos setfields>|vos_setfields(1)>.
-
-=item *
-
-Commands to obtain help:
-L<B<vos apropos>|vos_apropos(1)>
-and L<B<vos help>|vos_help(1)>.
-
-=back
-
-=head1 CAUTIONS
-
-Currently, the maximum size of a volume is 2 terabytes (2^31 bytes).
-
-=head1 OPTIONS
-
-The following arguments and flags are available on many commands in the
-B<bos> suite. The reference page for each command also lists them, but
-they are described here in greater detail.
-
-=over 4
-
-=item B<-cell> <I<cell name>>
-
-Names the cell in which to run the command. It is acceptable to abbreviate
-the cell name to the shortest form that distinguishes it from the other
-entries in the F</usr/vice/etc/CellServDB> file on the local machine. If
-the B<-cell> argument is omitted, the command interpreter determines the
-name of the local cell by reading the following in order:
-
-=over 4
-
-=item *
-
-The value of the AFSCELL environment variable.
-
-=item *
-
-The local F</usr/vice/etc/ThisCell> file.
-
-=back
-
-Do not combine the B<-cell> and B<-localauth> options. A command on which
-the B<-localauth> flag is included always runs in the local cell (as
-defined in the server machine's local F</usr/afs/etc/ThisCell> file),
-whereas a command on which the B<-cell> argument is included runs in the
-specified foreign cell.
-
-=item B<-help>
-
-Prints a command's online help message on the standard output stream. Do
-not combine this flag with any of the command's other options; when it is
-provided, the command interpreter ignores all other options, and only
-prints the help message.
-
-=item B<-localauth>
-
-Constructs a server ticket using the server encryption key with the
-highest key version number in the local F</usr/afs/etc/KeyFile> file. The
-B<vos> command interpreter presents the ticket, which never expires, to
-the Volume Server and VL Server during mutual authentication.
-
-Use this flag only when issuing a command on a server machine; client
-machines do not usually have a F</usr/afs/etc/KeyFile> file.  The issuer
-of a command that includes this flag must be logged on to the server
-machine as the local superuser C<root>. The flag is useful for commands
-invoked by an unattended application program, such as a process controlled
-by the UNIX B<cron> utility or by a cron entry in the machine's
-F</usr/afs/local/BosConfig> file. It is also useful if an administrator is
-unable to authenticate to AFS but is logged in as the local superuser
-B<root>.
-
-Do not combine the B<-cell> and B<-localauth> options. A command on which
-the B<-localauth> flag is included always runs in the local cell (as
-defined in the server machine's local F</usr/afs/etc/ThisCell> file),
-whereas a command on which the B<-cell> argument is included runs in the
-specified foreign cell. Also, do not combine the B<-localauth> and
-B<-noauth> flags.
-
-=item B<-noauth>
-
-Establishes an unauthenticated connection to the Volume Server and VL
-Server, in which the servers treat the issuer as the unprivileged user
-C<anonymous>. It is useful only when authorization checking is disabled on
-the server machine (during the installation of a file server machine or
-when the L<B<bos setauth>|bos_setauth(8)> command has been used during
-other unusual circumstances). In normal circumstances, the servers allow
-only privileged users to issue commands that change the status of a volume
-or VLDB record, and refuses to perform such an action even if the
-B<-noauth> flag is provided. Do not combine the B<-noauth> and
-B<-localauth> flags.
-
-=item B<-partition> <I<partition name>>
-
-Identifies the AFS server partition on a file server machine that houses,
-or is to house, the volumes of interest, or about which to list
-information. The B<vos> command interpreter accepts any of the following
-four name formats:
-
-   /vicepa     =     vicepa      =      a      =      0
-   /vicepb     =     vicepb      =      b      =      1
-
-After /vicepz (for which the index is 25) comes
-
-   /vicepaa    =     vicepaa     =      aa     =      26
-   /vicepab    =     vicepab     =      ab     =      27
-
-and so on through
-
-   /vicepiv    =     vicepiv     =      iv     =      255
-
-The B<-frompartition> and B<-topartition> arguments to the
-L<B<vos move>|vos_move(1)> command also accept this notation.
-
-=item B<-server> <I<machine name>>
-
-Identifies the file server machine that houses, or is to house, the
-volumes or AFS server partitions of interest. Provide the machine's IP
-address in dotted decimal format, its fully qualified host name (for
-example, C<fs1.abc.com>), or the shortest abbreviated form of its host
-name that distinguishes it from other machines. Successful use of an
-abbreviated form depends on the availability of a name resolution service
-(such as the Domain Name Service or a local host table) at the time the
-command is issued.
-
-The B<-fromserver> and B<-toserver> arguments to the
-L<B<vos move>|vos_move(1)> command also accept these name formats.
-
-=item B<-noresolve>
-
-Shows all servers as IP addresses instead of the DNS name. This is very
-useful when the server address is registered as 127.0.0.1 or when dealing
-with multi-homed servers. The B<-noresolve> option is available in OpenAFS
-versions 1.4.8 or later and 1.5.35 or later.
-
-=item B<-verbose>
-
-Produces on the standard output stream a detailed trace of the command's
-execution. If this argument is omitted, only warnings and error messages
-appear.
-
-=back
-
-=head1 PRIVILEGE REQUIRED
-
-To issue most vos commands, the issuer must be listed in the
-F</usr/afs/etc/UserList> file on each server machine that houses or is to
-house an affected volume, and on each database server machine. The most
-predictable performance results if all database server and file server
-machines in the cell share a common F<UserList> file.  Alternatively, if
-the B<-localauth> flag is included, the issuer must be logged on to a
-server machine as the local superuser C<root>.
-
-To issue a vos command that only displays information, no privilege is
-required.
-
-=head1 SEE ALSO
-
-L<vos_addsite(1)>,
-L<vos_apropos(1)>,
-L<vos_backup(1)>,
-L<vos_backupsys(1)>,
-L<vos_changeaddr(1)>,
-L<vos_convertROtoRW(1)>,
-L<vos_clone(1)>,
-L<vos_copy(1)>,
-L<vos_create(1)>,
-L<vos_delentry(1)>,
-L<vos_dump(1)>,
-L<vos_endtrans(1)>,
-L<vos_examine(1)>,
-L<vos_help(1)>,
-L<vos_listaddrs(1)>,
-L<vos_listpart(1)>,
-L<vos_listvldb(1)>,
-L<vos_listvol(1)>,
-L<vos_lock(1)>,
-L<vos_move(1)>,
-L<vos_partinfo(1)>,
-L<vos_release(1)>,
-L<vos_remove(1)>,
-L<vos_remsite(1)>,
-L<vos_rename(1)>,
-L<vos_restore(1)>,
-L<vos_setfields(1)>,
-L<vos_shadow(1)>,
-L<vos_size(1)>,
-L<vos_status(1)>,
-L<vos_syncserv(1)>,
-L<vos_syncvldb(1)>,
-L<vos_unlock(1)>,
-L<vos_unlockvldb(1)>,
-L<vos_zap(1)>,
-L<CellServDB(5)>,
-L<UserList(5)>
-
-=head1 COPYRIGHT
-
-IBM Corporation 2000. <http://www.ibm.com/> All Rights Reserved.
-
-This documentation is covered by the IBM Public License Version 1.0.  It was
-converted from HTML to POD by software written by Chas Williams and Russ
-Allbery, based on work by Alf Wachsmann and Elizabeth Cassell.
diff --git a/doc/man-pages/pod1/vos.pod.in b/doc/man-pages/pod1/vos.pod.in
new file mode 100644
index 0000000..101a5ed
--- /dev/null
+++ b/doc/man-pages/pod1/vos.pod.in
@@ -0,0 +1,321 @@
+=head1 NAME
+
+vos - Introduction to the vos command suite
+
+=head1 DESCRIPTION
+
+The commands in the B<vos> command suite are the administrative interface
+to the Volume Server and Volume Location (VL) Server. System
+administrators use B<vos> commands to create, move, delete, replicate,
+back up and examine volumes, among other operations. The VL Server
+automatically records in the Volume Location Database (VLDB) changes in
+volume status and location that result from B<vos> commands.
+
+The operations invoked by most B<vos> commands are idempotent, meaning
+that if an operation is interrupted by a network, server machine, or
+process outage, then a subsequent attempt at the same operation continues
+from the interruption point, rather than starting over at the beginning of
+the operation. Before executing a command, the Volume and VL Servers check
+the current state of the volumes and VLDB records to be altered by the
+command. If they are already in the desired end state (or a consistent
+intermediate state), there is no need to repeat the internal steps that
+brought them there. Idempotency does not apply if the command issuer
+explicitly interrupts the operation with the Ctrl-C command or another
+interrupt signal. In that case, the volume is left locked and the
+administrator must use the L<B<vos unlock>|vos_unlock(1)> command to
+unlock it before proceeding.
+
+It is important that the VLDB accurately indicate the status of the
+volumes on file server machines at all times. L<vldb.DB0(5)> and
+L<afs_volume_header(5)> describe the information recorded in the VLDB and
+volume headers, respectively. If a B<vos> command changes volume status,
+it automatically records the change in the corresponding VLDB entry. The
+most common cause of discrepancies between the VLDB and volume status on
+file server machines is interrupted operations; to restore consistency,
+use the L<B<vos syncserv>|vos_syncserv(1)> and
+L<B<vos syncvldb>|vos_syncvldb(1)> commands.
+
+There are several categories of commands in the vos command suite:
+
+=over 4
+
+=item *
+
+Commands to create, move, and rename volumes:
+L<B<vos backup>|vos_backup(1)>,
+L<B<vos backupsys>|vos_backupsys(1)>,
+L<B<vos changeloc>|vos_changeloc(1)>,
+L<B<vos create>|vos_create(1)>,
+L<B<vos move>|vos_move(1)>,
+and L<B<vos rename>|vos_rename(1)>.
+
+=item *
+
+Commands to remove VLDB volume records or volumes or both:
+L<B<vos delentry>|vos_delentry(1)>,
+L<B<vos remove>|vos_remove(1)>,
+and L<B<vos zap>|vos_zap(1)>.
+
+=item *
+
+Commands to edit or display VLDB server entries:
+L<B<vos changeaddr>|vos_changeaddr(1)>,
+L<B<vos listaddrs>|vos_listaddrs(1)>
+and L<B<vos setaddrs>|vos_setaddrs(1)>.
+
+=item *
+
+Commands to create, size, and restore dump files:
+L<B<vos dump>|vos_dump(1)>,
+L<B<vos restore>|vos_restore(1)>,
+and L<B<vos size>|vos_size(1)>.
+
+=item *
+
+Commands to administer replicated volumes:
+L<B<vos addsite>|vos_addsite(1)>,
+L<B<vos release>|vos_release(1)>,
+and L<B<vos remsite>|vos_remsite(1)>.
+
+=item *
+
+Commands to display VLDB records, volume headers, or both:
+L<B<vos examine>|vos_examine(1)>,
+L<B<vos listvldb>|vos_listvldb(1)>,
+and L<B<vos listvol>|vos_listvol(1)>.
+
+=item *
+
+Commands to display information about partitions that house volumes:
+L<B<vos listpart>|vos_listpart(1)>
+and L<B<vos partinfo>|vos_partinfo(1)>.
+
+=item *
+
+Commands to restore consistency between the VLDB and volume headers:
+L<B<vos syncserv>|vos_syncserv(1)>
+and L<B<vos syncvldb>|vos_syncvldb(1)>.
+
+=item *
+
+Commands to lock and unlock VLDB entries:
+L<B<vos lock>|vos_lock(1)>,
+L<B<vos unlock>|vos_unlock(1)>,
+and L<B<vos unlockvldb>|vos_unlockvldb(1)>.
+
+=item *
+
+A command to report Volume Server status:
+L<B<vos status>|vos_status(1)>.
+
+=item *
+
+A command to end Volume Server transactions:
+L<B<vos endtrans>|vos_endtrans(1)>.
+
+=item *
+
+A command to change volume fields:
+L<B<vos setfields>|vos_setfields(1)>.
+
+=item *
+
+Commands to obtain help:
+L<B<vos apropos>|vos_apropos(1)>
+and L<B<vos help>|vos_help(1)>.
+
+=back
+
+=head1 CAUTIONS
+
+=include fragments/volsize-caution.pod
+
+=head1 OPTIONS
+
+The following arguments and flags are available on many commands in the
+B<bos> suite. The reference page for each command also lists them, but
+they are described here in greater detail.
+
+=over 4
+
+=item B<-cell> <I<cell name>>
+
+Names the cell in which to run the command. It is acceptable to abbreviate
+the cell name to the shortest form that distinguishes it from the other
+entries in the F</usr/vice/etc/CellServDB> file on the local machine. If
+the B<-cell> argument is omitted, the command interpreter determines the
+name of the local cell by reading the following in order:
+
+=over 4
+
+=item *
+
+The value of the AFSCELL environment variable.
+
+=item *
+
+The local F</usr/vice/etc/ThisCell> file.
+
+=back
+
+Do not combine the B<-cell> and B<-localauth> options. A command on which
+the B<-localauth> flag is included always runs in the local cell (as
+defined in the server machine's local F</usr/afs/etc/ThisCell> file),
+whereas a command on which the B<-cell> argument is included runs in the
+specified foreign cell.
+
+=item B<-help>
+
+Prints a command's online help message on the standard output stream. Do
+not combine this flag with any of the command's other options; when it is
+provided, the command interpreter ignores all other options, and only
+prints the help message.
+
+=item B<-localauth>
+
+Constructs a server ticket using the server encryption key with the
+highest key version number in the local F</usr/afs/etc/KeyFile> file. The
+B<vos> command interpreter presents the ticket, which never expires, to
+the Volume Server and VL Server during mutual authentication.
+
+Use this flag only when issuing a command on a server machine; client
+machines do not usually have a F</usr/afs/etc/KeyFile> file.  The issuer
+of a command that includes this flag must be logged on to the server
+machine as the local superuser C<root>. The flag is useful for commands
+invoked by an unattended application program, such as a process controlled
+by the UNIX B<cron> utility or by a cron entry in the machine's
+F</usr/afs/local/BosConfig> file. It is also useful if an administrator is
+unable to authenticate to AFS but is logged in as the local superuser
+B<root>.
+
+Do not combine the B<-cell> and B<-localauth> options. A command on which
+the B<-localauth> flag is included always runs in the local cell (as
+defined in the server machine's local F</usr/afs/etc/ThisCell> file),
+whereas a command on which the B<-cell> argument is included runs in the
+specified foreign cell. Also, do not combine the B<-localauth> and
+B<-noauth> flags.
+
+=item B<-noauth>
+
+Establishes an unauthenticated connection to the Volume Server and VL
+Server, in which the servers treat the issuer as the unprivileged user
+C<anonymous>. It is useful only when authorization checking is disabled on
+the server machine (during the installation of a file server machine or
+when the L<B<bos setauth>|bos_setauth(8)> command has been used during
+other unusual circumstances). In normal circumstances, the servers allow
+only privileged users to issue commands that change the status of a volume
+or VLDB record, and refuses to perform such an action even if the
+B<-noauth> flag is provided. Do not combine the B<-noauth> and
+B<-localauth> flags.
+
+=item B<-partition> <I<partition name>>
+
+Identifies the AFS server partition on a file server machine that houses,
+or is to house, the volumes of interest, or about which to list
+information. The B<vos> command interpreter accepts any of the following
+four name formats:
+
+   /vicepa     =     vicepa      =      a      =      0
+   /vicepb     =     vicepb      =      b      =      1
+
+After /vicepz (for which the index is 25) comes
+
+   /vicepaa    =     vicepaa     =      aa     =      26
+   /vicepab    =     vicepab     =      ab     =      27
+
+and so on through
+
+   /vicepiv    =     vicepiv     =      iv     =      255
+
+The B<-frompartition> and B<-topartition> arguments to the
+L<B<vos move>|vos_move(1)> command also accept this notation.
+
+=item B<-server> <I<machine name>>
+
+Identifies the file server machine that houses, or is to house, the
+volumes or AFS server partitions of interest. Provide the machine's IP
+address in dotted decimal format, its fully qualified host name (for
+example, C<fs1.abc.com>), or the shortest abbreviated form of its host
+name that distinguishes it from other machines. Successful use of an
+abbreviated form depends on the availability of a name resolution service
+(such as the Domain Name Service or a local host table) at the time the
+command is issued.
+
+The B<-fromserver> and B<-toserver> arguments to the
+L<B<vos move>|vos_move(1)> command also accept these name formats.
+
+=item B<-noresolve>
+
+Shows all servers as IP addresses instead of the DNS name. This is very
+useful when the server address is registered as 127.0.0.1 or when dealing
+with multi-homed servers. The B<-noresolve> option is available in OpenAFS
+versions 1.4.8 or later and 1.5.35 or later.
+
+=item B<-verbose>
+
+Produces on the standard output stream a detailed trace of the command's
+execution. If this argument is omitted, only warnings and error messages
+appear.
+
+=back
+
+=head1 PRIVILEGE REQUIRED
+
+To issue most vos commands, the issuer must be listed in the
+F</usr/afs/etc/UserList> file on each server machine that houses or is to
+house an affected volume, and on each database server machine. The most
+predictable performance results if all database server and file server
+machines in the cell share a common F<UserList> file.  Alternatively, if
+the B<-localauth> flag is included, the issuer must be logged on to a
+server machine as the local superuser C<root>.
+
+To issue a vos command that only displays information, no privilege is
+required.
+
+=head1 SEE ALSO
+
+L<vos_addsite(1)>,
+L<vos_apropos(1)>,
+L<vos_backup(1)>,
+L<vos_backupsys(1)>,
+L<vos_changeaddr(1)>,
+L<vos_convertROtoRW(1)>,
+L<vos_clone(1)>,
+L<vos_copy(1)>,
+L<vos_create(1)>,
+L<vos_delentry(1)>,
+L<vos_dump(1)>,
+L<vos_endtrans(1)>,
+L<vos_examine(1)>,
+L<vos_help(1)>,
+L<vos_listaddrs(1)>,
+L<vos_listpart(1)>,
+L<vos_listvldb(1)>,
+L<vos_listvol(1)>,
+L<vos_lock(1)>,
+L<vos_move(1)>,
+L<vos_partinfo(1)>,
+L<vos_release(1)>,
+L<vos_remove(1)>,
+L<vos_remsite(1)>,
+L<vos_rename(1)>,
+L<vos_restore(1)>,
+L<vos_setfields(1)>,
+L<vos_shadow(1)>,
+L<vos_size(1)>,
+L<vos_status(1)>,
+L<vos_syncserv(1)>,
+L<vos_syncvldb(1)>,
+L<vos_unlock(1)>,
+L<vos_unlockvldb(1)>,
+L<vos_zap(1)>,
+L<CellServDB(5)>,
+L<UserList(5)>
+
+=head1 COPYRIGHT
+
+IBM Corporation 2000. <http://www.ibm.com/> All Rights Reserved.
+
+This documentation is covered by the IBM Public License Version 1.0.  It was
+converted from HTML to POD by software written by Chas Williams and Russ
+Allbery, based on work by Alf Wachsmann and Elizabeth Cassell.
diff --git a/doc/man-pages/pod1/vos_clone.pod b/doc/man-pages/pod1/vos_clone.pod
deleted file mode 100644
index 13b6c9f..0000000
--- a/doc/man-pages/pod1/vos_clone.pod
+++ /dev/null
@@ -1,172 +0,0 @@
-=head1 NAME
-
-vos_clone - Creates a shared-space copy of a volume on a partition
-
-=head1 SYNOPSIS
-
-=for html
-<div class="synopsis">
-
-B<vos clone> S<<< [B<-id>] <I<volume name or ID>> >>>
-    S<<< [B<-server>] <I<server name>> >>>
-    S<<< [B<-partition>] <I<partition name>> >>>
-    S<<< [B<-toname> <I<volume name on destination>>] >>>
-    S<<< [B<-toid> <I<volume ID on destination>>] >>>
-    [B<-offline>] [B<-readonly>]
-    S<<< [B<-cell> <I<cell name>>] >>> [B<-noauth>] [B<-localauth>]
-    [B<-verbose>] [B<-encrypt>] [B<-noresolve>] [B<-help>]
-
-B<vos cl> S<<< [B<-i>] <I<volume name or ID>> >>>
-    S<<< [B<-s>] <I<server name>> >>>
-    S<<< [B<-p>] <I<partition name>> >>>
-    S<<< [B<-ton> <I<volume name on destination>>] >>>
-    S<<< [B<-toi> <I<volume ID on destination>>] >>> [B<-o>] [B<-r>]
-    S<<< [B<-c> <I<cell name>>] >>> [B<-noa>]
-    [B<-l>] [B<-v>] [B<-e>] [B<-nor>] [B<-h>]
-
-=for html
-</div>
-
-=head1 DESCRIPTION
-
-The B<vos clone> command creates a copy-on-write copy of a volume on the
-same partition and server as the parent volume.
-
-A clone is a copy of a volume that only stores the changes from the
-parent volume. Cloning is a primitive operation that is used by the B<vos
-move>, B<vos backup>, and B<vos release> commands. A clone functions using
-the same mechanism as a backup volume, but it is persistent. Clone volumes
-can be used as point-in-time copies of the parent volume, but they must be
-used with care.
-
-=head1 CAUTIONS
-
-This command is not used during normal OpenAFS administration and may
-have adverse effects on the VLDB if not used properly! This command
-should only be used by an expert.
-
-Deleting or moving the parent volume makes the clone volume inaccessible,
-but the clone volume remains in the VLDB and on disk, and it needs to be
-cleaned up manually.
-
-There is a maximum limitation of 7 clones when using the namei
-fileserver. You may safely create up to 4 clones using the B<vos clone>
-command. The other three clone slots are used by the backup volume, a
-read-only replica and the temporary clone that is created when executing a
-B<vos move>, B<vos dump>, or other B<vos> commands.
-
-Some commands do not work properly on clone volumes. B<vos move> is one
-such command.
-
-Currently, the maximum size of a volume is 2 terabytes (2^31 bytes).
-
-=head1 OPTIONS
-
-=over 4
-
-=item [B<-id>] <I<volume name or ID>>
-
-Specifies either the complete name or volume ID number of a read/write
-volume.
-
-=item [B<-server>] <I<machine name>>
-
-Identifies the file server machine where the source volume resides. Provide
-the machine's IP address or its host name (either fully qualified or using
-an unambiguous abbreviation). For details, see L<vos(1)>.
-
-=item [B<-partition>] <I<partition name>>
-
-Names the partition where the source volume resides. Provide the full
-partition name (for, example, B</vicepa>) or one of the abbreviated forms
-described in L<vos(1)>.
-
-=item B<-toname> <I<volume name for new copy>>
-
-The complete name of the new volume to create.
-
-=item B<-toid> <I<volume id for new copy>>
-
-The complete id of the new volume to create.
-
-=item B<-offline>
-
-Leaves the new volume flagged as off-line in the volume database.
-
-=item B<-readonly>
-
-Flags the new volume as read-only in the volume database.
-
-=item B<-cell> <I<cell name>>
-
-Names the cell in which to run the command. Do not combine this argument
-with the B<-localauth> flag. For more details, see L<vos(1)>.
-
-=item B<-noauth>
-
-Assigns the unprivileged identity C<anonymous> to the issuer. Do not
-combine this flag with the B<-localauth> flag. For more details, see
-L<vos(1)>.
-
-=item B<-localauth>
-
-Constructs a server ticket using a key from the local
-F</usr/afs/etc/KeyFile> file. The B<vos> command interpreter presents
-it to the Volume Server and Volume Location Server during mutual
-authentication. Do not combine this flag with the B<-cell> argument or
-B<-noauth> flag. For more details, see L<vos(1)>.
-
-=item B<-verbose>
-
-Produces on the standard output stream a detailed trace of the command's
-execution. If this argument is omitted, only warnings and error messages
-appear.
-
-=item B<-encrypt>
-
-Encrypts the command so that the operation's results are not transmitted
-across the network in clear text. This option is available in OpenAFS
-versions 1.4.11 or later and 1.5.60 or later.
-
-=item B<-noresolve>
-
-Shows all servers as IP addresses instead of the DNS name. This is very
-useful when the server address is registered as 127.0.0.1 or when dealing
-with multi-homed servers. This option is available in OpenAFS
-versions 1.4.8 or later and 1.5.35 or later.
-
-=item B<-help>
-
-Prints the online help for this command. All other valid options are
-ignored.
-
-=back
-
-=head1 OUTPUT
-
-This command has no output unless C<-verbose> is specified or there is
-an error.
-
-=head1 PRIVILEGE REQUIRED
-
-The issuer must be listed in the F</usr/afs/etc/UserList> file on the
-machines specified with the B<-toserver> and B<-fromserver> arguments and
-on each database server machine.  If the B<-localauth> flag is included,
-the issuer must instead be logged on to a server machine as the local
-superuser C<root>.
-
-=head1 SEE ALSO
-
-L<vos(1)>,
-L<vos_backup(1)>,
-L<vos_copy(1)>,
-L<vos_move(1)>,
-L<vos_shadow(1)>
-
-=head1 COPYRIGHT
-
-Copyright 2008 Jason Edgecombe <jason@rampaginggeek.com>
-
-This documentation is covered by the BSD License as written in the
-doc/LICENSE file. This man page was written by Jason Edgecombe for
-OpenAFS.
diff --git a/doc/man-pages/pod1/vos_clone.pod.in b/doc/man-pages/pod1/vos_clone.pod.in
new file mode 100644
index 0000000..34fdcd6
--- /dev/null
+++ b/doc/man-pages/pod1/vos_clone.pod.in
@@ -0,0 +1,172 @@
+=head1 NAME
+
+vos_clone - Creates a shared-space copy of a volume on a partition
+
+=head1 SYNOPSIS
+
+=for html
+<div class="synopsis">
+
+B<vos clone> S<<< [B<-id>] <I<volume name or ID>> >>>
+    S<<< [B<-server>] <I<server name>> >>>
+    S<<< [B<-partition>] <I<partition name>> >>>
+    S<<< [B<-toname> <I<volume name on destination>>] >>>
+    S<<< [B<-toid> <I<volume ID on destination>>] >>>
+    [B<-offline>] [B<-readonly>]
+    S<<< [B<-cell> <I<cell name>>] >>> [B<-noauth>] [B<-localauth>]
+    [B<-verbose>] [B<-encrypt>] [B<-noresolve>] [B<-help>]
+
+B<vos cl> S<<< [B<-i>] <I<volume name or ID>> >>>
+    S<<< [B<-s>] <I<server name>> >>>
+    S<<< [B<-p>] <I<partition name>> >>>
+    S<<< [B<-ton> <I<volume name on destination>>] >>>
+    S<<< [B<-toi> <I<volume ID on destination>>] >>> [B<-o>] [B<-r>]
+    S<<< [B<-c> <I<cell name>>] >>> [B<-noa>]
+    [B<-l>] [B<-v>] [B<-e>] [B<-nor>] [B<-h>]
+
+=for html
+</div>
+
+=head1 DESCRIPTION
+
+The B<vos clone> command creates a copy-on-write copy of a volume on the
+same partition and server as the parent volume.
+
+A clone is a copy of a volume that only stores the changes from the
+parent volume. Cloning is a primitive operation that is used by the B<vos
+move>, B<vos backup>, and B<vos release> commands. A clone functions using
+the same mechanism as a backup volume, but it is persistent. Clone volumes
+can be used as point-in-time copies of the parent volume, but they must be
+used with care.
+
+=head1 CAUTIONS
+
+This command is not used during normal OpenAFS administration and may
+have adverse effects on the VLDB if not used properly! This command
+should only be used by an expert.
+
+Deleting or moving the parent volume makes the clone volume inaccessible,
+but the clone volume remains in the VLDB and on disk, and it needs to be
+cleaned up manually.
+
+There is a maximum limitation of 7 clones when using the namei
+fileserver. You may safely create up to 4 clones using the B<vos clone>
+command. The other three clone slots are used by the backup volume, a
+read-only replica and the temporary clone that is created when executing a
+B<vos move>, B<vos dump>, or other B<vos> commands.
+
+Some commands do not work properly on clone volumes. B<vos move> is one
+such command.
+
+=include fragments/volsize-caution.pod
+
+=head1 OPTIONS
+
+=over 4
+
+=item [B<-id>] <I<volume name or ID>>
+
+Specifies either the complete name or volume ID number of a read/write
+volume.
+
+=item [B<-server>] <I<machine name>>
+
+Identifies the file server machine where the source volume resides. Provide
+the machine's IP address or its host name (either fully qualified or using
+an unambiguous abbreviation). For details, see L<vos(1)>.
+
+=item [B<-partition>] <I<partition name>>
+
+Names the partition where the source volume resides. Provide the full
+partition name (for, example, B</vicepa>) or one of the abbreviated forms
+described in L<vos(1)>.
+
+=item B<-toname> <I<volume name for new copy>>
+
+The complete name of the new volume to create.
+
+=item B<-toid> <I<volume id for new copy>>
+
+The complete id of the new volume to create.
+
+=item B<-offline>
+
+Leaves the new volume flagged as off-line in the volume database.
+
+=item B<-readonly>
+
+Flags the new volume as read-only in the volume database.
+
+=item B<-cell> <I<cell name>>
+
+Names the cell in which to run the command. Do not combine this argument
+with the B<-localauth> flag. For more details, see L<vos(1)>.
+
+=item B<-noauth>
+
+Assigns the unprivileged identity C<anonymous> to the issuer. Do not
+combine this flag with the B<-localauth> flag. For more details, see
+L<vos(1)>.
+
+=item B<-localauth>
+
+Constructs a server ticket using a key from the local
+F</usr/afs/etc/KeyFile> file. The B<vos> command interpreter presents
+it to the Volume Server and Volume Location Server during mutual
+authentication. Do not combine this flag with the B<-cell> argument or
+B<-noauth> flag. For more details, see L<vos(1)>.
+
+=item B<-verbose>
+
+Produces on the standard output stream a detailed trace of the command's
+execution. If this argument is omitted, only warnings and error messages
+appear.
+
+=item B<-encrypt>
+
+Encrypts the command so that the operation's results are not transmitted
+across the network in clear text. This option is available in OpenAFS
+versions 1.4.11 or later and 1.5.60 or later.
+
+=item B<-noresolve>
+
+Shows all servers as IP addresses instead of the DNS name. This is very
+useful when the server address is registered as 127.0.0.1 or when dealing
+with multi-homed servers. This option is available in OpenAFS
+versions 1.4.8 or later and 1.5.35 or later.
+
+=item B<-help>
+
+Prints the online help for this command. All other valid options are
+ignored.
+
+=back
+
+=head1 OUTPUT
+
+This command has no output unless C<-verbose> is specified or there is
+an error.
+
+=head1 PRIVILEGE REQUIRED
+
+The issuer must be listed in the F</usr/afs/etc/UserList> file on the
+machines specified with the B<-toserver> and B<-fromserver> arguments and
+on each database server machine.  If the B<-localauth> flag is included,
+the issuer must instead be logged on to a server machine as the local
+superuser C<root>.
+
+=head1 SEE ALSO
+
+L<vos(1)>,
+L<vos_backup(1)>,
+L<vos_copy(1)>,
+L<vos_move(1)>,
+L<vos_shadow(1)>
+
+=head1 COPYRIGHT
+
+Copyright 2008 Jason Edgecombe <jason@rampaginggeek.com>
+
+This documentation is covered by the BSD License as written in the
+doc/LICENSE file. This man page was written by Jason Edgecombe for
+OpenAFS.
diff --git a/doc/man-pages/pod1/vos_convertROtoRW.pod b/doc/man-pages/pod1/vos_convertROtoRW.pod
index 580993c..56f71d2 100644
--- a/doc/man-pages/pod1/vos_convertROtoRW.pod
+++ b/doc/man-pages/pod1/vos_convertROtoRW.pod
@@ -116,7 +116,7 @@ partition vicepb on server1 to a read-write volume:
 =head1 PRIVILEGE REQUIRED
 
 The issuer must be listed in the F</usr/afs/etc/UserList> file on the
-machines specified with the B<-toserver> and B<-fromserver> arguments and
+machine specified with the B<-server> argument and
 on each database server machine.  If the B<-localauth> flag is included,
 the issuer must instead be logged on to a server machine as the local
 superuser C<root>.
diff --git a/doc/man-pages/pod1/vos_copy.pod.in b/doc/man-pages/pod1/vos_copy.pod.in
index 50cc0a0..dfbfaa6 100644
--- a/doc/man-pages/pod1/vos_copy.pod.in
+++ b/doc/man-pages/pod1/vos_copy.pod.in
@@ -38,7 +38,7 @@ the volume be stored locally by the client.
 
 =head1 CAUTIONS
 
-Currently, the maximum size of a volume is 2 terabytes (2^31 bytes).
+=include fragments/volsize-caution.pod
 
 =head1 OPTIONS
 
diff --git a/doc/man-pages/pod1/vos_create.pod b/doc/man-pages/pod1/vos_create.pod
deleted file mode 100644
index 89dad2c..0000000
--- a/doc/man-pages/pod1/vos_create.pod
+++ /dev/null
@@ -1,213 +0,0 @@
-=head1 NAME
-
-vos_create - Creates a read/write volume and associated VLDB entry
-
-=head1 SYNOPSIS
-
-=for html
-<div class="synopsis">
-
-B<vos create> S<<< B<-server> <I<machine name>> >>>
-    S<<< B<-partition> <I<partition name>> >>>
-    S<<< B<-name> <I<volume name>> >>>
-    S<<< [B<-maxquota> <I<initial quota (KB)>>] >>>
-    S<<< [B<-cell> <I<cell name>>] >>>
-    [B<-noauth>] [B<-localauth>] [B<-verbose>]
-    [B<-encrypt>] [B<-noresolve>] [B<-help>]
-
-B<vos cr> S<<< B<-s> <I<machine name>> >>> S<<< B<-p> <I<partition name>> >>>
-    S<<< B<-na> <I<volume name>> >>> S<<< [B<-m> <I<initial quota>>] >>>
-    S<<< [B<-c> <I<cell name>>] >>> [B<-noa>] [B<-l>] [B<-v>]
-    [B<-e>] [B<-nor>] [B<-h>]
-
-=for html
-</div>
-
-=head1 DESCRIPTION
-
-The B<vos create> command creates a read/write volume with the name
-specified by the B<-name> argument at the site specified by the B<-server>
-and B<-partition> arguments. In addition, the command allocates or sets
-the following:
-
-=over 4
-
-=item *
-
-Volume ID numbers for the read/write volume and its associated read-only
-and backup volumes (this command does not actually create the latter two
-types of volume). A volume ID number is an identification number
-guaranteed to be unique within a cell.
-
-=item *
-
-An access control list (ACL) associated with the volume's root directory,
-which takes the same name as volume's mount point when the volume is
-mounted with the B<fs mkmount> command. An entry that grants all seven
-permissions to the members of the system:administrators group is
-automatically placed on the ACL. (In addition, the File Server by default
-always implicitly grants the C<l> (lookup) and C<a> (administer)
-permissions on every ACL to members of the system:administrators group,
-even when the group does not appear on an ACL; use the B<-implicit>
-argument to the B<fileserver> initialization command to alter the set of
-rights on a server-by-server basis if desired.)
-
-=item *
-
-The volume's space quota, set to 5000 kilobyte blocks by default. Use the
-B<-maxquota> argument to specify a different quota, or use the B<fs
-setquota> command to change the volume's quota after mounting the volume
-with the B<fs mkmount> command.
-
-=back
-
-The volume is empty when created. To access it via the Cache Manager,
-mount it in the file space by using the B<fs mkmount> command.
-
-=head1 CAUTIONS
-
-Currently, the maximum size of a volume is 2 terabytes (2^31 bytes).
-
-=head1 OPTIONS
-
-=over 4
-
-=item B<-server> <I<server name>>
-
-Identifies the file server machine on which to create the read/write
-volume. Provide the machine's IP address or its host name (either fully
-qualified or using an unambiguous abbreviation). For details, see
-L<vos(1)>.
-
-=item B<-partition> <I<partition name>>
-
-Identifies the partition on which to create the read/write volume, on the
-file server machine specified by the B<-server> argument.  Provide the
-partition's complete name with preceding slash (for example, C</vicepa>)
-or use one of the three acceptable abbreviated forms. For details, see
-L<vos(1)>.
-
-=item B<-name> <I<volume name>>
-
-Specifies a name for the read/write volume. The maximum length is 22
-characters, which can include any alphanumeric or punctuation
-character. By convention, periods separate the fields in a name.  Do not
-apply the C<.backup> or C<.readonly> extension to a read/write volume
-name; they are reserved for the Volume Server to add to the read/write
-name when creating those backup and read-only volumes respectively.
-
-=item B<-maxquota> <I<initial quota>>
-
-Specifies the maximum amount of disk space the volume can use.  The size
-should be a positive integer followed by an optional suffix: C<K> for
-kibibytes (1024 bytes, the default), C<M> for mebibytes (1024 kibibytes),
-C<G> for gibibytes (1024 mebibytes), and C<T> for tebibytes (1024
-gibibytes).  The value C<0> (zero) grants an unlimited quota, but the size
-of the disk partition that houses the volume places an absolute limit on
-its size.  If this argument is omitted, the default value is C<5000K>.
-
-=item B<-id> <I<volume ID>>
-
-Specifies the volume ID for the read/write volume. If this options is not
-specified, or the given volume ID is 0, a volume ID will be allocated for
-the volume automatically. The volume IDs allocated should be fine for
-almost all cases, so you should almost never need to specify this option.
-
-=item B<-roid> <I<readonly volume ID>>
-
-Specifies the volume ID for the readonly volume corresponding to the
-read/write volume that is being created. The readonly volume will not be
-created; this merely specifies what volume ID the readonly volume will use
-when it is created. If a volume ID of 0 is specified here, no readonly
-volume ID will be assigned to the created volume immediately. A readonly
-volume ID can still be assigned later when B<vos addsite> is run; if a
-volume does not have a readonly volume ID associated with it by the time
-B<vos release> is run, a volume ID will be allocated for it.
-
-If this option is not specified, the default readonly volume ID is one
-number higher than the read-write volume ID, whether or not that ID was
-manually specified.
-
-As with the B<-id> option, the default allocated volume IDs should be
-sufficient for almost all cases, so you should almost never need to
-specify them explicitly. This option is available in OpenAFS
-versions 1.5.61 or later.
-
-=item B<-cell> <I<cell name>>
-
-Names the cell in which to run the command. Do not combine this argument
-with the B<-localauth> flag. For more details, see L<vos(1)>.
-
-=item B<-noauth>
-
-Assigns the unprivileged identity C<anonymous> to the issuer. Do not
-combine this flag with the B<-localauth> flag. For more details, see
-L<vos(1)>.
-
-=item B<-localauth>
-
-Constructs a server ticket using a key from the local
-F</usr/afs/etc/KeyFile> file. The B<vos> command interpreter presents it
-to the Volume Server and Volume Location Server during mutual
-authentication. Do not combine this flag with the B<-cell> argument or
-B<-noauth> flag. For more details, see L<vos(1)>.
-
-=item B<-verbose>
-
-Produces on the standard output stream a detailed trace of the command's
-execution. If this argument is omitted, only warnings and error messages
-appear.
-
-=item B<-encrypt>
-
-Encrypts the command so that the operation's results are not transmitted
-across the network in clear text. This option is available in OpenAFS
-versions 1.4.11 or later and 1.5.60 or later.
-
-=item B<-noresolve>
-
-Shows all servers as IP addresses instead of the DNS name. This is very
-useful when the server address is registered as 127.0.0.1 or when dealing
-with multi-homed servers. This option is available in OpenAFS
-versions 1.4.8 or later and 1.5.35 or later.
-
-=item B<-help>
-
-Prints the online help for this command. All other valid options are
-ignored.
-
-=back
-
-=head1 OUTPUT
-
-The Volume Server produces the following message to confirm that it
-created the volume:
-
-   Volume <volume_ID> created on partition <partition_name> of <machine_name>
-
-=head1 EXAMPLES
-
-The following command creates the read/write volume C<user.pat> on the
-F</vicepf> partition of the file server machine C<fs4.abc.com>.
-
-   % vos create -server fs4.abc.com -partition /vicepf -name user.pat
-   Volume user.pat created on partition /vicepf of fs4.abc.com
-
-=head1 PRIVILEGE REQUIRED
-
-The issuer must be listed in the F</usr/afs/etc/UserList> file on the
-machine specified with the B<-server> argument and on each database server
-machine. If the B<-localauth> flag is included, the issuer must instead be
-logged on to a server machine as the local superuser C<root>.
-
-=head1 SEE ALSO
-
-L<vos(1)>
-
-=head1 COPYRIGHT
-
-IBM Corporation 2000. <http://www.ibm.com/> All Rights Reserved.
-
-This documentation is covered by the IBM Public License Version 1.0.  It was
-converted from HTML to POD by software written by Chas Williams and Russ
-Allbery, based on work by Alf Wachsmann and Elizabeth Cassell.
diff --git a/doc/man-pages/pod1/vos_create.pod.in b/doc/man-pages/pod1/vos_create.pod.in
new file mode 100644
index 0000000..0807280
--- /dev/null
+++ b/doc/man-pages/pod1/vos_create.pod.in
@@ -0,0 +1,213 @@
+=head1 NAME
+
+vos_create - Creates a read/write volume and associated VLDB entry
+
+=head1 SYNOPSIS
+
+=for html
+<div class="synopsis">
+
+B<vos create> S<<< B<-server> <I<machine name>> >>>
+    S<<< B<-partition> <I<partition name>> >>>
+    S<<< B<-name> <I<volume name>> >>>
+    S<<< [B<-maxquota> <I<initial quota (KB)>>] >>>
+    S<<< [B<-cell> <I<cell name>>] >>>
+    [B<-noauth>] [B<-localauth>] [B<-verbose>]
+    [B<-encrypt>] [B<-noresolve>] [B<-help>]
+
+B<vos cr> S<<< B<-s> <I<machine name>> >>> S<<< B<-p> <I<partition name>> >>>
+    S<<< B<-na> <I<volume name>> >>> S<<< [B<-m> <I<initial quota>>] >>>
+    S<<< [B<-c> <I<cell name>>] >>> [B<-noa>] [B<-l>] [B<-v>]
+    [B<-e>] [B<-nor>] [B<-h>]
+
+=for html
+</div>
+
+=head1 DESCRIPTION
+
+The B<vos create> command creates a read/write volume with the name
+specified by the B<-name> argument at the site specified by the B<-server>
+and B<-partition> arguments. In addition, the command allocates or sets
+the following:
+
+=over 4
+
+=item *
+
+Volume ID numbers for the read/write volume and its associated read-only
+and backup volumes (this command does not actually create the latter two
+types of volume). A volume ID number is an identification number
+guaranteed to be unique within a cell.
+
+=item *
+
+An access control list (ACL) associated with the volume's root directory,
+which takes the same name as volume's mount point when the volume is
+mounted with the B<fs mkmount> command. An entry that grants all seven
+permissions to the members of the system:administrators group is
+automatically placed on the ACL. (In addition, the File Server by default
+always implicitly grants the C<l> (lookup) and C<a> (administer)
+permissions on every ACL to members of the system:administrators group,
+even when the group does not appear on an ACL; use the B<-implicit>
+argument to the B<fileserver> initialization command to alter the set of
+rights on a server-by-server basis if desired.)
+
+=item *
+
+The volume's space quota, set to 5000 kilobyte blocks by default. Use the
+B<-maxquota> argument to specify a different quota, or use the B<fs
+setquota> command to change the volume's quota after mounting the volume
+with the B<fs mkmount> command.
+
+=back
+
+The volume is empty when created. To access it via the Cache Manager,
+mount it in the file space by using the B<fs mkmount> command.
+
+=head1 CAUTIONS
+
+=include fragments/volsize-caution.pod
+
+=head1 OPTIONS
+
+=over 4
+
+=item B<-server> <I<server name>>
+
+Identifies the file server machine on which to create the read/write
+volume. Provide the machine's IP address or its host name (either fully
+qualified or using an unambiguous abbreviation). For details, see
+L<vos(1)>.
+
+=item B<-partition> <I<partition name>>
+
+Identifies the partition on which to create the read/write volume, on the
+file server machine specified by the B<-server> argument.  Provide the
+partition's complete name with preceding slash (for example, C</vicepa>)
+or use one of the three acceptable abbreviated forms. For details, see
+L<vos(1)>.
+
+=item B<-name> <I<volume name>>
+
+Specifies a name for the read/write volume. The maximum length is 22
+characters, which can include any alphanumeric or punctuation
+character. By convention, periods separate the fields in a name.  Do not
+apply the C<.backup> or C<.readonly> extension to a read/write volume
+name; they are reserved for the Volume Server to add to the read/write
+name when creating those backup and read-only volumes respectively.
+
+=item B<-maxquota> <I<initial quota>>
+
+Specifies the maximum amount of disk space the volume can use.  The size
+should be a positive integer followed by an optional suffix: C<K> for
+kibibytes (1024 bytes, the default), C<M> for mebibytes (1024 kibibytes),
+C<G> for gibibytes (1024 mebibytes), and C<T> for tebibytes (1024
+gibibytes).  The value C<0> (zero) grants an unlimited quota, but the size
+of the disk partition that houses the volume places an absolute limit on
+its size.  If this argument is omitted, the default value is C<5000K>.
+
+=item B<-id> <I<volume ID>>
+
+Specifies the volume ID for the read/write volume. If this options is not
+specified, or the given volume ID is 0, a volume ID will be allocated for
+the volume automatically. The volume IDs allocated should be fine for
+almost all cases, so you should almost never need to specify this option.
+
+=item B<-roid> <I<readonly volume ID>>
+
+Specifies the volume ID for the readonly volume corresponding to the
+read/write volume that is being created. The readonly volume will not be
+created; this merely specifies what volume ID the readonly volume will use
+when it is created. If a volume ID of 0 is specified here, no readonly
+volume ID will be assigned to the created volume immediately. A readonly
+volume ID can still be assigned later when B<vos addsite> is run; if a
+volume does not have a readonly volume ID associated with it by the time
+B<vos release> is run, a volume ID will be allocated for it.
+
+If this option is not specified, the default readonly volume ID is one
+number higher than the read-write volume ID, whether or not that ID was
+manually specified.
+
+As with the B<-id> option, the default allocated volume IDs should be
+sufficient for almost all cases, so you should almost never need to
+specify them explicitly. This option is available in OpenAFS
+versions 1.5.61 or later.
+
+=item B<-cell> <I<cell name>>
+
+Names the cell in which to run the command. Do not combine this argument
+with the B<-localauth> flag. For more details, see L<vos(1)>.
+
+=item B<-noauth>
+
+Assigns the unprivileged identity C<anonymous> to the issuer. Do not
+combine this flag with the B<-localauth> flag. For more details, see
+L<vos(1)>.
+
+=item B<-localauth>
+
+Constructs a server ticket using a key from the local
+F</usr/afs/etc/KeyFile> file. The B<vos> command interpreter presents it
+to the Volume Server and Volume Location Server during mutual
+authentication. Do not combine this flag with the B<-cell> argument or
+B<-noauth> flag. For more details, see L<vos(1)>.
+
+=item B<-verbose>
+
+Produces on the standard output stream a detailed trace of the command's
+execution. If this argument is omitted, only warnings and error messages
+appear.
+
+=item B<-encrypt>
+
+Encrypts the command so that the operation's results are not transmitted
+across the network in clear text. This option is available in OpenAFS
+versions 1.4.11 or later and 1.5.60 or later.
+
+=item B<-noresolve>
+
+Shows all servers as IP addresses instead of the DNS name. This is very
+useful when the server address is registered as 127.0.0.1 or when dealing
+with multi-homed servers. This option is available in OpenAFS
+versions 1.4.8 or later and 1.5.35 or later.
+
+=item B<-help>
+
+Prints the online help for this command. All other valid options are
+ignored.
+
+=back
+
+=head1 OUTPUT
+
+The Volume Server produces the following message to confirm that it
+created the volume:
+
+   Volume <volume_ID> created on partition <partition_name> of <machine_name>
+
+=head1 EXAMPLES
+
+The following command creates the read/write volume C<user.pat> on the
+F</vicepf> partition of the file server machine C<fs4.abc.com>.
+
+   % vos create -server fs4.abc.com -partition /vicepf -name user.pat
+   Volume user.pat created on partition /vicepf of fs4.abc.com
+
+=head1 PRIVILEGE REQUIRED
+
+The issuer must be listed in the F</usr/afs/etc/UserList> file on the
+machine specified with the B<-server> argument and on each database server
+machine. If the B<-localauth> flag is included, the issuer must instead be
+logged on to a server machine as the local superuser C<root>.
+
+=head1 SEE ALSO
+
+L<vos(1)>
+
+=head1 COPYRIGHT
+
+IBM Corporation 2000. <http://www.ibm.com/> All Rights Reserved.
+
+This documentation is covered by the IBM Public License Version 1.0.  It was
+converted from HTML to POD by software written by Chas Williams and Russ
+Allbery, based on work by Alf Wachsmann and Elizabeth Cassell.
diff --git a/doc/man-pages/pod1/vos_examine.pod b/doc/man-pages/pod1/vos_examine.pod
deleted file mode 100644
index 1da1d68..0000000
--- a/doc/man-pages/pod1/vos_examine.pod
+++ /dev/null
@@ -1,438 +0,0 @@
-=head1 NAME
-
-vos_examine - Shows volume header and VLDB entry information for a volume
-
-=head1 SYNOPSIS
-
-=for html
-<div class="synopsis">
-
-B<vos examine> S<<< B<-id> <I<volume name or ID>> >>> [B<-extended>]
-    [B<-format>] S<<< [B<-cell> <I<cell name>>] >>>
-    [B<-noauth>] [B<-localauth>] [B<-verbose>]
-    [B<-encrypt>] [B<-noresolve>] [B<-help>]
-
-B<vos e> S<<< B<-i> <I<volume name or ID>> >>> [B<-ex>] [B<-f>]
-    S<<< [B<-c> <I<cell name>>] >>>
-    [B<-noa>] [B<-l>] [B<-v>] [B<-e>] [B<-nor>] [B<-h>]
-
-B<vos volinfo> S<<< B<-id> <I<volume name or ID>> >>> [B<-extended>]
-    [B<-format>] S<<< [B<-cell> <I<cell name>>] >>>
-    [B<-noauth>] [B<-localauth>] [B<-verbose>]
-    [B<-encrypt>] [B<-noresolve>] [B<-help>]
-
-B<vos v> S<<< B<-i> <I<volume name or ID>> >>> [B<-ex>] [B<-f>]
-    S<<< [B<-c> <I<cell name>>] >>>
-    [B<-noa>] [B<-l>] [B<-v>] [B<-e>] [B<-nor>] [B<-h>]
-
-=for html
-</div>
-
-=head1 DESCRIPTION
-
-The B<vos examine> command formats and displays information from the
-Volume Location Database (VLDB) entry and the volume header of the volume
-specified by the B<-id> argument.
-
-To display the volume header only, use the B<vos listvol> command. To
-display information from the VLDB only, use the B<vos listvldb> command.
-
-=head1 CAUTIONS
-
-Currently, the maximum size of a volume is 2 terabytes (2^31 bytes).
-
-=head1 OPTIONS
-
-=over 4
-
-=item B<-id> <I<volume name or ID>>
-
-Specifies either the complete name or volume ID number of the volume,
-which can be read/write, read-only, or backup.
-
-=item B<-extended>
-
-Displays statistics about read and write operations on files and
-directories in the volume.
-
-=item B<-format>
-
-Shows information in a format suitable for machine parsing.
-
-=item B<-cell> <I<cell name>>
-
-Names the cell in which to run the command. Do not combine this argument
-with the B<-localauth> flag. For more details, see L<vos(1)>.
-
-=item B<-noauth>
-
-Assigns the unprivileged identity C<anonymous> to the issuer. Do not
-combine this flag with the B<-localauth> flag. For more details, see
-L<vos(1)>.
-
-=item B<-localauth>
-
-Constructs a server ticket using a key from the local
-F</usr/afs/etc/KeyFile> file. The B<vos> command interpreter presents it
-to the Volume Server and Volume Location Server during mutual
-authentication. Do not combine this flag with the B<-cell> argument or
-B<-noauth> flag. For more details, see L<vos(1)>.
-
-=item B<-verbose>
-
-Produces on the standard output stream a detailed trace of the command's
-execution. If this argument is omitted, only warnings and error messages
-appear.
-
-=item B<-encrypt>
-
-Encrypts the command so that the operation's results are not transmitted
-across the network in clear text. This option is available in OpenAFS
-versions 1.4.11 or later and 1.5.60 or later.
-
-=item B<-noresolve>
-
-Shows all servers as IP addresses instead of the DNS name. This is very
-useful when the server address is registered as 127.0.0.1 or when dealing
-with multi-homed servers. This option is available in OpenAFS
-versions 1.4.8 or later and 1.5.35 or later.
-
-=item B<-help>
-
-Prints the online help for this command. All other valid options are
-ignored.
-
-=back
-
-=head1 OUTPUT
-
-The first seven lines of the output show information from the volume
-header and the remaining lines come from the VLDB. Each item in the
-following list corresponds to a line of output derived from the volume
-header.
-
-=over 4
-
-=item *
-
-Basic information about the specified volume (displayed on a single
-line):
-
-=over 4
-
-=item *
-
-Name
-
-=item *
-
-Volume ID number
-
-=item *
-
-Type (the flag is C<RW> for read/write, C<RO> for read-only, C<BK> for
-backup)
-
-=item *
-
-Size in kilobytes (C<1024> equals a megabyte)
-
-=item *
-
-Number of files in the volume, if the B<-extended> flag is provided
-
-=item *
-
-Status on the file server machine, which is one of the following:
-
-=over 4
-
-=item On-line
-
-The volume is completely accessible to Cache Managers.
-
-=item Off-line
-
-The volume is not accessible to Cache Managers, but does not seem to be
-corrupted. This status appears while a volume is being dumped, for
-example.
-
-=item Off-line**needs salvage**
-
-The volume is not accessible to Cache Managers, because it seems to be
-corrupted. Use the B<bos salvage> or B<salvager> command to repair the
-corruption.
-
-=back
-
-=back
-
-=item *
-
-The file server machine and partition that house the volume, as determined
-by the command interpreter as the command runs, rather than derived from
-the VLDB or the volume header.
-
-=item *
-
-The volume ID numbers associated with the various versions of the volume:
-read/write (C<RWrite>), read-only (C<ROnly>), backup (C<Backup>), and
-ReleaseClone (C<RClone>). One of them matches the volume ID number that
-appears on the first line of the volume's output. If the value in the
-C<RWrite>, C<ROnly>, or C<Backup> field is C<0> (zero), there is no volume
-of that type. If there is currently no ReleaseClone, the C<RClone> field
-does not appear at all.
-
-=item *
-
-The maximum space quota allotted to the read/write copy of the volume,
-expressed in kilobyte blocks in the C<MaxQuota> field.
-
-=item *
-
-The date and time the volume was created, in the C<Creation> field. If the
-volume has been restored with the B<backup diskrestore>, B<backup
-volrestore>, or B<vos restore> command, this is the restore time. For a
-read-only volume, this is the last release time.
-
-=item *
-
-The date and time this copy of this volume was created, in the C<Copy>
-field.  This is the time when the volume was created on this server and
-partition.  For read-only volumes, it is not updated by a release (unlike
-the Creation date).  The copy date is not stored in volume dumps.
-
-=item *
-
-The date and time when the contents of the volume last changed, in the
-C<Last Update> field. For read-only and backup volumes, it matches the
-timestamp in the C<Creation> field.
-
-=item *
-
-The number of times the volume has been accessed for a fetch or store
-operation since the later of the two following times:
-
-=over 4
-
-=item *
-
-12:00 a.m. on the day the command is issued
-
-=item *
-
-The last time the volume changed location
-
-=back
-
-=back
-
-When the B<-extended> flag is included, two tables appear next:
-
-=over 4
-
-=item *
-
-The table labeled C<Raw Read/Write Stats> contains information on the
-number of reads (fetches) and writes (stores) made on the specified
-volume.
-
-=item *
-
-The table labeled C<Writes Affecting Authorship> contains information on
-writes made to files and directories in the specified volume.
-
-=back
-
-If the following message appears instead of the previously listed
-information, it indicates that a volume is not accessible to Cache
-Managers or the B<vos> command interpreter, for example because a clone is
-being created.
-
-   **** Volume <volume_ID> is busy ****
-
-If the following message appears instead of the previously listed
-information, it indicates that the File Server is unable to attach the
-volume, perhaps because it is seriously corrupted. The F<FileLog> and
-F<VolserLog> log files in the F</usr/afs/logs> directory on the file
-server machine possibly provide additional information; use the B<bos
-getlog> command to display them.
-
-   **** Could not attach volume <volume_ID> ****
-
-Following a blank line, information from the VLDB entry appears.  Each
-item in this list corresponds to a separate line in the output:
-
-=over 4
-
-=item *
-
-The base (read/write) volume name. The read-only and backup versions have
-the same name with a C<.readonly> and C<.backup> extension, respectively.
-
-=item *
-
-The volume ID numbers allocated to the versions of the volume that
-actually exist, in fields labeled C<RWrite> for the read/write, C<ROnly>
-for the read-only, C<Backup> for the backup, and C<RClone> for the
-ReleaseClone. (If a field does not appear, the corresponding version of
-the volume does not exist.) The appearance of the C<RClone> field normally
-indicates that a release operation did not complete successfully; the
-C<Old release> and C<New release> flags often also appear on one or more
-of the site definition lines described just following.
-
-=item *
-
-The number of sites that house a read/write or read-only copy of the
-volume, following the string C<< number of sites -> >>.
-
-=item *
-
-A line for each site that houses a read/write or read-only copy of the
-volume, specifying the file server machine, partition, and type of volume
-(C<RW> for read/write or C<RO> for read-only). If a backup version exists,
-it is understood to share the read/write site.  Several flags can appear
-with a site definition:
-
-=over 4
-
-=item Not released
-
-Indicates that the vos release command has not been issued since the B<vos
-addsite> command was used to define the read-only site.
-
-=item Old release
-
-Indicates that a vos release command did not complete successfully,
-leaving the previous, obsolete version of the volume at this site.
-
-=item New release
-
-Indicates that a vos release command did not complete successfully, but
-that this site did receive the correct new version of the volume.
-
-=back
-
-=item *
-
-If the VLDB entry is locked, the string C<Volume is currently LOCKED>, as
-well as (in OpenAFS 1.5.75 and later) one or more of the following strings:
-
-=over 4
-
-=item Volume is locked for a move operation
-
-Indicates that the volume was locked due to a B<vos move> or a B<vos
-convertROtoRW> command.
-
-=item Volume is locked for a release operation
-
-Indicates that the volume was locked due to a B<vos release> command.
-
-=item Volume is locked for a backup operation
-
-Indicates that the volume was locked due to a B<vos backup> command.
-
-=item Volume is locked for a delete/misc operation
-
-Indicates that the volume was locked due to a B<vos delentry>, B<vos
-addsite>, B<vos remsite>, B<vos changeloc>, B<vos syncvldb>, B<vos
-syncserv>, B<vos rename>, or B<vos lock> command.
-
-=item Volume is locked for a dump/restore operation
-
-Indicates that the volume was locked due to a B<vos dump> or B<vos restore>
-command.
-
-=back
-
-=back
-
-For further discussion of the C<New release> and C<Old release> flags, see
-L<vos_release(1)>.
-
-=head1 EXAMPLES
-
-The following example shows output for the ABC Corporation volume called
-C<usr> with two read-only replication sites (this volume is mounted at the
-F</afs/abc.com/usr> directory). For the sake of illustration, the output
-shows the volume as locked.
-
-   % vos examine usr
-   usr                           536870981 RW   3459 K On-line
-        fs2.abc.com /vicepb
-        RWrite 5360870981   ROnly 536870982   Backup 536870983
-        MaxQuota      40000 K
-        Creation    Mon Jun 12 15:22:06 1989
-        Copy        Mon Jun 12 15:22:06 1989
-        Last Update Fri Jun 16 09:34:35 1989
-        5719 accesses in the past day (i.e., vnode references)
-        RWrite: 5360870981   ROnly: 536870982   Backup: 536870983
-        number of sites -> 3
-           server fs1.abc.com partition /vicepa RO Site
-           server fs3.abc.com partition /vicepa RO Site
-           server fs2.abc.com partition /vicepb RW Site
-        Volume is currently LOCKED
-
-The following example shows the output for the volume C<user.terry> using
-the B<-extended> flag. The volume has no read-only replication sites.
-
-   % vos examine -id user.terry -extended
-   user.terry         354287190 RW    2302 K used 119 files On-line
-       fs4.abc.com /vicepc
-       RWrite 354287190 ROnly          0 Backup 354287192
-       MaxQuota       5000 K
-       Creation    Wed Nov 25 17:38:57 1992
-       Copy        Wed Nov 25 17:38:57 1992
-       Last Update Tue Dec 15 10:46:20 1992
-       598 accesses in the past day (i.e., vnode references)
-                         Raw Read/Write Stats
-             |-------------------------------------------|
-             |    Same Network     |    Diff Network     |
-             |----------|----------|----------|----------|
-             |  Total   |   Auth   |   Total  |   Auth   |
-             |----------|----------|----------|----------|
-   Reads     |       55 |       55 |       38 |       38 |
-   Writes    |       95 |       95 |        0 |        0 |
-             |-------------------------------------------|
-                      Writes Affecting Authorship
-             |-------------------------------------------|
-             |   File Authorship   | Directory Authorship|
-             |----------|----------|----------|----------|
-             |   Same   |   Diff   |    Same  |   Diff   |
-             |----------|----------|----------|----------|
-   0-60 sec  |       38 |        0 |       21 |        1 |
-   1-10 min  |        2 |        0 |        7 |        0 |
-   10min-1hr |        0 |        0 |        1 |        0 |
-   1hr-1day  |        1 |        0 |        5 |        1 |
-   1day-1wk  |        0 |        0 |        0 |        0 |
-   > 1wk     |        0 |        0 |        0 |        0 |
-             |-------------------------------------------|
-       RWrite: 354287190    Backup: 354287192
-       number of sites -> 1
-          server fs4.abc.com partition /vicepc RW Site
-
-=head1 PRIVILEGE REQUIRED
-
-None
-
-=head1 SEE ALSO
-
-L<backup_diskrestore(8)>,
-L<backup_volrestore(8)>,
-L<bos_getlog(8)>,
-L<bos_salvage(8)>,
-L<salvager(8)>,
-L<vos(1)>,
-L<vos_listvol(1)>,
-L<vos_listvldb(1)>,
-L<vos_release(1)>,
-L<vos_restore(1)>
-
-=head1 COPYRIGHT
-
-IBM Corporation 2000. <http://www.ibm.com/> All Rights Reserved.
-
-This documentation is covered by the IBM Public License Version 1.0.  It was
-converted from HTML to POD by software written by Chas Williams and Russ
-Allbery, based on work by Alf Wachsmann and Elizabeth Cassell.
diff --git a/doc/man-pages/pod1/vos_examine.pod.in b/doc/man-pages/pod1/vos_examine.pod.in
new file mode 100644
index 0000000..8b145a3
--- /dev/null
+++ b/doc/man-pages/pod1/vos_examine.pod.in
@@ -0,0 +1,438 @@
+=head1 NAME
+
+vos_examine - Shows volume header and VLDB entry information for a volume
+
+=head1 SYNOPSIS
+
+=for html
+<div class="synopsis">
+
+B<vos examine> S<<< B<-id> <I<volume name or ID>> >>> [B<-extended>]
+    [B<-format>] S<<< [B<-cell> <I<cell name>>] >>>
+    [B<-noauth>] [B<-localauth>] [B<-verbose>]
+    [B<-encrypt>] [B<-noresolve>] [B<-help>]
+
+B<vos e> S<<< B<-i> <I<volume name or ID>> >>> [B<-ex>] [B<-f>]
+    S<<< [B<-c> <I<cell name>>] >>>
+    [B<-noa>] [B<-l>] [B<-v>] [B<-e>] [B<-nor>] [B<-h>]
+
+B<vos volinfo> S<<< B<-id> <I<volume name or ID>> >>> [B<-extended>]
+    [B<-format>] S<<< [B<-cell> <I<cell name>>] >>>
+    [B<-noauth>] [B<-localauth>] [B<-verbose>]
+    [B<-encrypt>] [B<-noresolve>] [B<-help>]
+
+B<vos v> S<<< B<-i> <I<volume name or ID>> >>> [B<-ex>] [B<-f>]
+    S<<< [B<-c> <I<cell name>>] >>>
+    [B<-noa>] [B<-l>] [B<-v>] [B<-e>] [B<-nor>] [B<-h>]
+
+=for html
+</div>
+
+=head1 DESCRIPTION
+
+The B<vos examine> command formats and displays information from the
+Volume Location Database (VLDB) entry and the volume header of the volume
+specified by the B<-id> argument.
+
+To display the volume header only, use the B<vos listvol> command. To
+display information from the VLDB only, use the B<vos listvldb> command.
+
+=head1 CAUTIONS
+
+=include fragments/volsize-caution.pod
+
+=head1 OPTIONS
+
+=over 4
+
+=item B<-id> <I<volume name or ID>>
+
+Specifies either the complete name or volume ID number of the volume,
+which can be read/write, read-only, or backup.
+
+=item B<-extended>
+
+Displays statistics about read and write operations on files and
+directories in the volume.
+
+=item B<-format>
+
+Shows information in a format suitable for machine parsing.
+
+=item B<-cell> <I<cell name>>
+
+Names the cell in which to run the command. Do not combine this argument
+with the B<-localauth> flag. For more details, see L<vos(1)>.
+
+=item B<-noauth>
+
+Assigns the unprivileged identity C<anonymous> to the issuer. Do not
+combine this flag with the B<-localauth> flag. For more details, see
+L<vos(1)>.
+
+=item B<-localauth>
+
+Constructs a server ticket using a key from the local
+F</usr/afs/etc/KeyFile> file. The B<vos> command interpreter presents it
+to the Volume Server and Volume Location Server during mutual
+authentication. Do not combine this flag with the B<-cell> argument or
+B<-noauth> flag. For more details, see L<vos(1)>.
+
+=item B<-verbose>
+
+Produces on the standard output stream a detailed trace of the command's
+execution. If this argument is omitted, only warnings and error messages
+appear.
+
+=item B<-encrypt>
+
+Encrypts the command so that the operation's results are not transmitted
+across the network in clear text. This option is available in OpenAFS
+versions 1.4.11 or later and 1.5.60 or later.
+
+=item B<-noresolve>
+
+Shows all servers as IP addresses instead of the DNS name. This is very
+useful when the server address is registered as 127.0.0.1 or when dealing
+with multi-homed servers. This option is available in OpenAFS
+versions 1.4.8 or later and 1.5.35 or later.
+
+=item B<-help>
+
+Prints the online help for this command. All other valid options are
+ignored.
+
+=back
+
+=head1 OUTPUT
+
+The first seven lines of the output show information from the volume
+header and the remaining lines come from the VLDB. Each item in the
+following list corresponds to a line of output derived from the volume
+header.
+
+=over 4
+
+=item *
+
+Basic information about the specified volume (displayed on a single
+line):
+
+=over 4
+
+=item *
+
+Name
+
+=item *
+
+Volume ID number
+
+=item *
+
+Type (the flag is C<RW> for read/write, C<RO> for read-only, C<BK> for
+backup)
+
+=item *
+
+Size in kilobytes (C<1024> equals a megabyte)
+
+=item *
+
+Number of files in the volume, if the B<-extended> flag is provided
+
+=item *
+
+Status on the file server machine, which is one of the following:
+
+=over 4
+
+=item On-line
+
+The volume is completely accessible to Cache Managers.
+
+=item Off-line
+
+The volume is not accessible to Cache Managers, but does not seem to be
+corrupted. This status appears while a volume is being dumped, for
+example.
+
+=item Off-line**needs salvage**
+
+The volume is not accessible to Cache Managers, because it seems to be
+corrupted. Use the B<bos salvage> or B<salvager> command to repair the
+corruption.
+
+=back
+
+=back
+
+=item *
+
+The file server machine and partition that house the volume, as determined
+by the command interpreter as the command runs, rather than derived from
+the VLDB or the volume header.
+
+=item *
+
+The volume ID numbers associated with the various versions of the volume:
+read/write (C<RWrite>), read-only (C<ROnly>), backup (C<Backup>), and
+ReleaseClone (C<RClone>). One of them matches the volume ID number that
+appears on the first line of the volume's output. If the value in the
+C<RWrite>, C<ROnly>, or C<Backup> field is C<0> (zero), there is no volume
+of that type. If there is currently no ReleaseClone, the C<RClone> field
+does not appear at all.
+
+=item *
+
+The maximum space quota allotted to the read/write copy of the volume,
+expressed in kilobyte blocks in the C<MaxQuota> field.
+
+=item *
+
+The date and time the volume was created, in the C<Creation> field. If the
+volume has been restored with the B<backup diskrestore>, B<backup
+volrestore>, or B<vos restore> command, this is the restore time. For a
+read-only volume, this is the last release time.
+
+=item *
+
+The date and time this copy of this volume was created, in the C<Copy>
+field.  This is the time when the volume was created on this server and
+partition.  For read-only volumes, it is not updated by a release (unlike
+the Creation date).  The copy date is not stored in volume dumps.
+
+=item *
+
+The date and time when the contents of the volume last changed, in the
+C<Last Update> field. For read-only and backup volumes, it matches the
+timestamp in the C<Creation> field.
+
+=item *
+
+The number of times the volume has been accessed for a fetch or store
+operation since the later of the two following times:
+
+=over 4
+
+=item *
+
+12:00 a.m. on the day the command is issued
+
+=item *
+
+The last time the volume changed location
+
+=back
+
+=back
+
+When the B<-extended> flag is included, two tables appear next:
+
+=over 4
+
+=item *
+
+The table labeled C<Raw Read/Write Stats> contains information on the
+number of reads (fetches) and writes (stores) made on the specified
+volume.
+
+=item *
+
+The table labeled C<Writes Affecting Authorship> contains information on
+writes made to files and directories in the specified volume.
+
+=back
+
+If the following message appears instead of the previously listed
+information, it indicates that a volume is not accessible to Cache
+Managers or the B<vos> command interpreter, for example because a clone is
+being created.
+
+   **** Volume <volume_ID> is busy ****
+
+If the following message appears instead of the previously listed
+information, it indicates that the File Server is unable to attach the
+volume, perhaps because it is seriously corrupted. The F<FileLog> and
+F<VolserLog> log files in the F</usr/afs/logs> directory on the file
+server machine possibly provide additional information; use the B<bos
+getlog> command to display them.
+
+   **** Could not attach volume <volume_ID> ****
+
+Following a blank line, information from the VLDB entry appears.  Each
+item in this list corresponds to a separate line in the output:
+
+=over 4
+
+=item *
+
+The base (read/write) volume name. The read-only and backup versions have
+the same name with a C<.readonly> and C<.backup> extension, respectively.
+
+=item *
+
+The volume ID numbers allocated to the versions of the volume that
+actually exist, in fields labeled C<RWrite> for the read/write, C<ROnly>
+for the read-only, C<Backup> for the backup, and C<RClone> for the
+ReleaseClone. (If a field does not appear, the corresponding version of
+the volume does not exist.) The appearance of the C<RClone> field normally
+indicates that a release operation did not complete successfully; the
+C<Old release> and C<New release> flags often also appear on one or more
+of the site definition lines described just following.
+
+=item *
+
+The number of sites that house a read/write or read-only copy of the
+volume, following the string C<< number of sites -> >>.
+
+=item *
+
+A line for each site that houses a read/write or read-only copy of the
+volume, specifying the file server machine, partition, and type of volume
+(C<RW> for read/write or C<RO> for read-only). If a backup version exists,
+it is understood to share the read/write site.  Several flags can appear
+with a site definition:
+
+=over 4
+
+=item Not released
+
+Indicates that the vos release command has not been issued since the B<vos
+addsite> command was used to define the read-only site.
+
+=item Old release
+
+Indicates that a vos release command did not complete successfully,
+leaving the previous, obsolete version of the volume at this site.
+
+=item New release
+
+Indicates that a vos release command did not complete successfully, but
+that this site did receive the correct new version of the volume.
+
+=back
+
+=item *
+
+If the VLDB entry is locked, the string C<Volume is currently LOCKED>, as
+well as (in OpenAFS 1.5.75 and later) one or more of the following strings:
+
+=over 4
+
+=item Volume is locked for a move operation
+
+Indicates that the volume was locked due to a B<vos move> or a B<vos
+convertROtoRW> command.
+
+=item Volume is locked for a release operation
+
+Indicates that the volume was locked due to a B<vos release> command.
+
+=item Volume is locked for a backup operation
+
+Indicates that the volume was locked due to a B<vos backup> command.
+
+=item Volume is locked for a delete/misc operation
+
+Indicates that the volume was locked due to a B<vos delentry>, B<vos
+addsite>, B<vos remsite>, B<vos changeloc>, B<vos syncvldb>, B<vos
+syncserv>, B<vos rename>, or B<vos lock> command.
+
+=item Volume is locked for a dump/restore operation
+
+Indicates that the volume was locked due to a B<vos dump> or B<vos restore>
+command.
+
+=back
+
+=back
+
+For further discussion of the C<New release> and C<Old release> flags, see
+L<vos_release(1)>.
+
+=head1 EXAMPLES
+
+The following example shows output for the ABC Corporation volume called
+C<usr> with two read-only replication sites (this volume is mounted at the
+F</afs/abc.com/usr> directory). For the sake of illustration, the output
+shows the volume as locked.
+
+   % vos examine usr
+   usr                           536870981 RW   3459 K On-line
+        fs2.abc.com /vicepb
+        RWrite 5360870981   ROnly 536870982   Backup 536870983
+        MaxQuota      40000 K
+        Creation    Mon Jun 12 15:22:06 1989
+        Copy        Mon Jun 12 15:22:06 1989
+        Last Update Fri Jun 16 09:34:35 1989
+        5719 accesses in the past day (i.e., vnode references)
+        RWrite: 5360870981   ROnly: 536870982   Backup: 536870983
+        number of sites -> 3
+           server fs1.abc.com partition /vicepa RO Site
+           server fs3.abc.com partition /vicepa RO Site
+           server fs2.abc.com partition /vicepb RW Site
+        Volume is currently LOCKED
+
+The following example shows the output for the volume C<user.terry> using
+the B<-extended> flag. The volume has no read-only replication sites.
+
+   % vos examine -id user.terry -extended
+   user.terry         354287190 RW    2302 K used 119 files On-line
+       fs4.abc.com /vicepc
+       RWrite 354287190 ROnly          0 Backup 354287192
+       MaxQuota       5000 K
+       Creation    Wed Nov 25 17:38:57 1992
+       Copy        Wed Nov 25 17:38:57 1992
+       Last Update Tue Dec 15 10:46:20 1992
+       598 accesses in the past day (i.e., vnode references)
+                         Raw Read/Write Stats
+             |-------------------------------------------|
+             |    Same Network     |    Diff Network     |
+             |----------|----------|----------|----------|
+             |  Total   |   Auth   |   Total  |   Auth   |
+             |----------|----------|----------|----------|
+   Reads     |       55 |       55 |       38 |       38 |
+   Writes    |       95 |       95 |        0 |        0 |
+             |-------------------------------------------|
+                      Writes Affecting Authorship
+             |-------------------------------------------|
+             |   File Authorship   | Directory Authorship|
+             |----------|----------|----------|----------|
+             |   Same   |   Diff   |    Same  |   Diff   |
+             |----------|----------|----------|----------|
+   0-60 sec  |       38 |        0 |       21 |        1 |
+   1-10 min  |        2 |        0 |        7 |        0 |
+   10min-1hr |        0 |        0 |        1 |        0 |
+   1hr-1day  |        1 |        0 |        5 |        1 |
+   1day-1wk  |        0 |        0 |        0 |        0 |
+   > 1wk     |        0 |        0 |        0 |        0 |
+             |-------------------------------------------|
+       RWrite: 354287190    Backup: 354287192
+       number of sites -> 1
+          server fs4.abc.com partition /vicepc RW Site
+
+=head1 PRIVILEGE REQUIRED
+
+None
+
+=head1 SEE ALSO
+
+L<backup_diskrestore(8)>,
+L<backup_volrestore(8)>,
+L<bos_getlog(8)>,
+L<bos_salvage(8)>,
+L<salvager(8)>,
+L<vos(1)>,
+L<vos_listvol(1)>,
+L<vos_listvldb(1)>,
+L<vos_release(1)>,
+L<vos_restore(1)>
+
+=head1 COPYRIGHT
+
+IBM Corporation 2000. <http://www.ibm.com/> All Rights Reserved.
+
+This documentation is covered by the IBM Public License Version 1.0.  It was
+converted from HTML to POD by software written by Chas Williams and Russ
+Allbery, based on work by Alf Wachsmann and Elizabeth Cassell.
diff --git a/doc/man-pages/pod1/vos_move.pod b/doc/man-pages/pod1/vos_move.pod
deleted file mode 100644
index 4787196..0000000
--- a/doc/man-pages/pod1/vos_move.pod
+++ /dev/null
@@ -1,212 +0,0 @@
-=head1 NAME
-
-vos_move - Moves a read/write volume to another site
-
-=head1 SYNOPSIS
-
-=for html
-<div class="synopsis">
-
-B<vos move> S<<< B<-id> <I<volume name or ID>> >>>
-    S<<< B<-fromserver> <I<machine name on source>> >>>
-    S<<< B<-frompartition> <I<partition name on source>> >>>
-    S<<< B<-toserver> <I<machine name on destination>> >>>
-    S<<< B<-topartition> <I<partition name on destination>> >>>
-    [B<-live>] S<<< [B<-cell> <I<cell name>>] >>> [B<-noauth>] [B<-localauth>]
-    [B<-verbose>] [B<-encrypt>] [B<-noresolve>] [B<-help>]
-
-B<vos m> S<<< B<-i> <I<volume name or ID>> >>>
-    S<<< B<-froms> <I<machine name on source>> >>>
-    S<<< B<-fromp> <I<partition name on source>> >>>
-    S<<< B<-tos> <I<machine name on destination>> >>>
-    S<<< B<-top> <I<partition name on destination>> >>>
-    [B<-li>] S<<< [B<-c> <I<cell name>>] >>> [B<-noa>]
-    [B<-lo>] [B<-v>] [B<-e>] [B<-nor>] [B<-h>]
-
-=for html
-</div>
-
-=head1 DESCRIPTION
-
-The B<vos move> command moves the indicated read/write volume from its
-current site (specified with the B<-fromserver> and B<-frompartition>
-arguments) to the destination site (specified with the B<-toserver> and
-B<-topartition> arguments). This command automatically removes the backup
-copy from the current site, if it exists. To create a new backup volume at
-the destination site, use the B<vos backup> command.
-
-This command works on read/write volumes only. To move a read-only volume,
-use the B<vos addsite> and B<vos release> commands to define a new
-read-only site and release the volume contents to it, and then use the
-B<vos remove> command to remove the previous read-only volume's definition
-from the Volume Location Database (VLDB) and data from the partition. To
-move a backup volume, use this command to move its read/write source and
-then issue the B<vos backup> command.
-
-Before executing this command, the B<vos> command interpreter initiates a
-check that the destination partition contains enough space to house the
-volume being moved. If there is not enough space, the move operation is
-not attempted and the following message appears:
-
-   vos: no space on target partition <dest_part> to move volume <volume>
-
-=head1 CAUTIONS
-
-Unless there is a compelling reason, do not interrupt a B<vos move>
-command in progress. Interrupting a move can result in one or more of the
-following inconsistent states:
-
-=over 4
-
-=item *
-
-There are two versions of the volume, one at the source site and one at
-the destination site. (If this happens, retain the version identified by
-the VLDB and use the B<vos zap> command to remove the other version.)
-
-=item *
-
-The backup version of the volume is stranded at the old site. (If this
-happens, use the B<vos zap> command to remove it.)
-
-=item *
-
-The volume is off-line. (If this happens, run the B<bos salvage> command
-to bring it back on line.)
-
-=back
-
-If the Ctrl-C interrupt signal is pressed while a vos move operation is
-executing, the following message warns of the consequences and requests
-confirmation of the kill signal:
-
-   SIGINT handler: vos move operation in progress
-   WARNING: may leave AFS storage and metadata in indeterminate state
-   enter second control-c to exit
-
-To confirm termination of the operation, press Ctrl-C a second time; press
-any other key to continue the operation.
-
-Currently, the maximum size of a volume is 2 terabytes (2^31 bytes).
-
-=head1 OPTIONS
-
-=over 4
-
-=item B<-id> <I<volume name or ID>>
-
-Specifies either the complete name or volume ID number of a read/write
-volume.
-
-=item B<-fromserver> <I<server name>>
-
-Identifies the file server machine where the volume currently
-resides. Provide the machine's IP address or its host name (either fully
-qualified or using an unambiguous abbreviation). For details, see
-L<vos(1)>.
-
-=item B<-frompartition> <I<partition name>>
-
-Names the partition where the volume currently resides. Provide the full
-partition name (for, example, B</vicepa>) or one of the abbreviated forms
-described in L<vos(1)>.
-
-=item B<-toserver> <I<server name>>
-
-Identifies the file server machine to which to move the volume.  Provide
-the machine's IP address or its host name (either fully qualified or using
-an unambiguous abbreviation). For details, see L<vos(1)>.
-
-=item B<-topartition> <I<partition name>>
-
-Names the partition to which to move the volume. Provide the full
-partition name (for, example, B</vicepa>) or one of the abbreviated forms
-described in L<vos(1)>.
-
-=item B<-live>
-
-Avoids making a temporary copy of the volume during the move. This is
-useful if the partition is full, but the administrator needs to move
-volumes to a another partition or server to free up disk space. The
-caveat is that the volume is locked during the entire operation
-instead of the short time that is needed to make the temporary clone.
-
-=item B<-cell> <I<cell name>>
-
-Names the cell in which to run the command. Do not combine this argument
-with the B<-localauth> flag. For more details, see L<vos(1)>.
-
-=item B<-noauth>
-
-Assigns the unprivileged identity C<anonymous> to the issuer. Do not
-combine this flag with the B<-localauth> flag. For more details, see
-L<vos(1)>.
-
-=item B<-localauth>
-
-Constructs a server ticket using a key from the local
-F</usr/afs/etc/KeyFile> file. The B<vos> command interpreter presents it
-to the Volume Server and Volume Location Server during mutual
-authentication. Do not combine this flag with the B<-cell> argument or
-B<-noauth> flag. For more details, see L<vos(1)>.
-
-=item B<-verbose>
-
-Produces on the standard output stream a detailed trace of the command's
-execution. If this argument is omitted, only warnings and error messages
-appear.
-
-=item B<-encrypt>
-
-Encrypts the command so that the operation's results are not transmitted
-across the network in clear text. This option is available in OpenAFS
-versions 1.4.11 or later and 1.5.60 or later.
-
-=item B<-noresolve>
-
-Shows all servers as IP addresses instead of the DNS name. This is very
-useful when the server address is registered as 127.0.0.1 or when dealing
-with multi-homed servers. This option is available in OpenAFS
-versions 1.4.8 or later and 1.5.35 or later.
-
-=item B<-help>
-
-Prints the online help for this command. All other valid options are
-ignored.
-
-=back
-
-=head1 EXAMPLES
-
-The following example moves the volume C<user.smith> from the F</vicepb>
-partition on the file server machine C<fs3.abc.com> to the F</vicepg>
-partition on the file server machine C<fs7.abc.com>.
-
-   % vos move -id user.smith -fromserver fs3.abc.com -frompartition b \
-       -toserver fs7.abc.com -topartition g
-
-=head1 PRIVILEGE REQUIRED
-
-The issuer must be listed in the F</usr/afs/etc/UserList> file on the
-machines specified with the B<-toserver> and B<-fromserver> arguments and
-on each database server machine.  If the B<-localauth> flag is included,
-the issuer must instead be logged on to a server machine as the local
-superuser C<root>.
-
-=head1 SEE ALSO
-
-L<vos(1)>,
-L<vos_addsite(1)>,
-L<vos_backup(1)>,
-L<vos_copy(1)>,
-L<vos_release(1)>,
-L<vos_listvol(1)>,
-L<vos_remove(1)>
-
-=head1 COPYRIGHT
-
-IBM Corporation 2000. <http://www.ibm.com/> All Rights Reserved.
-
-This documentation is covered by the IBM Public License Version 1.0.  It was
-converted from HTML to POD by software written by Chas Williams and Russ
-Allbery, based on work by Alf Wachsmann and Elizabeth Cassell.
diff --git a/doc/man-pages/pod1/vos_move.pod.in b/doc/man-pages/pod1/vos_move.pod.in
new file mode 100644
index 0000000..4dea987
--- /dev/null
+++ b/doc/man-pages/pod1/vos_move.pod.in
@@ -0,0 +1,212 @@
+=head1 NAME
+
+vos_move - Moves a read/write volume to another site
+
+=head1 SYNOPSIS
+
+=for html
+<div class="synopsis">
+
+B<vos move> S<<< B<-id> <I<volume name or ID>> >>>
+    S<<< B<-fromserver> <I<machine name on source>> >>>
+    S<<< B<-frompartition> <I<partition name on source>> >>>
+    S<<< B<-toserver> <I<machine name on destination>> >>>
+    S<<< B<-topartition> <I<partition name on destination>> >>>
+    [B<-live>] S<<< [B<-cell> <I<cell name>>] >>> [B<-noauth>] [B<-localauth>]
+    [B<-verbose>] [B<-encrypt>] [B<-noresolve>] [B<-help>]
+
+B<vos m> S<<< B<-i> <I<volume name or ID>> >>>
+    S<<< B<-froms> <I<machine name on source>> >>>
+    S<<< B<-fromp> <I<partition name on source>> >>>
+    S<<< B<-tos> <I<machine name on destination>> >>>
+    S<<< B<-top> <I<partition name on destination>> >>>
+    [B<-li>] S<<< [B<-c> <I<cell name>>] >>> [B<-noa>]
+    [B<-lo>] [B<-v>] [B<-e>] [B<-nor>] [B<-h>]
+
+=for html
+</div>
+
+=head1 DESCRIPTION
+
+The B<vos move> command moves the indicated read/write volume from its
+current site (specified with the B<-fromserver> and B<-frompartition>
+arguments) to the destination site (specified with the B<-toserver> and
+B<-topartition> arguments). This command automatically removes the backup
+copy from the current site, if it exists. To create a new backup volume at
+the destination site, use the B<vos backup> command.
+
+This command works on read/write volumes only. To move a read-only volume,
+use the B<vos addsite> and B<vos release> commands to define a new
+read-only site and release the volume contents to it, and then use the
+B<vos remove> command to remove the previous read-only volume's definition
+from the Volume Location Database (VLDB) and data from the partition. To
+move a backup volume, use this command to move its read/write source and
+then issue the B<vos backup> command.
+
+Before executing this command, the B<vos> command interpreter initiates a
+check that the destination partition contains enough space to house the
+volume being moved. If there is not enough space, the move operation is
+not attempted and the following message appears:
+
+   vos: no space on target partition <dest_part> to move volume <volume>
+
+=head1 CAUTIONS
+
+Unless there is a compelling reason, do not interrupt a B<vos move>
+command in progress. Interrupting a move can result in one or more of the
+following inconsistent states:
+
+=over 4
+
+=item *
+
+There are two versions of the volume, one at the source site and one at
+the destination site. (If this happens, retain the version identified by
+the VLDB and use the B<vos zap> command to remove the other version.)
+
+=item *
+
+The backup version of the volume is stranded at the old site. (If this
+happens, use the B<vos zap> command to remove it.)
+
+=item *
+
+The volume is off-line. (If this happens, run the B<bos salvage> command
+to bring it back on line.)
+
+=back
+
+If the Ctrl-C interrupt signal is pressed while a vos move operation is
+executing, the following message warns of the consequences and requests
+confirmation of the kill signal:
+
+   SIGINT handler: vos move operation in progress
+   WARNING: may leave AFS storage and metadata in indeterminate state
+   enter second control-c to exit
+
+To confirm termination of the operation, press Ctrl-C a second time; press
+any other key to continue the operation.
+
+=include fragments/volsize-caution.pod
+
+=head1 OPTIONS
+
+=over 4
+
+=item B<-id> <I<volume name or ID>>
+
+Specifies either the complete name or volume ID number of a read/write
+volume.
+
+=item B<-fromserver> <I<server name>>
+
+Identifies the file server machine where the volume currently
+resides. Provide the machine's IP address or its host name (either fully
+qualified or using an unambiguous abbreviation). For details, see
+L<vos(1)>.
+
+=item B<-frompartition> <I<partition name>>
+
+Names the partition where the volume currently resides. Provide the full
+partition name (for, example, B</vicepa>) or one of the abbreviated forms
+described in L<vos(1)>.
+
+=item B<-toserver> <I<server name>>
+
+Identifies the file server machine to which to move the volume.  Provide
+the machine's IP address or its host name (either fully qualified or using
+an unambiguous abbreviation). For details, see L<vos(1)>.
+
+=item B<-topartition> <I<partition name>>
+
+Names the partition to which to move the volume. Provide the full
+partition name (for, example, B</vicepa>) or one of the abbreviated forms
+described in L<vos(1)>.
+
+=item B<-live>
+
+Avoids making a temporary copy of the volume during the move. This is
+useful if the partition is full, but the administrator needs to move
+volumes to a another partition or server to free up disk space. The
+caveat is that the volume is locked during the entire operation
+instead of the short time that is needed to make the temporary clone.
+
+=item B<-cell> <I<cell name>>
+
+Names the cell in which to run the command. Do not combine this argument
+with the B<-localauth> flag. For more details, see L<vos(1)>.
+
+=item B<-noauth>
+
+Assigns the unprivileged identity C<anonymous> to the issuer. Do not
+combine this flag with the B<-localauth> flag. For more details, see
+L<vos(1)>.
+
+=item B<-localauth>
+
+Constructs a server ticket using a key from the local
+F</usr/afs/etc/KeyFile> file. The B<vos> command interpreter presents it
+to the Volume Server and Volume Location Server during mutual
+authentication. Do not combine this flag with the B<-cell> argument or
+B<-noauth> flag. For more details, see L<vos(1)>.
+
+=item B<-verbose>
+
+Produces on the standard output stream a detailed trace of the command's
+execution. If this argument is omitted, only warnings and error messages
+appear.
+
+=item B<-encrypt>
+
+Encrypts the command so that the operation's results are not transmitted
+across the network in clear text. This option is available in OpenAFS
+versions 1.4.11 or later and 1.5.60 or later.
+
+=item B<-noresolve>
+
+Shows all servers as IP addresses instead of the DNS name. This is very
+useful when the server address is registered as 127.0.0.1 or when dealing
+with multi-homed servers. This option is available in OpenAFS
+versions 1.4.8 or later and 1.5.35 or later.
+
+=item B<-help>
+
+Prints the online help for this command. All other valid options are
+ignored.
+
+=back
+
+=head1 EXAMPLES
+
+The following example moves the volume C<user.smith> from the F</vicepb>
+partition on the file server machine C<fs3.abc.com> to the F</vicepg>
+partition on the file server machine C<fs7.abc.com>.
+
+   % vos move -id user.smith -fromserver fs3.abc.com -frompartition b \
+       -toserver fs7.abc.com -topartition g
+
+=head1 PRIVILEGE REQUIRED
+
+The issuer must be listed in the F</usr/afs/etc/UserList> file on the
+machines specified with the B<-toserver> and B<-fromserver> arguments and
+on each database server machine.  If the B<-localauth> flag is included,
+the issuer must instead be logged on to a server machine as the local
+superuser C<root>.
+
+=head1 SEE ALSO
+
+L<vos(1)>,
+L<vos_addsite(1)>,
+L<vos_backup(1)>,
+L<vos_copy(1)>,
+L<vos_release(1)>,
+L<vos_listvol(1)>,
+L<vos_remove(1)>
+
+=head1 COPYRIGHT
+
+IBM Corporation 2000. <http://www.ibm.com/> All Rights Reserved.
+
+This documentation is covered by the IBM Public License Version 1.0.  It was
+converted from HTML to POD by software written by Chas Williams and Russ
+Allbery, based on work by Alf Wachsmann and Elizabeth Cassell.
diff --git a/doc/man-pages/pod1/vos_partinfo.pod b/doc/man-pages/pod1/vos_partinfo.pod
deleted file mode 100644
index 483a942..0000000
--- a/doc/man-pages/pod1/vos_partinfo.pod
+++ /dev/null
@@ -1,145 +0,0 @@
-=head1 NAME
-
-vos_partinfo - Reports the available and total space on a partition
-
-=head1 SYNOPSIS
-
-=for html
-<div class="synopsis">
-
-B<vos partinfo> S<<< B<-server> <I<machine name>> >>>
-    S<<< [B<-partition> <I<partition name>>] >>> [B<-summary>]
-    S<<< [B<-cell> <I<cell name>>] >>>
-    [B<-noauth>] [B<-localauth>]
-    [B<-verbose>] [B<-encrypt>] [B<-noresolve>] [B<-help>]
-
-B<vos p> S<<< B<-se> <I<machine name>> >>>
-    S<<< [B<-p> <I<partition name>>] >>> [B<-su>]
-    S<<< [B<-c> <I<cell name>>] >>>
-    [B<-noa>] [B<-l>] [B<-v>] [B<-e>] [B<-nor>] [B<-h>]
-
-=for html
-</div>
-
-=head1 DESCRIPTION
-
-The vos partinfo command reports the amount of space available and total
-size on either all of the partitions on the indicated file server machine
-(if the B<-partition> argument is omitted) or the specified partition on
-that file server machine. The Volume Location Database (VLDB) is not
-consulted.
-
-=head1 CAUTIONS
-
-Currently, the maximum size of a volume is 2 terabytes (2^31 bytes).
-
-=head1 OPTIONS
-
-=over 4
-
-=item B<-server> <I<server name>>
-
-Identifies the file server machine for which to display partition
-information. Provide the machine's IP address or its host name (either
-fully qualified or using an unambiguous abbreviation). For details, see
-L<vos(1)>.
-
-=item B<-partition> <I<partition name>>
-
-Identifies which partition on the file server machine specified by the
-B<-server> argument for which to display information. Provide the
-partition's complete name with preceding slash (for example, C</vicepa>)
-or use one of the three acceptable abbreviated forms. For details, see
-L<vos(1)>.
-
-=item B<-summary>
-
-Prints storage summary.
-
-=item B<-cell> <I<cell name>>
-
-Names the cell in which to run the command. Do not combine this argument
-with the B<-localauth> flag. For more details, see L<vos(1)>.
-
-=item B<-noauth>
-
-Assigns the unprivileged identity C<anonymous> to the issuer. Do not
-combine this flag with the B<-localauth> flag. For more details, see
-L<vos(1)>.
-
-=item B<-localauth>
-
-Constructs a server ticket using a key from the local
-F</usr/afs/etc/KeyFile> file. The B<vos> command interpreter presents it
-to the Volume Server and Volume Location Server during mutual
-authentication. Do not combine this flag with the B<-cell> argument or
-B<-noauth> flag. For more details, see L<vos(1)>.
-
-=item B<-verbose>
-
-Produces on the standard output stream a detailed trace of the command's
-execution. If this argument is omitted, only warnings and error messages
-appear.
-
-=item B<-encrypt>
-
-Encrypts the command so that the operation's results are not transmitted
-across the network in clear text. This option is available in OpenAFS
-versions 1.4.11 or later and 1.5.60 or later.
-
-=item B<-noresolve>
-
-Shows all servers as IP addresses instead of the DNS name. This is very
-useful when the server address is registered as 127.0.0.1 or when dealing
-with multi-homed servers. This option is available in OpenAFS
-versions 1.4.8 or later and 1.5.35 or later.
-
-=item B<-help>
-
-Prints the online help for this command. All other valid options are
-ignored.
-
-=back
-
-=head1 CAUTIONS
-
-The partition-related statistics in this command's output do not always
-agree with the corresponding values in the output of the standard UNIX
-B<df> command. The statistics reported by this command can be up to five
-minutes old, because the Cache Manager polls the File Server for partition
-information at that frequency. Also, on some operating systems, the B<df>
-command's report of partition size includes reserved space not included in
-this command's calculation, and so is likely to be about 10% larger.
-
-=head1 OUTPUT
-
-The output reports the amount of space available and total space for each
-specified partition.
-
-=head1 EXAMPLES
-
-The following command displays all partitions on the file server machine
-C<fs2.abc.com>.
-
-   % vos partinfo fs2.abc.com
-   Free space on partition /vicepa: 27301 K blocks out of total 549197
-   Free space on partition /vicepb: 13646 K blocks out of total 69194
-   Free space on partition /vicepc: 31798 K blocks out of total 320315
-   Free space on partition /vicepd: 33302 K blocks out of total 494954
-
-=head1 PRIVILEGE REQUIRED
-
-None
-
-=head1 SEE ALSO
-
-L<vos(1)>,
-L<vos_listpart(1)>
-
-=head1 COPYRIGHT
-
-IBM Corporation 2000. <http://www.ibm.com/> All Rights Reserved.
-
-This documentation is covered by the IBM Public License Version 1.0.  It was
-converted from HTML to POD by software written by Chas Williams and Russ
-Allbery, based on work by Alf Wachsmann and Elizabeth Cassell.
diff --git a/doc/man-pages/pod1/vos_partinfo.pod.in b/doc/man-pages/pod1/vos_partinfo.pod.in
new file mode 100644
index 0000000..5aeccf1
--- /dev/null
+++ b/doc/man-pages/pod1/vos_partinfo.pod.in
@@ -0,0 +1,145 @@
+=head1 NAME
+
+vos_partinfo - Reports the available and total space on a partition
+
+=head1 SYNOPSIS
+
+=for html
+<div class="synopsis">
+
+B<vos partinfo> S<<< B<-server> <I<machine name>> >>>
+    S<<< [B<-partition> <I<partition name>>] >>> [B<-summary>]
+    S<<< [B<-cell> <I<cell name>>] >>>
+    [B<-noauth>] [B<-localauth>]
+    [B<-verbose>] [B<-encrypt>] [B<-noresolve>] [B<-help>]
+
+B<vos p> S<<< B<-se> <I<machine name>> >>>
+    S<<< [B<-p> <I<partition name>>] >>> [B<-su>]
+    S<<< [B<-c> <I<cell name>>] >>>
+    [B<-noa>] [B<-l>] [B<-v>] [B<-e>] [B<-nor>] [B<-h>]
+
+=for html
+</div>
+
+=head1 DESCRIPTION
+
+The vos partinfo command reports the amount of space available and total
+size on either all of the partitions on the indicated file server machine
+(if the B<-partition> argument is omitted) or the specified partition on
+that file server machine. The Volume Location Database (VLDB) is not
+consulted.
+
+=head1 CAUTIONS
+
+=include fragments/volsize-caution.pod
+
+=head1 OPTIONS
+
+=over 4
+
+=item B<-server> <I<server name>>
+
+Identifies the file server machine for which to display partition
+information. Provide the machine's IP address or its host name (either
+fully qualified or using an unambiguous abbreviation). For details, see
+L<vos(1)>.
+
+=item B<-partition> <I<partition name>>
+
+Identifies which partition on the file server machine specified by the
+B<-server> argument for which to display information. Provide the
+partition's complete name with preceding slash (for example, C</vicepa>)
+or use one of the three acceptable abbreviated forms. For details, see
+L<vos(1)>.
+
+=item B<-summary>
+
+Prints storage summary.
+
+=item B<-cell> <I<cell name>>
+
+Names the cell in which to run the command. Do not combine this argument
+with the B<-localauth> flag. For more details, see L<vos(1)>.
+
+=item B<-noauth>
+
+Assigns the unprivileged identity C<anonymous> to the issuer. Do not
+combine this flag with the B<-localauth> flag. For more details, see
+L<vos(1)>.
+
+=item B<-localauth>
+
+Constructs a server ticket using a key from the local
+F</usr/afs/etc/KeyFile> file. The B<vos> command interpreter presents it
+to the Volume Server and Volume Location Server during mutual
+authentication. Do not combine this flag with the B<-cell> argument or
+B<-noauth> flag. For more details, see L<vos(1)>.
+
+=item B<-verbose>
+
+Produces on the standard output stream a detailed trace of the command's
+execution. If this argument is omitted, only warnings and error messages
+appear.
+
+=item B<-encrypt>
+
+Encrypts the command so that the operation's results are not transmitted
+across the network in clear text. This option is available in OpenAFS
+versions 1.4.11 or later and 1.5.60 or later.
+
+=item B<-noresolve>
+
+Shows all servers as IP addresses instead of the DNS name. This is very
+useful when the server address is registered as 127.0.0.1 or when dealing
+with multi-homed servers. This option is available in OpenAFS
+versions 1.4.8 or later and 1.5.35 or later.
+
+=item B<-help>
+
+Prints the online help for this command. All other valid options are
+ignored.
+
+=back
+
+=head1 CAUTIONS
+
+The partition-related statistics in this command's output do not always
+agree with the corresponding values in the output of the standard UNIX
+B<df> command. The statistics reported by this command can be up to five
+minutes old, because the Cache Manager polls the File Server for partition
+information at that frequency. Also, on some operating systems, the B<df>
+command's report of partition size includes reserved space not included in
+this command's calculation, and so is likely to be about 10% larger.
+
+=head1 OUTPUT
+
+The output reports the amount of space available and total space for each
+specified partition.
+
+=head1 EXAMPLES
+
+The following command displays all partitions on the file server machine
+C<fs2.abc.com>.
+
+   % vos partinfo fs2.abc.com
+   Free space on partition /vicepa: 27301 K blocks out of total 549197
+   Free space on partition /vicepb: 13646 K blocks out of total 69194
+   Free space on partition /vicepc: 31798 K blocks out of total 320315
+   Free space on partition /vicepd: 33302 K blocks out of total 494954
+
+=head1 PRIVILEGE REQUIRED
+
+None
+
+=head1 SEE ALSO
+
+L<vos(1)>,
+L<vos_listpart(1)>
+
+=head1 COPYRIGHT
+
+IBM Corporation 2000. <http://www.ibm.com/> All Rights Reserved.
+
+This documentation is covered by the IBM Public License Version 1.0.  It was
+converted from HTML to POD by software written by Chas Williams and Russ
+Allbery, based on work by Alf Wachsmann and Elizabeth Cassell.
diff --git a/doc/man-pages/pod1/vos_shadow.pod b/doc/man-pages/pod1/vos_shadow.pod
deleted file mode 100644
index 4987ba2..0000000
--- a/doc/man-pages/pod1/vos_shadow.pod
+++ /dev/null
@@ -1,195 +0,0 @@
-=head1 NAME
-
-vos_shadow - Creates a shadow copy of a volume on a different server/partition
-
-=head1 SYNOPSIS
-
-=for html
-<div class="synopsis">
-
-B<vos shadow> S<<< [B<-id>] <I<volume name or ID on source>> >>>
-    S<<< [B<-fromserver>] <I<machine name on source>> >>>
-    S<<< [B<-frompartition>] <I<partition name on source>> >>>
-    S<<< [B<-toserver>] <I<machine name on destination>> >>>
-    S<<< [B<-topartition>] <I<partition name on destination>> >>>
-    S<<< [B<-toname> <I<volume name on destination>>] >>>
-    S<<< [B<-toid> <I<volume ID on destination>>] >>>
-    [B<-offline>] [B<-readonly>] [B<-live>] [B<-incremental>]
-    S<<< [B<-cell> <I<cell name>>] >>>
-    [B<-noauth>] [B<-localauth>]
-    [B<-verbose>] [B<-encrypt>] [B<-noresolve>] [B<-help>]
-
-B<vos sh> S<<< [B<-id>] <I<volume name or ID on source>> >>>
-    S<<< [B<-froms>] <I<machine name on source>> >>>
-    S<<< [B<-fromp>] <I<partition name on source>> >>>
-    S<<< [B<-tos>] <I<machine name on destination>> >>>
-    S<<< [B<-top>] <I<partition name on destination>> >>>
-    S<<< [B<-ton> <I<volume name on destination>>] >>>
-    S<<< [B<-toi> <I<volume ID on destination>>] >>>
-    [B<-o>] [B<-r>] [B<-l>] [B<-in>]
-    S<<< [B<-c> <I<cell name>>] >>>
-    [B<-noa>] [B<-lo>] [B<-v>] [B<-e>] [B<-nor>] [B<-h>]
-
-=for html
-</div>
-
-=head1 DESCRIPTION
-
-The B<vos shadow> command creates a shadow copy of a volume on a
-different partition or server.
-
-A shadow volume is a copy of a volume that does not normally appear in
-the volume location database (VLDB). It is a primitive operation that
-is meant to be used in backup or disaster recovery situations.
-
-=head1 CAUTIONS
-
-This command is not used during normal OpenAFS administration and may
-have adverse effects on the VLDB if not used properly! This command
-should only be used by an expert.
-
-Using this command on a volume when the source volume is not the same
-as parent volume used to create the shadow will leave the destination
-volume in a unknown state.
-
-Do NOT run the B<vos syncserv> or B<vos syncvldb> on any fileserver
-containing shadow volumes. This would update the VLDB to show all
-shadowed Read/Write volumes instead of the source volumes from which
-they were copied.
-
-Currently, the maximum size of a volume is 2 terabytes (2^31 bytes).
-
-=head1 OPTIONS
-
-=over 4
-
-=item [B<-id>] <I<volume name or ID>>
-
-Specifies either the complete name or volume ID number of a read/write
-volume.
-
-=item [B<-fromserver>] <I<machine name for source>>
-
-Identifies the file server machine where the source volume resides. Provide
-the machine's IP address or its host name (either fully qualified or using
-an unambiguous abbreviation). For details, see L<vos(1)>.
-
-=item [B<-frompartition>] <I<partition name for source>>
-
-Names the partition where the source volume resides. Provide the full
-partition name (for, example, B</vicepa>) or one of the abbreviated forms
-described in L<vos(1)>.
-
-=item [B<-toserver>] <I<machine name for destination>>
-
-Identifies the file server machine to which to copy the volume.  Provide
-the machine's IP address or its host name (either fully qualified or using
-an unambiguous abbreviation). For details, see L<vos(1)>.
-
-=item [B<-topartition>] <I<partition name for destination>>
-
-Names the partition to which to copy the volume. Provide the full partition
-name (for, example, B</vicepa>) or one of the abbreviated forms described in
-L<vos(1)>.
-
-=item B<-toname> <I<volume name for new copy>>
-
-The complete name of the new volume to create.
-
-=item B<-offline>
-
-Leaves the new volume flagged as off-line in the volume database.
-
-=item B<-readonly>
-
-Flags the new volume as read-only in the volume database.
-
-=item B<-live>
-
-Copies the live volume without cloning.  This is normally not necessary and
-causes the volume to be kept locked for longer than the normal copy
-mechanism.
-
-=item B<-incremental>
-
-Copy the changes from the source volume to a previously created shadow
-volume.
-
-=item B<-cell> <I<cell name>>
-
-Names the cell in which to run the command. Do not combine this argument
-with the B<-localauth> flag. For more details, see L<vos(1)>.
-
-=item B<-noauth>
-
-Assigns the unprivileged identity C<anonymous> to the issuer. Do not
-combine this flag with the B<-localauth> flag. For more details, see
-L<vos(1)>.
-
-=item B<-localauth>
-
-Constructs a server ticket using a key from the local
-F</usr/afs/etc/KeyFile> file. The B<vos> command interpreter presents
-it to the Volume Server and Volume Location Server during mutual
-authentication. Do not combine this flag with the B<-cell> argument or
-B<-noauth> flag. For more details, see L<vos(1)>.
-
-=item B<-verbose>
-
-Produces on the standard output stream a detailed trace of the command's
-execution. If this argument is omitted, only warnings and error messages
-appear.
-
-=item B<-encrypt>
-
-Encrypts the command so that the operation's results are not transmitted
-across the network in clear text. This option is available in OpenAFS
-versions 1.4.11 or later and 1.5.60 or later.
-
-=item B<-noresolve>
-
-Shows all servers as IP addresses instead of the DNS name. This is very
-useful when the server address is registered as 127.0.0.1 or when dealing
-with multi-homed servers. This option is available in OpenAFS
-versions 1.4.8 or later and 1.5.35 or later.
-
-=item B<-help>
-
-Prints the online help for this command. All other valid options are
-ignored.
-
-=back
-
-=head1 OUTPUT
-
-This command has no output unless C<-verbose> is specified or there is
-an error.
-
-=head1 PRIVILEGE REQUIRED
-
-The issuer must be listed in the F</usr/afs/etc/UserList> file on the
-machines specified with the B<-toserver> and B<-fromserver> arguments and
-on each database server machine.  If the B<-localauth> flag is included,
-the issuer must instead be logged on to a server machine as the local
-superuser C<root>.
-
-=head1 SEE ALSO
-
-L<vos(1)>,
-L<vos_backup(1)>,
-L<vos_copy(1)>,
-L<vos_move(1)>
-
-L<http://www.openafs.org/pipermail/openafs-info/2005-July/018469.html>
-discusses motivation for the creation of this command.
-
-L<http://workshop.openafs.org/afsbpw06/talks/drh.scs.html> discusses
-one possible use for it.
-
-=head1 COPYRIGHT
-
-Copyright 2008 Jason Edgecombe <jason@rampaginggeek.com>
-
-This documentation is covered by the BSD License as written in the
-doc/LICENSE file. This man page was written by Jason Edgecombe for
-OpenAFS.
diff --git a/doc/man-pages/pod1/vos_shadow.pod.in b/doc/man-pages/pod1/vos_shadow.pod.in
new file mode 100644
index 0000000..3852151
--- /dev/null
+++ b/doc/man-pages/pod1/vos_shadow.pod.in
@@ -0,0 +1,195 @@
+=head1 NAME
+
+vos_shadow - Creates a shadow copy of a volume on a different server/partition
+
+=head1 SYNOPSIS
+
+=for html
+<div class="synopsis">
+
+B<vos shadow> S<<< [B<-id>] <I<volume name or ID on source>> >>>
+    S<<< [B<-fromserver>] <I<machine name on source>> >>>
+    S<<< [B<-frompartition>] <I<partition name on source>> >>>
+    S<<< [B<-toserver>] <I<machine name on destination>> >>>
+    S<<< [B<-topartition>] <I<partition name on destination>> >>>
+    S<<< [B<-toname> <I<volume name on destination>>] >>>
+    S<<< [B<-toid> <I<volume ID on destination>>] >>>
+    [B<-offline>] [B<-readonly>] [B<-live>] [B<-incremental>]
+    S<<< [B<-cell> <I<cell name>>] >>>
+    [B<-noauth>] [B<-localauth>]
+    [B<-verbose>] [B<-encrypt>] [B<-noresolve>] [B<-help>]
+
+B<vos sh> S<<< [B<-id>] <I<volume name or ID on source>> >>>
+    S<<< [B<-froms>] <I<machine name on source>> >>>
+    S<<< [B<-fromp>] <I<partition name on source>> >>>
+    S<<< [B<-tos>] <I<machine name on destination>> >>>
+    S<<< [B<-top>] <I<partition name on destination>> >>>
+    S<<< [B<-ton> <I<volume name on destination>>] >>>
+    S<<< [B<-toi> <I<volume ID on destination>>] >>>
+    [B<-o>] [B<-r>] [B<-l>] [B<-in>]
+    S<<< [B<-c> <I<cell name>>] >>>
+    [B<-noa>] [B<-lo>] [B<-v>] [B<-e>] [B<-nor>] [B<-h>]
+
+=for html
+</div>
+
+=head1 DESCRIPTION
+
+The B<vos shadow> command creates a shadow copy of a volume on a
+different partition or server.
+
+A shadow volume is a copy of a volume that does not normally appear in
+the volume location database (VLDB). It is a primitive operation that
+is meant to be used in backup or disaster recovery situations.
+
+=head1 CAUTIONS
+
+This command is not used during normal OpenAFS administration and may
+have adverse effects on the VLDB if not used properly! This command
+should only be used by an expert.
+
+Using this command on a volume when the source volume is not the same
+as parent volume used to create the shadow will leave the destination
+volume in a unknown state.
+
+Do NOT run the B<vos syncserv> or B<vos syncvldb> on any fileserver
+containing shadow volumes. This would update the VLDB to show all
+shadowed Read/Write volumes instead of the source volumes from which
+they were copied.
+
+=include fragments/volsize-caution.pod
+
+=head1 OPTIONS
+
+=over 4
+
+=item [B<-id>] <I<volume name or ID>>
+
+Specifies either the complete name or volume ID number of a read/write
+volume.
+
+=item [B<-fromserver>] <I<machine name for source>>
+
+Identifies the file server machine where the source volume resides. Provide
+the machine's IP address or its host name (either fully qualified or using
+an unambiguous abbreviation). For details, see L<vos(1)>.
+
+=item [B<-frompartition>] <I<partition name for source>>
+
+Names the partition where the source volume resides. Provide the full
+partition name (for, example, B</vicepa>) or one of the abbreviated forms
+described in L<vos(1)>.
+
+=item [B<-toserver>] <I<machine name for destination>>
+
+Identifies the file server machine to which to copy the volume.  Provide
+the machine's IP address or its host name (either fully qualified or using
+an unambiguous abbreviation). For details, see L<vos(1)>.
+
+=item [B<-topartition>] <I<partition name for destination>>
+
+Names the partition to which to copy the volume. Provide the full partition
+name (for, example, B</vicepa>) or one of the abbreviated forms described in
+L<vos(1)>.
+
+=item B<-toname> <I<volume name for new copy>>
+
+The complete name of the new volume to create.
+
+=item B<-offline>
+
+Leaves the new volume flagged as off-line in the volume database.
+
+=item B<-readonly>
+
+Flags the new volume as read-only in the volume database.
+
+=item B<-live>
+
+Copies the live volume without cloning.  This is normally not necessary and
+causes the volume to be kept locked for longer than the normal copy
+mechanism.
+
+=item B<-incremental>
+
+Copy the changes from the source volume to a previously created shadow
+volume.
+
+=item B<-cell> <I<cell name>>
+
+Names the cell in which to run the command. Do not combine this argument
+with the B<-localauth> flag. For more details, see L<vos(1)>.
+
+=item B<-noauth>
+
+Assigns the unprivileged identity C<anonymous> to the issuer. Do not
+combine this flag with the B<-localauth> flag. For more details, see
+L<vos(1)>.
+
+=item B<-localauth>
+
+Constructs a server ticket using a key from the local
+F</usr/afs/etc/KeyFile> file. The B<vos> command interpreter presents
+it to the Volume Server and Volume Location Server during mutual
+authentication. Do not combine this flag with the B<-cell> argument or
+B<-noauth> flag. For more details, see L<vos(1)>.
+
+=item B<-verbose>
+
+Produces on the standard output stream a detailed trace of the command's
+execution. If this argument is omitted, only warnings and error messages
+appear.
+
+=item B<-encrypt>
+
+Encrypts the command so that the operation's results are not transmitted
+across the network in clear text. This option is available in OpenAFS
+versions 1.4.11 or later and 1.5.60 or later.
+
+=item B<-noresolve>
+
+Shows all servers as IP addresses instead of the DNS name. This is very
+useful when the server address is registered as 127.0.0.1 or when dealing
+with multi-homed servers. This option is available in OpenAFS
+versions 1.4.8 or later and 1.5.35 or later.
+
+=item B<-help>
+
+Prints the online help for this command. All other valid options are
+ignored.
+
+=back
+
+=head1 OUTPUT
+
+This command has no output unless C<-verbose> is specified or there is
+an error.
+
+=head1 PRIVILEGE REQUIRED
+
+The issuer must be listed in the F</usr/afs/etc/UserList> file on the
+machines specified with the B<-toserver> and B<-fromserver> arguments and
+on each database server machine.  If the B<-localauth> flag is included,
+the issuer must instead be logged on to a server machine as the local
+superuser C<root>.
+
+=head1 SEE ALSO
+
+L<vos(1)>,
+L<vos_backup(1)>,
+L<vos_copy(1)>,
+L<vos_move(1)>
+
+L<http://www.openafs.org/pipermail/openafs-info/2005-July/018469.html>
+discusses motivation for the creation of this command.
+
+L<http://workshop.openafs.org/afsbpw06/talks/drh.scs.html> discusses
+one possible use for it.
+
+=head1 COPYRIGHT
+
+Copyright 2008 Jason Edgecombe <jason@rampaginggeek.com>
+
+This documentation is covered by the BSD License as written in the
+doc/LICENSE file. This man page was written by Jason Edgecombe for
+OpenAFS.
diff --git a/doc/man-pages/pod5/NetRestrict.pod b/doc/man-pages/pod5/NetRestrict.pod
index e69b579..be527fc 100644
--- a/doc/man-pages/pod5/NetRestrict.pod
+++ b/doc/man-pages/pod5/NetRestrict.pod
@@ -11,6 +11,13 @@ File Servers it connects to.  The server F<NetRestrict> file specifies
 what interfaces should not be registered with AFS Database Servers or used
 to talk to other database servers.
 
+=head2 FORMAT
+
+The F<NetRestrict> file is in ASCII format. One IP address appears on each
+line, in dotted decimal format. The order of the addresses is not
+significant. There is currently no mechanism to specify a range of
+addresses or a wildcard; each IP address must be listed individually.
+
 =head2 Client NetRestrict
 
 The F<NetRestrict> file, if present in a client machine's F</usr/vice/etc>
@@ -28,10 +35,7 @@ list in kernel memory.
 
 The F<NetRestrict> file is in ASCII format. One IP address appears on each
 line, in dotted decimal format. The order of the addresses is not
-significant. The value C<255> is a wildcard that represents all possible
-addresses in that field. For example, the value C<192.12.105.255>
-indicates that the Cache Manager does not register any of the addresses in
-the C<192.12.105> subnet.
+significant.
 
 To display the addresses the Cache Manager is currently registering with
 File Servers, use the B<fs getclientaddrs> command.
@@ -67,10 +71,6 @@ the VLDB. The database server processes use a similar procedure when
 initializing, to determine which interfaces to use for communication with
 the peer processes on other database machines in the cell.
 
-The F<NetRestrict> file is in ASCII format. One IP address appears on each
-line, in dotted decimal format. The order of the addresses is not
-significant. 
-
 To display the File Server interface addresses registered in the VLDB, use
 the B<vos listaddrs> command.
 
diff --git a/doc/man-pages/pod8/fragments/fileserver-cautions.pod b/doc/man-pages/pod8/fragments/fileserver-cautions.pod
index 01c7db5..5d9230a 100644
--- a/doc/man-pages/pod8/fragments/fileserver-cautions.pod
+++ b/doc/man-pages/pod8/fragments/fileserver-cautions.pod
@@ -28,7 +28,7 @@ Options that are available only on some system types, such as the B<-m>
 and B<-lock> options, appear in the output generated by the B<-help>
 option only on the relevant system type.
 
-Currently, the maximum size of a volume is 2 terabytes (2^31 bytes)
+Currently, the maximum size of a volume quota is 2 terabytes (2^41 bytes)
 and the maximum size of a /vicepX partition on a fileserver is 2^64
 kilobytes. The maximum partition size in releases 1.4.7 and earlier is
 2 terabytes (2^31 bytes). The maximum partition size for 1.5.x
diff --git a/doc/txt/winnotes/afs-changes-since-1.2.txt b/doc/txt/winnotes/afs-changes-since-1.2.txt
index 9e53feb..1190360 100644
--- a/doc/txt/winnotes/afs-changes-since-1.2.txt
+++ b/doc/txt/winnotes/afs-changes-since-1.2.txt
@@ -1,3 +1,15 @@
+Since 1.6.0103 (1.6.1pre4)
+
+ * Revert Win7 SMB Reconnect Bug Workaround
+
+  The workaround breaks systems where "afs.<fqdn>" is a valid
+  DNS name or systems joined to an AD domain but unable to
+  connect to the AD servers.
+
+ * VNOSERVICE errors should not result in the file server
+   or the volume being marked offline.  Instead the RPC should
+   be retried.
+
 Since 1.6.0102 (1.6.1pre3)
 
  * Workaround Win7 SMB Reconnect Bug
diff --git a/src/WINNT/afsd/cm_conn.c b/src/WINNT/afsd/cm_conn.c
index f6a644e..00edbba 100644
--- a/src/WINNT/afsd/cm_conn.c
+++ b/src/WINNT/afsd/cm_conn.c
@@ -838,7 +838,8 @@ cm_Analyze(cm_conn_t *connp,
                         ((serverp->addr.sin_addr.s_addr & 0xff0000)>> 16),
                         ((serverp->addr.sin_addr.s_addr & 0xff000000)>> 24));
 
-            LogEvent(EVENTLOG_WARNING_TYPE, MSG_SERVER_REPORTS_VNOSERVICE, addr);
+            LogEvent(EVENTLOG_WARNING_TYPE, MSG_SERVER_REPORTS_VNOSERVICE,
+                     addr, fidp->volume, cellp->name);
             osi_Log1(afsd_logp, "Server %s reported volume %d in cell %s as not in service.",
                      osi_LogSaveString(afsd_logp,addr), fidp->volume, cellp->name);
         }
diff --git a/src/WINNT/bosctlsvc/bosctlsvc.c b/src/WINNT/bosctlsvc/bosctlsvc.c
index 475d7ac..0a93e6b 100644
--- a/src/WINNT/bosctlsvc/bosctlsvc.c
+++ b/src/WINNT/bosctlsvc/bosctlsvc.c
@@ -35,7 +35,6 @@
 
 #define BOSSERVER_STARTMSG_EXE  "afslegal.exe"
 
-#define BOSSERVER_RESTART_ARG_MAX  3  /* "-noauth", "-log", "-rxbind" */
 #define BOSSERVER_WAIT_TIME_HINT  60  /* seconds */
 #define BOSSERVER_STOP_TIME_MAX  (FSSDTIME + 60)  /* seconds */
 
@@ -76,7 +75,6 @@ static void BosserverDoStopEvent(pid_t cpid,
 static void BosserverDoExitEvent(pid_t cpid,
 				 BOOL *doWait,
 				 BOOL *doRestart,
-				 char **restartArgv,
 				 DWORD *stopStatus,
 				 BOOL *isWin32Code);
 
@@ -382,7 +380,6 @@ static void
 BosserverDoExitEvent(pid_t cpid,
 		     BOOL *doWait,
 		     BOOL *doRestart,
-		     char **restartArgv,
 		     DWORD *stopStatus,
 		     BOOL *isWin32Code)
 {
@@ -402,27 +399,6 @@ BosserverDoExitEvent(pid_t cpid,
 		/* bosserver requests restart */
 		int i;
 		*doRestart = TRUE;
-
-		/* set up bosserver argument list */
-		restartArgv[0] = (char *)AFSDIR_SERVER_BOSVR_FILEPATH;
-		i = 1;
-
-		if (exitCode & BOSEXIT_NOAUTH_FLAG) {
-		    /* pass "-noauth" to new bosserver */
-		    restartArgv[i] = "-noauth";
-		    i++;
-		}
-		if (exitCode & BOSEXIT_LOGGING_FLAG) {
-		    /* pass "-log" to new bosserver */
-		    restartArgv[i] = "-log";
-		    i++;
-		}
-		if (exitCode & BOSEXIT_RXBIND_FLAG) {
-		    /* pass "-rxbind" to new bosserver */
-		    restartArgv[i] = "-rxbind";
-		    i++;
-		}
-		restartArgv[i] = NULL;
 	    }
 	}
 
@@ -464,9 +440,8 @@ BosserverRun(DWORD argc,
     /* Set env variable forcing process mgmt lib to spawn processes detached */
     (void)putenv(PMGT_SPAWN_DETACHED_ENV_NAME "=1");
 
-    /* Alloc block with room for at least BOSSERVER_RESTART_ARG_MAX args */
-    i = max((argc + 1), (BOSSERVER_RESTART_ARG_MAX + 2));
-    spawn_argv = (char **)malloc(i * sizeof(char *));
+    /* Alloc block with room for arguments plus a terminator */
+    spawn_argv = (char **)malloc((argc + 1) * sizeof(char *));
 
     if (spawn_argv == NULL) {
 	/* failed to malloc required space; can not continue */
@@ -536,7 +511,7 @@ BosserverRun(DWORD argc,
 		/* exit event signaled; see function comment for outcomes */
 		BosserverDoExitEvent(cpid,
 				     &doWait,
-				     &doRestart, spawn_argv,
+				     &doRestart,
 				     stopStatus, isWin32Code);
 
 	    } else {
diff --git a/src/afs/AIX/osi_file.c b/src/afs/AIX/osi_file.c
index 37df330..7ecaaf2 100644
--- a/src/afs/AIX/osi_file.c
+++ b/src/afs/AIX/osi_file.c
@@ -164,7 +164,7 @@ afs_osi_Read(struct osi_file *afile, int offset, void *aptr,
 	if (!afs_shuttingdown)
 	    osi_Panic("osi_Read called with null param");
 	else
-	    return EIO;
+	    return -EIO;
     }
 
     if (offset != -1)
@@ -198,7 +198,9 @@ afs_osi_Read(struct osi_file *afile, int offset, void *aptr,
 	    goto retry_IO;
 	}
 	setuerror(code);
-	code = -1;
+	if (code > 0) {
+	    code *= -1;
+	}
     }
     return code;
 }
@@ -241,7 +243,9 @@ afs_osi_Write(struct osi_file *afile, afs_int32 offset, void *aptr,
 	    afs_warnuser
 		("\n\n\n*** Cache partition is FULL - Decrease cachesize!!! ***\n\n");
 	setuerror(code);
-	code = -1;
+	if (code > 0) {
+	    code *= -1;
+	}
     }
     if (afile->proc) {
 	(*afile->proc) (afile, code);
diff --git a/src/afs/AIX/osi_vcache.c b/src/afs/AIX/osi_vcache.c
index debb1c8..b61d466 100644
--- a/src/afs/AIX/osi_vcache.c
+++ b/src/afs/AIX/osi_vcache.c
@@ -31,7 +31,8 @@ struct vcache *
 osi_NewVnode(void) {
     struct vcache *tvc;
 
-    tvc = (struct vcache *)afs_osi_Alloc(sizeof(struct vcache));
+    tvc = afs_osi_Alloc(sizeof(struct vcache));
+    osi_Assert(tvc != NULL);
 
 #ifdef	KERNEL_HAVE_PIN
     pin((char *)tvc, sizeof(struct vcache));	/* XXX */
diff --git a/src/afs/DARWIN/osi_file.c b/src/afs/DARWIN/osi_file.c
index 4012ff7..bc271f0 100644
--- a/src/afs/DARWIN/osi_file.c
+++ b/src/afs/DARWIN/osi_file.c
@@ -321,7 +321,7 @@ afs_osi_Read(struct osi_file *afile, int offset, void *aptr,
 	if (!afs_shuttingdown)
 	    osi_Panic("osi_Read called with null param");
 	else
-	    return EIO;
+	    return -EIO;
     }
 
     if (offset != -1)
@@ -346,7 +346,9 @@ afs_osi_Read(struct osi_file *afile, int offset, void *aptr,
     } else {
 	afs_Trace2(afs_iclSetp, CM_TRACE_READFAILED, ICL_TYPE_INT32, resid,
 		   ICL_TYPE_INT32, code);
-	code = -1;
+	if (code > 0) {
+	    code *= -1;
+	}
     }
     return code;
 }
@@ -387,7 +389,9 @@ afs_osi_Write(struct osi_file *afile, afs_int32 offset, void *aptr,
 	code = asize - resid;
 	afile->offset += code;
     } else {
-	code = -1;
+	if (code > 0) {
+	    code *= -1;
+	}
     }
     if (afile->proc) {
 	(*afile->proc) (afile, code);
diff --git a/src/afs/DARWIN/osi_module.c b/src/afs/DARWIN/osi_module.c
index 020518b..f254ccf 100644
--- a/src/afs/DARWIN/osi_module.c
+++ b/src/afs/DARWIN/osi_module.c
@@ -115,6 +115,8 @@ afs_modunload(struct kmod_info * kmod_info, void *data)
 {
     if (afs_globalVFS)
 	return KERN_FAILURE;
+    if ((afs_initState != 0) || (afs_shuttingdown))
+	return KERN_FAILURE;
 #ifdef AFS_DARWIN80_ENV
     if (vfs_fsremove(afs_vfstable))
 	return KERN_FAILURE;
diff --git a/src/afs/DARWIN/osi_vcache.c b/src/afs/DARWIN/osi_vcache.c
index ee4b28e..18d8d9a 100644
--- a/src/afs/DARWIN/osi_vcache.c
+++ b/src/afs/DARWIN/osi_vcache.c
@@ -17,7 +17,8 @@ struct vcache *
 osi_NewVnode(void) {
     struct vcache *tvc;
 
-    tvc = (struct vcache *)afs_osi_Alloc(sizeof(struct vcache));
+    tvc = afs_osi_Alloc(sizeof(struct vcache));
+    osi_Assert(tvc != NULL);
     tvc->v = NULL; /* important to clean this, or use memset 0 */
 
     return tvc;
diff --git a/src/afs/FBSD/osi_file.c b/src/afs/FBSD/osi_file.c
index 02fe253..7c695d6 100644
--- a/src/afs/FBSD/osi_file.c
+++ b/src/afs/FBSD/osi_file.c
@@ -170,7 +170,7 @@ afs_osi_Read(struct osi_file *afile, int offset, void *aptr,
 	if (!afs_shuttingdown)
 	    osi_Panic("osi_Read called with null param");
 	else
-	    return EIO;
+	    return -EIO;
     }
 
     if (offset != -1)
@@ -187,7 +187,9 @@ afs_osi_Read(struct osi_file *afile, int offset, void *aptr,
     } else {
 	afs_Trace2(afs_iclSetp, CM_TRACE_READFAILED, ICL_TYPE_INT32, resid,
 		   ICL_TYPE_INT32, code);
-	code = -1;
+	if (code > 0) {
+	    code *= -1;
+	}
     }
     return code;
 }
@@ -216,7 +218,9 @@ afs_osi_Write(struct osi_file *afile, afs_int32 offset, void *aptr,
 	code = asize - resid;
 	afile->offset += code;
     } else {
-	code = -1;
+	if (code > 0) {
+	    code *= -1;
+	}
     }
     if (afile->proc) {
 	(*afile->proc) (afile, code);
diff --git a/src/afs/FBSD/osi_misc.c b/src/afs/FBSD/osi_misc.c
index 2ece43d..5fdd461 100644
--- a/src/afs/FBSD/osi_misc.c
+++ b/src/afs/FBSD/osi_misc.c
@@ -31,13 +31,15 @@ osi_lookupname(char *aname, enum uio_seg seg, int followlink,
     if (glocked)
 	AFS_GUNLOCK();
 
-    flags = 0;
+#if __FreeBSD_version >= 1000021 /* MPSAFE is gone for good! */
     flags = LOCKLEAF;
+#else
+    flags = LOCKLEAF | MPSAFE; /* namei must take Giant if needed */
+#endif
     if (followlink)
 	flags |= FOLLOW;
     else
 	flags |= NOFOLLOW;
-    flags |= MPSAFE; /* namei must take Giant if needed */
     NDINIT(&n, LOOKUP, flags, seg, aname, curthread);
     if ((error = namei(&n)) != 0) {
 	if (glocked)
diff --git a/src/afs/FBSD/osi_vfsops.c b/src/afs/FBSD/osi_vfsops.c
index b300ff4..3311e94 100644
--- a/src/afs/FBSD/osi_vfsops.c
+++ b/src/afs/FBSD/osi_vfsops.c
@@ -135,7 +135,9 @@ afs_omount(struct mount *mp, char *path, caddr_t data, struct nameidata *ndp,
 #if defined(AFS_FBSD61_ENV) && !defined(AFS_FBSD62_ENV)
     MNT_ILOCK(mp);
 #endif
+#if __FreeBSD_version < 1000021
     mp->mnt_kern_flag |= MNTK_MPSAFE; /* solid steel */
+#endif
 #ifndef AFS_FBSD61_ENV
     MNT_ILOCK(mp);
 #endif
diff --git a/src/afs/FBSD/osi_vnodeops.c b/src/afs/FBSD/osi_vnodeops.c
index 11d8cfe..01498fa 100644
--- a/src/afs/FBSD/osi_vnodeops.c
+++ b/src/afs/FBSD/osi_vnodeops.c
@@ -501,7 +501,9 @@ afs_vop_lookup(ap)
     lockparent = flags & LOCKPARENT;
     wantparent = flags & (LOCKPARENT | WANTPARENT);
 
+#if __FreeBSD_version < 1000021
     cnp->cn_flags |= MPSAFE; /* steel */
+#endif
 
     if (flags & ISDOTDOT)
 	MA_VOP_UNLOCK(dvp, 0, p);
diff --git a/src/afs/HPUX/osi_file.c b/src/afs/HPUX/osi_file.c
index 1bba21f..59c2594 100644
--- a/src/afs/HPUX/osi_file.c
+++ b/src/afs/HPUX/osi_file.c
@@ -150,7 +150,7 @@ afs_osi_Read(struct osi_file *afile, int offset, void *aptr,
 	if (!afs_shuttingdown)
 	    osi_Panic("osi_Read called with null param");
 	else
-	    return EIO;
+	    return -EIO;
     }
 
     if (offset != -1)
@@ -177,7 +177,9 @@ afs_osi_Read(struct osi_file *afile, int offset, void *aptr,
 	    goto retry_IO;
 	}
 	setuerror(code);
-	code = -1;
+	if (code > 0) {
+	    code *= -1;
+	}
     }
     return code;
 }
@@ -208,7 +210,9 @@ afs_osi_Write(struct osi_file *afile, afs_int32 offset, void *aptr,
 	    afs_warnuser
 		("\n\n\n*** Cache partition is FULL - Decrease cachesize!!! ***\n\n");
 	setuerror(code);
-	code = -1;
+	if (code > 0) {
+	    code *= -1;
+	}
     }
     if (afile->proc) {
 	(*afile->proc) (afile, code);
diff --git a/src/afs/IRIX/osi_file.c b/src/afs/IRIX/osi_file.c
index 1800d75..8698493 100644
--- a/src/afs/IRIX/osi_file.c
+++ b/src/afs/IRIX/osi_file.c
@@ -144,7 +144,7 @@ afs_osi_Read(struct osi_file *afile, int offset, void *aptr,
 	if (!afs_shuttingdown)
 	    osi_Panic("osi_Read called with null param");
 	else
-	    return EIO;
+	    return -EIO;
     }
 
     if (offset != -1)
@@ -160,7 +160,9 @@ afs_osi_Read(struct osi_file *afile, int offset, void *aptr,
     } else {
 	afs_Trace2(afs_iclSetp, CM_TRACE_READFAILED, ICL_TYPE_INT32, resid,
 		   ICL_TYPE_INT32, code);
-	code = -1;
+	if (code > 0) {
+	    code *= -1;
+	}
     }
     return code;
 }
@@ -191,7 +193,9 @@ afs_osi_Write(struct osi_file *afile, afs_int32 offset, void *aptr,
 	if (code == ENOSPC)
 	    afs_warnuser
 		("\n\n\n*** Cache partition is FULL - Decrease cachesize!!! ***\n\n");
-	code = -1;
+	if (code > 0) {
+	    code *= -1;
+	}
     }
     if (afile->proc) {
 	(*afile->proc) (afile, code);
diff --git a/src/afs/LINUX/osi_compat.h b/src/afs/LINUX/osi_compat.h
index b94295c..c6d9002 100644
--- a/src/afs/LINUX/osi_compat.h
+++ b/src/afs/LINUX/osi_compat.h
@@ -333,7 +333,11 @@ afs_get_dentry_from_fh(struct super_block *afs_cacheSBp, afs_dcache_id_t *ainode
 static inline int
 afs_get_fh_from_dentry(struct dentry *dp, afs_ufs_dcache_id_t *ainode, int *max_lenp) {
     if (dp->d_sb->s_export_op->encode_fh)
+#if defined(EXPORT_OP_ENCODE_FH_TAKES_INODES)
+        return dp->d_sb->s_export_op->encode_fh(dp->d_inode, &ainode->raw[0], max_lenp, NULL);
+#else
         return dp->d_sb->s_export_op->encode_fh(dp, &ainode->raw[0], max_lenp, 0);
+#endif
 #if defined(NEW_EXPORT_OPS)
     /* If fs doesn't provide an encode_fh method, assume the default INO32 type */
     *max_lenp = sizeof(struct fid)/4;
@@ -441,4 +445,56 @@ afs_get_dentry_ref(struct path *path, struct vfsmount **mnt, struct dentry **dpp
 #endif
 }
 
+#if defined(STRUCT_TASK_STRUCT_HAS_CRED)
+static inline struct file *
+afs_dentry_open(struct dentry *dp, struct vfsmount *mnt, int flags, const struct cred *creds) {
+#if defined(DENTRY_OPEN_TAKES_PATH)
+    struct path path;
+    struct file *filp;
+    path.mnt = mnt;
+    path.dentry = dp;
+    filp = dentry_open(&path, flags, creds);
+    return filp;
+#else
+    return dentry_open(dp, mntget(mnt), flags, creds);
+#endif
+}
+#endif
+
+#if defined(HAVE_LINUX_PUTNAME)
+typedef char *afs_name_t;
+
+static inline char *
+afs_name_to_string(afs_name_t s) {
+    return (char *)s;
+}
+
+static inline void
+afs_putname(afs_name_t name) {
+    putname((char *)name);
+}
+
+static inline void
+afs_set_name(afs_name_t name, char *string) {
+    name = string;
+}
+#else
+typedef struct filename *afs_name_t;
+
+static inline char *
+afs_name_to_string(afs_name_t s) {
+    return (char *)s->name;
+}
+
+static inline void
+afs_putname(afs_name_t name) {
+    kmem_cache_free(names_cachep, (void *)name);
+}
+
+static inline void
+afs_set_name(afs_name_t aname, char *string) {
+    aname->name = string;
+}
+#endif
+
 #endif /* AFS_LINUX_OSI_COMPAT_H */
diff --git a/src/afs/LINUX/osi_file.c b/src/afs/LINUX/osi_file.c
index 3c20fd9..01cc42f 100644
--- a/src/afs/LINUX/osi_file.c
+++ b/src/afs/LINUX/osi_file.c
@@ -56,9 +56,9 @@ afs_linux_raw_open(afs_dcache_id_t *ainode)
 
 #if defined(STRUCT_TASK_STRUCT_HAS_CRED)
     /* Use stashed credentials - prevent selinux/apparmor problems  */
-    filp = dentry_open(dp, mntget(afs_cacheMnt), O_RDWR, cache_creds);
+    filp = afs_dentry_open(dp, mntget(afs_cacheMnt), O_RDWR, cache_creds);
     if (IS_ERR(filp))
-	filp = dentry_open(dp, mntget(afs_cacheMnt), O_RDWR, current_cred());
+	filp = afs_dentry_open(dp, mntget(afs_cacheMnt), O_RDWR, current_cred());
 #else
     filp = dentry_open(dp, mntget(afs_cacheMnt), O_RDWR);
 #endif
@@ -216,7 +216,7 @@ afs_osi_Read(struct osi_file *afile, int offset, void *aptr,
 	if (!afs_shuttingdown)
 	    osi_Panic("osi_Read called with null param");
 	else
-	    return EIO;
+	    return -EIO;
     }
 
     if (offset != -1)
@@ -231,7 +231,9 @@ afs_osi_Read(struct osi_file *afile, int offset, void *aptr,
     } else {
 	afs_Trace2(afs_iclSetp, CM_TRACE_READFAILED, ICL_TYPE_INT32, auio.uio_resid,
 		   ICL_TYPE_INT32, code);
-	code = -1;
+	if (code > 0) {
+	    code *= -1;
+	}
     }
     return code;
 }
@@ -251,7 +253,7 @@ afs_osi_Write(struct osi_file *afile, afs_int32 offset, void *aptr,
 	if (!afs_shuttingdown)
 	    osi_Panic("afs_osi_Write called with null param");
 	else
-	    return EIO;
+	    return -EIO;
     }
 
     if (offset != -1)
@@ -267,7 +269,9 @@ afs_osi_Write(struct osi_file *afile, afs_int32 offset, void *aptr,
 	if (code == ENOSPC)
 	    afs_warnuser
 		("\n\n\n*** Cache partition is FULL - Decrease cachesize!!! ***\n\n");
-	code = -1;
+	if (code > 0) {
+	    code *= -1;
+	}
     }
 
     if (afile->proc)
diff --git a/src/afs/LINUX/osi_misc.c b/src/afs/LINUX/osi_misc.c
index fb740db..6ae6c1b 100644
--- a/src/afs/LINUX/osi_misc.c
+++ b/src/afs/LINUX/osi_misc.c
@@ -78,22 +78,25 @@ osi_lookupname_internal(char *aname, int followlink, struct vfsmount **mnt,
 }
 
 int
-osi_lookupname(char *aname, uio_seg_t seg, int followlink, 
+osi_lookupname(char *aname, uio_seg_t seg, int followlink,
 	       struct dentry **dpp)
 {
     int code;
-    char *tname;
+    afs_name_t tname = NULL;
+    char *name;
+
     code = ENOENT;
     if (seg == AFS_UIOUSER) {
-        tname = getname(aname);
-        if (IS_ERR(tname)) 
-            return PTR_ERR(tname);
+	tname = getname(aname);
+	if (IS_ERR(tname))
+	    return PTR_ERR(tname);
+	name = afs_name_to_string(tname);
     } else {
-        tname = aname;
+	name = aname;
     }
-    code = osi_lookupname_internal(tname, followlink, NULL, dpp);   
+    code = osi_lookupname_internal(name, followlink, NULL, dpp);
     if (seg == AFS_UIOUSER) {
-        putname(tname);
+	afs_putname(tname);
     }
     return code;
 }
@@ -103,14 +106,15 @@ int osi_abspath(char *aname, char *buf, int buflen,
 {
     struct dentry *dp = NULL;
     struct vfsmount *mnt = NULL;
-    char *tname, *path;
+    afs_name_t tname;
+    char *path;
     int code;
 
     code = ENOENT;
     tname = getname(aname);
-    if (IS_ERR(tname)) 
+    if (IS_ERR(tname))
 	return -PTR_ERR(tname);
-    code = osi_lookupname_internal(tname, followlink, &mnt, &dp);   
+    code = osi_lookupname_internal(afs_name_to_string(tname), followlink, &mnt, &dp);
     if (!code) {
 #if defined(D_PATH_TAKES_STRUCT_PATH)
 	struct path p = { mnt, dp };
@@ -129,7 +133,7 @@ int osi_abspath(char *aname, char *buf, int buflen,
 	mntput(mnt);
     }
 
-    putname(tname);
+    afs_putname(tname);
     return code;
 }
 
diff --git a/src/afs/LINUX/osi_nfssrv.c b/src/afs/LINUX/osi_nfssrv.c
index cde4b9b..425ecd3 100644
--- a/src/afs/LINUX/osi_nfssrv.c
+++ b/src/afs/LINUX/osi_nfssrv.c
@@ -223,6 +223,7 @@ void osi_linux_nfssrv_init(void)
 	}
 
 	afs_new_authtab[i] = afs_osi_Alloc(sizeof(struct auth_ops));
+	osi_Assert(afs_new_authtab[i] != NULL);
 	*(afs_new_authtab[i]) = *(afs_orig_authtab[i]);
 	afs_new_authtab[i]->owner = THIS_MODULE;
 	afs_new_authtab[i]->accept = svcauth_afs_accept;
diff --git a/src/afs/LINUX/osi_proc.c b/src/afs/LINUX/osi_proc.c
index b4b5c9e..3f687f3 100644
--- a/src/afs/LINUX/osi_proc.c
+++ b/src/afs/LINUX/osi_proc.c
@@ -17,7 +17,7 @@
 
 #include <linux/module.h> /* early to avoid printf->printk mapping */
 #ifdef HAVE_LINUX_SEQ_FILE_H
-#include <linux/seq_file.h>
+# include <linux/seq_file.h>
 #endif
 #include "afs/sysincludes.h"
 #include "afsincludes.h"
@@ -26,7 +26,7 @@
 #include <linux/mm.h>
 
 #ifdef AFS_AMD64_LINUX20_ENV
-#include <asm/ia32_unistd.h>
+# include <asm/ia32_unistd.h>
 #endif
 
 #include <linux/proc_fs.h>
@@ -38,115 +38,129 @@
 struct proc_dir_entry *openafs_procfs;
 
 #ifdef HAVE_LINUX_SEQ_FILE_H
-static void *c_start(struct seq_file *m, loff_t *pos)
+static void *
+c_start(struct seq_file *m, loff_t *pos)
 {
-	struct afs_q *cq, *tq;
-	loff_t n = 0;
+    struct afs_q *cq, *tq;
+    loff_t n = 0;
 
-	AFS_GLOCK();
-	ObtainReadLock(&afs_xcell);
-	for (cq = CellLRU.next; cq != &CellLRU; cq = tq) {
-		tq = QNext(cq);
+    AFS_GLOCK();
+    ObtainReadLock(&afs_xcell);
+    for (cq = CellLRU.next; cq != &CellLRU; cq = tq) {
+	tq = QNext(cq);
 
-		if (n++ == *pos)
-			break;
-	}
-	if (cq == &CellLRU)
-		cq = NULL;
+	if (n++ == *pos)
+	    break;
+    }
+    if (cq == &CellLRU)
+	cq = NULL;
 
-	AFS_GUNLOCK();
-	return cq;
+    AFS_GUNLOCK();
+    return cq;
 }
 
-static void *c_next(struct seq_file *m, void *p, loff_t *pos)
+static void *
+c_next(struct seq_file *m, void *p, loff_t *pos)
 {
-	struct afs_q *cq = p, *tq;
+    struct afs_q *cq = p, *tq;
 
-	AFS_GLOCK();
-	(*pos)++;
-	tq = QNext(cq);
+    AFS_GLOCK();
+    (*pos)++;
+    tq = QNext(cq);
 
-	if (tq == &CellLRU)
-		tq = NULL;
+    if (tq == &CellLRU)
+	tq = NULL;
 
-	AFS_GUNLOCK();
-	return tq;
+    AFS_GUNLOCK();
+    return tq;
 }
 
-static void c_stop(struct seq_file *m, void *p)
+static void
+c_stop(struct seq_file *m, void *p)
 {
-        AFS_GLOCK();
-	ReleaseReadLock(&afs_xcell);
-	AFS_GUNLOCK();
+    AFS_GLOCK();
+    ReleaseReadLock(&afs_xcell);
+    AFS_GUNLOCK();
 }
 
-static int c_show(struct seq_file *m, void *p)
+static int
+c_show(struct seq_file *m, void *p)
 {
-	struct afs_q *cq = p;
-	struct cell *tc = QTOC(cq);
-	int j;
+    struct afs_q *cq = p;
+    struct cell *tc = QTOC(cq);
+    int j;
 
-	seq_printf(m, ">%s #(%d/%d)\n", tc->cellName,
-		   tc->cellNum, tc->cellIndex);
+    seq_printf(m, ">%s #(%d/%d)\n", tc->cellName,
+               tc->cellNum, tc->cellIndex);
 
-	for (j = 0; j < AFS_MAXCELLHOSTS; j++) {
-		afs_uint32 addr;
+    for (j = 0; j < AFS_MAXCELLHOSTS; j++) {
+	afs_uint32 addr;
 
-		if (!tc->cellHosts[j]) break;
+	if (!tc->cellHosts[j]) break;
 
-		addr = tc->cellHosts[j]->addr->sa_ip;
+	addr = tc->cellHosts[j]->addr->sa_ip;
 #if defined(NIPQUAD)
-		seq_printf(m, "%u.%u.%u.%u #%u.%u.%u.%u\n",
-			   NIPQUAD(addr), NIPQUAD(addr));
+	seq_printf(m, "%u.%u.%u.%u #%u.%u.%u.%u\n",
+	           NIPQUAD(addr), NIPQUAD(addr));
 #else
-		seq_printf(m, "%pI4 #%pI4\n", &addr, &addr);
+	seq_printf(m, "%pI4 #%pI4\n", &addr, &addr);
 #endif
-	}
+    }
 
 	return 0;
 }
 
 static struct seq_operations afs_csdb_op = {
-	.start		= c_start,
-	.next		= c_next,
-	.stop		= c_stop,
-	.show		= c_show,
+    .start = c_start,
+    .next  = c_next,
+    .stop  = c_stop,
+    .show  = c_show,
 };
 
-static int afs_csdb_open(struct inode *inode, struct file *file)
+static int
+afs_csdb_open(struct inode *inode, struct file *file)
 {
-	return seq_open(file, &afs_csdb_op);
+    return seq_open(file, &afs_csdb_op);
 }
 
 static struct file_operations afs_csdb_operations = {
-	.open		= afs_csdb_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= seq_release,
+    .open    = afs_csdb_open,
+    .read    = seq_read,
+    .llseek  = seq_lseek,
+    .release = seq_release,
 };
 
-
-static void *uu_start(struct seq_file *m, loff_t *pos)
+static void *
+uu_start(struct seq_file *m, loff_t *pos)
 {
     struct unixuser *tu;
+    void *ret;
     loff_t n = 0;
     afs_int32 i;
 
-    ObtainReadLock(&afs_xuser);
     if (!*pos)
 	return (void *)(1);
 
+    AFS_GLOCK();
+    ObtainReadLock(&afs_xuser);
+
+    ret = NULL;
+
     for (i = 0; i < NUSERS; i++) {
 	for (tu = afs_users[i]; tu; tu = tu->next) {
 	    if (++n == *pos)
-		return tu;
+		ret = tu;
+		goto done;
 	}
     }
 
-    return NULL;
+ done:
+    AFS_GUNLOCK();
+    return ret;
 }
 
-static void *uu_next(struct seq_file *m, void *p, loff_t *pos)
+static void *
+uu_next(struct seq_file *m, void *p, loff_t *pos)
 {
     struct unixuser *tu = p;
     afs_int32 i = 0;
@@ -164,12 +178,16 @@ static void *uu_next(struct seq_file *m, void *p, loff_t *pos)
     return NULL;
 }
 
-static void uu_stop(struct seq_file *m, void *p)
+static void
+uu_stop(struct seq_file *m, void *p)
 {
+    AFS_GLOCK();
     ReleaseReadLock(&afs_xuser);
+    AFS_GUNLOCK();
 }
 
-static int uu_show(struct seq_file *m, void *p)
+static int
+uu_show(struct seq_file *m, void *p)
 {
     struct cell *tc = 0;
     struct unixuser *tu = p;
@@ -186,6 +204,8 @@ static int uu_show(struct seq_file *m, void *p)
 	return 0;
     }
 
+    AFS_GLOCK();
+
     if (tu->cell == -1) {
 	cellname = "<default>";
     } else {
@@ -230,34 +250,36 @@ static int uu_show(struct seq_file *m, void *p)
     }
     seq_printf(m, "\n");
 
+    AFS_GUNLOCK();
+
     return 0;
 }
 
 static struct seq_operations afs_unixuser_seqop = {
-    .start		= uu_start,
-    .next		= uu_next,
-    .stop		= uu_stop,
-    .show		= uu_show,
+    .start = uu_start,
+    .next  = uu_next,
+    .stop  = uu_stop,
+    .show  = uu_show,
 };
 
-static int afs_unixuser_open(struct inode *inode, struct file *file)
+static int
+afs_unixuser_open(struct inode *inode, struct file *file)
 {
     return seq_open(file, &afs_unixuser_seqop);
 }
 
 static struct file_operations afs_unixuser_fops = {
-    .open		= afs_unixuser_open,
-    .read		= seq_read,
-    .llseek		= seq_lseek,
-    .release	= seq_release,
+    .open    = afs_unixuser_open,
+    .read    = seq_read,
+    .llseek  = seq_lseek,
+    .release = seq_release,
 };
 
 
 #else /* HAVE_LINUX_SEQ_FILE_H */
 
 static int
-csdbproc_info(char *buffer, char **start, off_t offset, int
-length)
+csdbproc_info(char *buffer, char **start, off_t offset, int length)
 {
     int len = 0;
     off_t pos = 0;
@@ -269,6 +291,8 @@ length)
        decor */
     char temp[91];
     afs_uint32 addr;
+
+    AFS_GLOCK();
     
     ObtainReadLock(&afs_xcell);
 
@@ -315,6 +339,8 @@ length)
     ReleaseReadLock(&afs_xcell);
     
 done:
+    AFS_GUNLOCK();
+
     *start = buffer + len - (pos - offset);
     len = pos - offset;
     if (len > length)
@@ -342,9 +368,9 @@ osi_proc_init(void)
     entry = create_proc_entry("unixusers", 0, openafs_procfs);
     if (entry) {
 	entry->proc_fops = &afs_unixuser_fops;
-#if defined(STRUCT_PROC_DIR_ENTRY_HAS_OWNER)
+# if defined(STRUCT_PROC_DIR_ENTRY_HAS_OWNER)
 	entry->owner = THIS_MODULE;
-#endif
+# endif
     }
     entry = create_proc_entry(PROC_CELLSERVDB_NAME, 0, openafs_procfs);
     if (entry)
diff --git a/src/afs/LINUX/osi_vcache.c b/src/afs/LINUX/osi_vcache.c
index e82d78e..dc3685b 100644
--- a/src/afs/LINUX/osi_vcache.c
+++ b/src/afs/LINUX/osi_vcache.c
@@ -19,7 +19,11 @@ osi_TryEvictVCache(struct vcache *avc, int *slept, int defersleep) {
 
     struct dentry *dentry;
     struct inode *inode = AFSTOV(avc);
-    struct list_head *cur, *head;
+#if defined(D_ALIAS_IS_HLIST)
+    struct hlist_node *cur, *head, *list_end;
+#else
+    struct list_head *cur, *head, *list_end;
+#endif
 
     /* First, see if we can evict the inode from the dcache */
     if (defersleep && avc != afs_globalVp && VREFCOUNT(avc) > 1 && avc->opens == 0) {
@@ -53,12 +57,22 @@ restart:
 	spin_unlock(&dcache_lock);
 #else /* HAVE_DCACHE_LOCK */
 	spin_lock(&inode->i_lock);
+#if defined(D_ALIAS_IS_HLIST)
+	head = inode->i_dentry.first;
+	list_end = NULL;
+#else
 	head = &inode->i_dentry;
+	list_end = head;
+#endif
 
 restart:
 	cur = head;
-	while ((cur = cur->next) != head) {
+	while ((cur = cur->next) != list_end) {
+#if defined(D_ALIAS_IS_HLIST)
+	    dentry = hlist_entry(cur, struct dentry, d_alias);
+#else
 	    dentry = list_entry(cur, struct dentry, d_alias);
+#endif
 
 	    spin_lock(&dentry->d_lock);
 	    if (d_unhashed(dentry)) {
diff --git a/src/afs/LINUX/osi_vfsops.c b/src/afs/LINUX/osi_vfsops.c
index a6be1b3..bc951a2 100644
--- a/src/afs/LINUX/osi_vfsops.c
+++ b/src/afs/LINUX/osi_vfsops.c
@@ -284,7 +284,11 @@ afs_evict_inode(struct inode *ip)
 	osi_Panic("inode freed while still hashed");
 
     truncate_inode_pages(&ip->i_data, 0);
+#if defined(HAVE_LINUX_CLEAR_INODE)
+    clear_inode(ip);
+#else
     end_writeback(ip);
+#endif
 
 #if !defined(STRUCT_SUPER_OPERATIONS_HAS_ALLOC_INODE)
     afs_osi_Free(ip->u.generic_ip, sizeof(struct vcache));
diff --git a/src/afs/LINUX/osi_vnodeops.c b/src/afs/LINUX/osi_vnodeops.c
index 4cda547..1028908 100644
--- a/src/afs/LINUX/osi_vnodeops.c
+++ b/src/afs/LINUX/osi_vnodeops.c
@@ -272,7 +272,8 @@ afs_linux_readdir(struct file *fp, void *dirbuf, filldir_t filldir)
 	    goto out;
         }
 
-	ino = afs_calc_inum (avc->f.fid.Fid.Volume, ntohl(de->fid.vnode));
+	ino = afs_calc_inum(avc->f.fid.Cell, avc->f.fid.Fid.Volume,
+	                    ntohl(de->fid.vnode));
 	len = strlen(de->name);
 
 	/* filldir returns -EINVAL when the buffer is full. */
@@ -695,6 +696,68 @@ struct file_operations afs_file_fops = {
   .llseek = 	default_llseek,
 };
 
+static struct dentry *
+canonical_dentry(struct inode *ip)
+{
+    struct vcache *vcp = VTOAFS(ip);
+    struct dentry *first = NULL, *ret = NULL, *cur;
+#if defined(D_ALIAS_IS_HLIST)
+    struct hlist_node *p;
+#endif
+
+    /* general strategy:
+     * if vcp->target_link is set, and can be found in ip->i_dentry, use that.
+     * otherwise, use the first dentry in ip->i_dentry.
+     * if ip->i_dentry is empty, use the 'dentry' argument we were given.
+     */
+    /* note that vcp->target_link specifies which dentry to use, but we have
+     * no reference held on that dentry. so, we cannot use or dereference
+     * vcp->target_link itself, since it may have been freed. instead, we only
+     * use it to compare to pointers in the ip->i_dentry list. */
+
+    d_prune_aliases(ip);
+
+# ifdef HAVE_DCACHE_LOCK
+    spin_lock(&dcache_lock);
+# else
+    spin_lock(&ip->i_lock);
+# endif
+
+#if defined(D_ALIAS_IS_HLIST)
+    hlist_for_each_entry(cur, p, &ip->i_dentry, d_alias) {
+#else
+    list_for_each_entry_reverse(cur, &ip->i_dentry, d_alias) {
+#endif
+
+	if (!vcp->target_link || cur == vcp->target_link) {
+	    ret = cur;
+	    break;
+	}
+
+	if (!first) {
+	    first = cur;
+	}
+    }
+    if (!ret && first) {
+	ret = first;
+    }
+
+    vcp->target_link = ret;
+
+# ifdef HAVE_DCACHE_LOCK
+    if (ret) {
+	dget_locked(ret);
+    }
+    spin_unlock(&dcache_lock);
+# else
+    if (ret) {
+	dget(ret);
+    }
+    spin_unlock(&ip->i_lock);
+# endif
+
+    return ret;
+}
 
 /**********************************************************************
  * AFS Linux dentry operations
@@ -906,7 +969,9 @@ afs_linux_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *sta
  * later on, we shouldn't have to do it until later. Perhaps in the future..
  */
 static int
-#ifdef DOP_REVALIDATE_TAKES_NAMEIDATA
+#if defined(DOP_REVALIDATE_TAKES_UNSIGNED)
+afs_linux_dentry_revalidate(struct dentry *dp, unsigned int flags)
+#elif defined(DOP_REVALIDATE_TAKES_NAMEIDATA)
 afs_linux_dentry_revalidate(struct dentry *dp, struct nameidata *nd)
 #else
 afs_linux_dentry_revalidate(struct dentry *dp, int flags)
@@ -921,7 +986,11 @@ afs_linux_dentry_revalidate(struct dentry *dp, int flags)
 
 #ifdef LOOKUP_RCU
     /* We don't support RCU path walking */
+# if defined(DOP_REVALIDATE_TAKES_UNSIGNED)
+    if (flags & LOOKUP_RCU)
+# else
     if (nd->flags & LOOKUP_RCU)
+# endif
        return -ECHILD;
 #endif
     AFS_GLOCK();
@@ -1075,10 +1144,44 @@ afs_dentry_delete(struct dentry *dp)
     return 0;
 }
 
+#ifdef STRUCT_DENTRY_OPERATIONS_HAS_D_AUTOMOUNT
+static struct vfsmount *
+afs_dentry_automount(struct path *path)
+{
+    struct dentry *target;
+
+    /* avoid symlink resolution limits when resolving; we cannot contribute to
+     * an infinite symlink loop */
+    current->total_link_count--;
+
+    target = canonical_dentry(path->dentry->d_inode);
+
+    if (target == path->dentry) {
+	dput(target);
+	target = NULL;
+    }
+
+    if (target) {
+	dput(path->dentry);
+	path->dentry = target;
+
+    } else {
+	spin_lock(&path->dentry->d_lock);
+	path->dentry->d_flags &= ~DCACHE_NEED_AUTOMOUNT;
+	spin_unlock(&path->dentry->d_lock);
+    }
+
+    return NULL;
+}
+#endif /* STRUCT_DENTRY_OPERATIONS_HAS_D_AUTOMOUNT */
+
 struct dentry_operations afs_dentry_operations = {
   .d_revalidate =	afs_linux_dentry_revalidate,
   .d_delete =		afs_dentry_delete,
   .d_iput =		afs_dentry_iput,
+#ifdef STRUCT_DENTRY_OPERATIONS_HAS_D_AUTOMOUNT
+  .d_automount =        afs_dentry_automount,
+#endif /* STRUCT_DENTRY_OPERATIONS_HAS_D_AUTOMOUNT */
 };
 
 /**********************************************************************
@@ -1094,17 +1197,18 @@ struct dentry_operations afs_dentry_operations = {
  * name is in kernel space at this point.
  */
 static int
-#if defined(IOP_MKDIR_TAKES_UMODE_T)
+#if defined(IOP_CREATE_TAKES_BOOL)
+afs_linux_create(struct inode *dip, struct dentry *dp, umode_t mode,
+		 bool excl)
+#elif defined(IOP_CREATE_TAKES_UMODE_T)
 afs_linux_create(struct inode *dip, struct dentry *dp, umode_t mode,
 		 struct nameidata *nd)
-#else
-#ifdef IOP_CREATE_TAKES_NAMEIDATA
+#elif defined(IOP_CREATE_TAKES_NAMEIDATA)
 afs_linux_create(struct inode *dip, struct dentry *dp, int mode,
 		 struct nameidata *nd)
 #else
 afs_linux_create(struct inode *dip, struct dentry *dp, int mode)
 #endif
-#endif
 {
     struct vattr vattr;
     cred_t *credp = crref();
@@ -1140,7 +1244,10 @@ afs_linux_create(struct inode *dip, struct dentry *dp, int mode)
 
 /* afs_linux_lookup */
 static struct dentry *
-#ifdef IOP_LOOKUP_TAKES_NAMEIDATA
+#if defined(IOP_LOOKUP_TAKES_UNSIGNED)
+afs_linux_lookup(struct inode *dip, struct dentry *dp,
+		 unsigned flags)
+#elif defined(IOP_LOOKUP_TAKES_NAMEIDATA)
 afs_linux_lookup(struct inode *dip, struct dentry *dp,
 		 struct nameidata *nd)
 #else
@@ -1159,6 +1266,18 @@ afs_linux_lookup(struct inode *dip, struct dentry *dp)
     
     if (vcp) {
 	struct vattr vattr;
+	struct vcache *parent_vc = VTOAFS(dip);
+
+	if (parent_vc == vcp) {
+	    /* This is possible if the parent dir is a mountpoint to a volume,
+	     * and the dir entry we looked up is a mountpoint to the same
+	     * volume. Linux cannot cope with this, so return an error instead
+	     * of risking a deadlock or panic. */
+	    afs_PutVCache(vcp);
+	    code = EDEADLK;
+	    AFS_GUNLOCK();
+	    goto done;
+	}
 
 	ip = AFSTOV(vcp);
 	afs_getattr(vcp, &vattr, credp);
@@ -1173,23 +1292,32 @@ afs_linux_lookup(struct inode *dip, struct dentry *dp)
     AFS_GUNLOCK();
 
     if (ip && S_ISDIR(ip->i_mode)) {
+	int retry = 1;
 	struct dentry *alias;
 
-        /* Try to invalidate an existing alias in favor of our new one */
-	alias = d_find_alias(ip);
-        /* But not if it's disconnected; then we want d_splice_alias below */
-	if (alias && !(alias->d_flags & DCACHE_DISCONNECTED)) {
-	    if (d_invalidate(alias) == 0) {
-		dput(alias);
-	    } else {
-		iput(ip);
-		crfree(credp);
-		return alias;
+	while (retry) {
+	    retry = 0;
+
+	    /* Try to invalidate an existing alias in favor of our new one */
+	    alias = d_find_alias(ip);
+	    /* But not if it's disconnected; then we want d_splice_alias below */
+	    if (alias && !(alias->d_flags & DCACHE_DISCONNECTED)) {
+		if (d_invalidate(alias) == 0) {
+		    /* there may be more aliases; try again until we run out */
+		    retry = 1;
+		}
 	    }
+
+	    dput(alias);
 	}
+
+#ifdef STRUCT_DENTRY_OPERATIONS_HAS_D_AUTOMOUNT
+	ip->i_flags |= S_AUTOMOUNT;
+#endif
     }
     newdp = d_splice_alias(ip, dp);
 
+ done:
     crfree(credp);
 
     /* It's ok for the file to not be found. That's noted by the caller by
@@ -1533,7 +1661,7 @@ afs_linux_read_cache(struct file *cachefp, struct page *page,
     struct inode *cacheinode = cachefp->f_dentry->d_inode;
     struct page *newpage, *cachepage;
     struct address_space *cachemapping;
-    int pageindex, endindex;
+    int pageindex;
     int code = 0;
 
     cachemapping = cacheinode->i_mapping;
@@ -2483,6 +2611,44 @@ afs_linux_write_begin(struct file *file, struct address_space *mapping,
 }
 #endif
 
+#ifndef STRUCT_DENTRY_OPERATIONS_HAS_D_AUTOMOUNT
+static void *
+afs_linux_dir_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+    struct dentry **dpp;
+    struct dentry *target;
+
+    if (current->total_link_count > 0) {
+	/* avoid symlink resolution limits when resolving; we cannot contribute to
+	 * an infinite symlink loop */
+	/* only do this for follow_link when total_link_count is positive to be
+	 * on the safe side; there is at least one code path in the Linux
+	 * kernel where it seems like it may be possible to get here without
+	 * total_link_count getting incremented. it is not clear on how that
+	 * path is actually reached, but guard against it just to be safe */
+	current->total_link_count--;
+    }
+
+    target = canonical_dentry(dentry->d_inode);
+
+# ifdef STRUCT_NAMEIDATA_HAS_PATH
+    dpp = &nd->path.dentry;
+# else
+    dpp = &nd->dentry;
+# endif
+
+    dput(*dpp);
+
+    if (target) {
+	*dpp = target;
+    } else {
+	*dpp = dget(dentry);
+    }
+
+    return NULL;
+}
+#endif /* !STRUCT_DENTRY_OPERATIONS_HAS_D_AUTOMOUNT */
+
 
 static struct inode_operations afs_file_iops = {
   .permission =		afs_linux_permission,
@@ -2520,6 +2686,9 @@ static struct inode_operations afs_dir_iops = {
   .rename =		afs_linux_rename,
   .getattr =		afs_linux_getattr,
   .permission =		afs_linux_permission,
+#ifndef STRUCT_DENTRY_OPERATIONS_HAS_D_AUTOMOUNT
+  .follow_link =        afs_linux_dir_follow_link,
+#endif
 };
 
 /* We really need a separate symlink set of ops, since do_follow_link()
diff --git a/src/afs/LINUX24/osi_file.c b/src/afs/LINUX24/osi_file.c
index 8751388..35bd031 100644
--- a/src/afs/LINUX24/osi_file.c
+++ b/src/afs/LINUX24/osi_file.c
@@ -200,7 +200,7 @@ afs_osi_Read(struct osi_file *afile, int offset, void *aptr,
 	if (!afs_shuttingdown)
 	    osi_Panic("osi_Read called with null param");
 	else
-	    return EIO;
+	    return -EIO;
     }
 
     if (offset != -1)
@@ -215,7 +215,9 @@ afs_osi_Read(struct osi_file *afile, int offset, void *aptr,
     } else {
 	afs_Trace2(afs_iclSetp, CM_TRACE_READFAILED, ICL_TYPE_INT32, auio.uio_resid,
 		   ICL_TYPE_INT32, code);
-	code = -1;
+	if (code > 0) {
+	    code *= -1;
+	}
     }
     return code;
 }
@@ -235,7 +237,7 @@ afs_osi_Write(struct osi_file *afile, afs_int32 offset, void *aptr,
 	if (!afs_shuttingdown)
 	    osi_Panic("afs_osi_Write called with null param");
 	else
-	    return EIO;
+	    return -EIO;
     }
 
     if (offset != -1)
@@ -251,7 +253,9 @@ afs_osi_Write(struct osi_file *afile, afs_int32 offset, void *aptr,
 	if (code == ENOSPC)
 	    afs_warnuser
 		("\n\n\n*** Cache partition is FULL - Decrease cachesize!!! ***\n\n");
-	code = -1;
+	if (code > 0) {
+	    code *= -1;
+	}
     }
 
     if (afile->proc)
diff --git a/src/afs/LINUX24/osi_vcache.c b/src/afs/LINUX24/osi_vcache.c
index c1d2340..bbaf5ce 100644
--- a/src/afs/LINUX24/osi_vcache.c
+++ b/src/afs/LINUX24/osi_vcache.c
@@ -94,6 +94,7 @@ osi_NewVnode(void)
     tvc = VTOAFS(ip);
 #else
     tvc = afs_osi_Alloc(sizeof(struct vcache));
+    osi_Assert(tvc != NULL);
     ip->u.generic_ip = tvc;
     tvc->v = ip;
 #endif
diff --git a/src/afs/LINUX24/osi_vnodeops.c b/src/afs/LINUX24/osi_vnodeops.c
index 841f453..2fd1a22 100644
--- a/src/afs/LINUX24/osi_vnodeops.c
+++ b/src/afs/LINUX24/osi_vnodeops.c
@@ -303,7 +303,8 @@ afs_linux_readdir(struct file *fp, void *dirbuf, filldir_t filldir)
 	if (!de)
 	    break;
 
-	ino = afs_calc_inum (avc->f.fid.Fid.Volume, ntohl(de->fid.vnode));
+	ino = afs_calc_inum(avc->f.fid.Cell, avc->f.fid.Fid.Volume,
+	                    ntohl(de->fid.vnode));
 
 	if (de->name)
 	    len = strlen(de->name);
@@ -780,6 +781,57 @@ struct file_operations afs_file_fops = {
 #endif
 };
 
+static struct dentry *
+canonical_dentry(struct inode *ip)
+{
+    struct vcache *vcp = VTOAFS(ip);
+    struct dentry *first = NULL, *ret = NULL, *cur;
+    struct list_head *head, *prev, *tmp;
+
+    /* general strategy:
+     * if vcp->target_link is set, and can be found in ip->i_dentry, use that.
+     * otherwise, use the first dentry in ip->i_dentry.
+     * if ip->i_dentry is empty, use the 'dentry' argument we were given.
+     */
+    /* note that vcp->target_link specifies which dentry to use, but we have
+     * no reference held on that dentry. so, we cannot use or dereference
+     * vcp->target_link itself, since it may have been freed. instead, we only
+     * use it to compare to pointers in the ip->i_dentry list. */
+
+    d_prune_aliases(ip);
+
+    spin_lock(&dcache_lock);
+
+    head = &ip->i_dentry;
+    prev = ip->i_dentry.prev;
+
+    while (prev != head) {
+	tmp = prev;
+	prev = tmp->prev;
+	cur = list_entry(tmp, struct dentry, d_alias);
+
+	if (!vcp->target_link || cur == vcp->target_link) {
+	    ret = cur;
+	    break;
+	}
+
+	if (!first) {
+	    first = cur;
+	}
+    }
+    if (!ret && first) {
+	ret = first;
+    }
+
+    vcp->target_link = ret;
+
+    if (ret) {
+	dget_locked(ret);
+    }
+    spin_unlock(&dcache_lock);
+
+    return ret;
+}
 
 /**********************************************************************
  * AFS Linux dentry operations
@@ -1219,6 +1271,18 @@ afs_linux_lookup(struct inode *dip, struct dentry *dp)
     
     if (vcp) {
 	struct vattr vattr;
+	struct vcache *parent_vc = VTOAFS(dip);
+
+	if (parent_vc == vcp) {
+	    /* This is possible if the parent dir is a mountpoint to a volume,
+	     * and the dir entry we looked up is a mountpoint to the same
+	     * volume. Linux cannot cope with this, so return an error instead
+	     * of risking a deadlock or panic. */
+	    afs_PutVCache(vcp);
+	    code = EDEADLK;
+	    AFS_GUNLOCK();
+	    goto done;
+	}
 
 	ip = AFSTOV(vcp);
 	afs_getattr(vcp, &vattr, credp);
@@ -1238,23 +1302,29 @@ afs_linux_lookup(struct inode *dip, struct dentry *dp)
 
 #if defined(AFS_LINUX24_ENV)
     if (ip && S_ISDIR(ip->i_mode)) {
+	int retry = 1;
 	struct dentry *alias;
 
-        /* Try to invalidate an existing alias in favor of our new one */
-	alias = d_find_alias(ip);
-	if (alias) {
-	    if (d_invalidate(alias) == 0) {
-		dput(alias);
-	    } else {
-		iput(ip);
-		crfree(credp);
-		return alias;
+	while (retry) {
+	    retry = 0;
+
+	    /* Try to invalidate an existing alias in favor of our new one */
+	    alias = d_find_alias(ip);
+	    /* But not if it's disconnected; then we want d_splice_alias below */
+	    if (alias) {
+		if (d_invalidate(alias) == 0) {
+		    /* there may be more aliases; try again until we run out */
+		    retry = 1;
+		}
 	    }
+
+	    dput(alias);
 	}
     }
 #endif
     d_add(dp, ip);
 
+ done:
     crfree(credp);
 
     /* It's ok for the file to not be found. That's noted by the caller by
@@ -1995,6 +2065,26 @@ afs_linux_write_begin(struct file *file, struct address_space *mapping,
 }
 #endif
 
+static int
+afs_linux_dir_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+    struct dentry **dpp;
+    struct dentry *target;
+
+    target = canonical_dentry(dentry->d_inode);
+
+    dpp = &nd->dentry;
+
+    dput(*dpp);
+
+    if (target) {
+	*dpp = target;
+    } else {
+	*dpp = dget(dentry);
+    }
+
+    return 0;
+}
 
 static struct inode_operations afs_file_iops = {
 #if defined(AFS_LINUX24_ENV)
@@ -2044,6 +2134,7 @@ static struct inode_operations afs_dir_iops = {
   .rename =		afs_linux_rename,
   .revalidate =		afs_linux_revalidate,
   .permission =		afs_linux_permission,
+  .follow_link =	afs_linux_dir_follow_link,
 };
 
 /* We really need a separate symlink set of ops, since do_follow_link()
diff --git a/src/afs/NBSD/osi_file.c b/src/afs/NBSD/osi_file.c
index 8c93145..6d8746a 100644
--- a/src/afs/NBSD/osi_file.c
+++ b/src/afs/NBSD/osi_file.c
@@ -142,7 +142,7 @@ afs_osi_Read(struct osi_file *afile, int offset, void *aptr, afs_int32 asize)
 	if (!afs_shuttingdown)
 	    osi_Panic("osi_Read called with null param");
 	else
-	    return EIO;
+	    return -EIO;
     }
 
     if (offset != -1)
@@ -160,7 +160,9 @@ afs_osi_Read(struct osi_file *afile, int offset, void *aptr, afs_int32 asize)
     } else {
 	afs_Trace2(afs_iclSetp, CM_TRACE_READFAILED, ICL_TYPE_INT32, resid,
 		   ICL_TYPE_INT32, code);
-	code = -1;
+	if (code > 0) {
+	    code *= -1;
+	}
     }
     return code;
 }
@@ -192,8 +194,11 @@ afs_osi_Write(struct osi_file *afile, afs_int32 offset, void *aptr,
 	afile->offset += code;
 	if (afile->offset > afile->size)
 	    afile->size = afile->offset;
-    } else
-	code = -1;
+    } else {
+	if (code > 0) {
+	    code *= -1;
+	}
+    }
 
     if (afile->proc)
 	(*afile->proc) (afile, code);
diff --git a/src/afs/OBSD/osi_file.c b/src/afs/OBSD/osi_file.c
index a82cd02..72a43ef 100644
--- a/src/afs/OBSD/osi_file.c
+++ b/src/afs/OBSD/osi_file.c
@@ -146,7 +146,7 @@ afs_osi_Read(struct osi_file *afile, int offset, void *aptr, afs_int32 asize)
 	if (!afs_shuttingdown)
 	    osi_Panic("osi_Read called with null param");
 	else
-	    return EIO;
+	    return -EIO;
     }
 
     if (offset != -1)
@@ -163,7 +163,9 @@ afs_osi_Read(struct osi_file *afile, int offset, void *aptr, afs_int32 asize)
     } else {
 	afs_Trace2(afs_iclSetp, CM_TRACE_READFAILED, ICL_TYPE_INT32,
 		   (unsigned int) resid, ICL_TYPE_INT32, code);
-	code = -1;
+	if (code > 0) {
+	    code *= -1;
+	}
     }
     return code;
 }
@@ -195,8 +197,11 @@ afs_osi_Write(struct osi_file *afile, afs_int32 offset, void *aptr,
 	afile->offset += code;
 	if (afile->offset > afile->size)
 	    afile->size = afile->offset;
-    } else
-	code = -1;
+    } else {
+	if (code > 0) {
+	    code *= -1;
+	}
+    }
 
     if (afile->proc)
 	(*afile->proc) (afile, code);
diff --git a/src/afs/SOLARIS/osi_file.c b/src/afs/SOLARIS/osi_file.c
index a9e97ed..e0c0057 100644
--- a/src/afs/SOLARIS/osi_file.c
+++ b/src/afs/SOLARIS/osi_file.c
@@ -379,7 +379,7 @@ afs_osi_Read(struct osi_file *afile, int offset, void *aptr,
 	if (!afs_shuttingdown)
 	    osi_Panic("osi_Read called with null param");
 	else
-	    return EIO;
+	    return -EIO;
     }
 
     if (offset != -1)
@@ -396,7 +396,9 @@ afs_osi_Read(struct osi_file *afile, int offset, void *aptr,
     } else {
 	afs_Trace2(afs_iclSetp, CM_TRACE_READFAILED, ICL_TYPE_INT32, resid,
 		   ICL_TYPE_INT32, code);
-	code = -1;
+	if (code > 0) {
+	    code *= -1;
+	}
     }
     return code;
 }
@@ -428,7 +430,9 @@ afs_osi_Write(struct osi_file *afile, afs_int32 offset, void *aptr,
 	code = asize - resid;
 	afile->offset += code;
     } else {
-	code = -1;
+	if (code > 0) {
+	    code *= -1;
+	}
     }
     if (afile->proc) {
 	(*afile->proc) (afile, code);
diff --git a/src/afs/SOLARIS/osi_machdep.h b/src/afs/SOLARIS/osi_machdep.h
index 3e8c886..964ac8b 100644
--- a/src/afs/SOLARIS/osi_machdep.h
+++ b/src/afs/SOLARIS/osi_machdep.h
@@ -99,7 +99,6 @@ extern kmutex_t afs_global_lock;
 #define ISAFS_GLOCK()	mutex_owned(&afs_global_lock)
 #define osi_InitGlock() \
 	mutex_init(&afs_global_lock, "afs_global_lock", MUTEX_DEFAULT, NULL);
-#endif
 
 
 /* Associate the Berkley signal equivalent lock types to System V's */
@@ -144,6 +143,7 @@ struct afs_ifinfo {
   int         metric;
   ipaddr_t    dstaddr;
 };
+#endif /* AFS_SUN510_ENV */
 
 #define osi_procname(procname, size) strncpy(procname, PTOU(ttoproc(curthread))->u_comm, size)
 
diff --git a/src/afs/SOLARIS/osi_vcache.c b/src/afs/SOLARIS/osi_vcache.c
index 8c2ce11..19fba7b 100644
--- a/src/afs/SOLARIS/osi_vcache.c
+++ b/src/afs/SOLARIS/osi_vcache.c
@@ -28,7 +28,11 @@ osi_TryEvictVCache(struct vcache *avc, int *slept, int defersleep) {
 
 struct vcache *
 osi_NewVnode(void) {
-    return (struct vcache *)afs_osi_Alloc(sizeof(struct vcache));
+    struct vcache *avc;
+
+    avc = afs_osi_Alloc(sizeof(struct vcache));
+    osi_Assert(avc != NULL);
+    return avc;
 }
 
 void
diff --git a/src/afs/VNOPS/afs_vnop_attrs.c b/src/afs/VNOPS/afs_vnop_attrs.c
index b3931e5..d01aff2 100644
--- a/src/afs/VNOPS/afs_vnop_attrs.c
+++ b/src/afs/VNOPS/afs_vnop_attrs.c
@@ -104,8 +104,9 @@ afs_CopyOutAttrs(struct vcache *avc, struct vattr *attrs)
 	/* The mount point's vnode. */
 	if (tvp) {
 	    attrs->va_nodeid =
-	      afs_calc_inum (tvp->mtpoint.Fid.Volume,
-			      tvp->mtpoint.Fid.Vnode);
+	      afs_calc_inum(tvp->mtpoint.Cell,
+			    tvp->mtpoint.Fid.Volume,
+			    tvp->mtpoint.Fid.Vnode);
 	    if (FidCmp(&afs_rootFid, &avc->f.fid) && !attrs->va_nodeid)
 		attrs->va_nodeid = 2;
 	    afs_PutVolume(tvp, READ_LOCK);
@@ -113,8 +114,9 @@ afs_CopyOutAttrs(struct vcache *avc, struct vattr *attrs)
 	    attrs->va_nodeid = 2;
     } else
 	attrs->va_nodeid = 
-	      afs_calc_inum (avc->f.fid.Fid.Volume,
-			      avc->f.fid.Fid.Vnode);
+	      afs_calc_inum(avc->f.fid.Cell,
+			    avc->f.fid.Fid.Volume,
+			    avc->f.fid.Fid.Vnode);
     attrs->va_nodeid &= 0x7fffffff;	/* Saber C hates negative inode #s! */
     attrs->va_nlink = fakedir ? 100 : avc->f.m.LinkCount;
     attrs->va_size = fakedir ? 4096 : avc->f.m.Length;
diff --git a/src/afs/VNOPS/afs_vnop_lookup.c b/src/afs/VNOPS/afs_vnop_lookup.c
index 580f78b..f4f28da 100644
--- a/src/afs/VNOPS/afs_vnop_lookup.c
+++ b/src/afs/VNOPS/afs_vnop_lookup.c
@@ -622,6 +622,33 @@ Next_AtSys(struct vcache *avc, struct vrequest *areq,
     return 1;
 }
 
+static int
+afs_CheckBulkStatus(struct afs_conn *tc, int nFids, AFSBulkStats *statParm,
+                    AFSCBs *cbParm)
+{
+    int i;
+    int code;
+
+    if (statParm->AFSBulkStats_len != nFids || cbParm->AFSCBs_len != nFids) {
+	afs_warn("afs: BulkFetchStatus length %u/%u, expected %u\n",
+	         (unsigned)statParm->AFSBulkStats_len,
+	         (unsigned)cbParm->AFSCBs_len, nFids);
+	afs_BadFetchStatus(tc);
+	return VBUSY;
+    }
+    for (i = 0; i < nFids; i++) {
+	if (statParm->AFSBulkStats_val[i].errorCode) {
+	    continue;
+	}
+	code = afs_CheckFetchStatus(tc, &statParm->AFSBulkStats_val[i]);
+	if (code) {
+	    return code;
+	}
+    }
+
+    return 0;
+}
+
 extern int BlobScan(struct dcache * afile, afs_int32 ablob);
 
 /* called with an unlocked directory and directory cookie.  Areqp
@@ -1001,6 +1028,10 @@ afs_DoBulkStat(struct vcache *adp, long dirCookie, struct vrequest *areqp)
 		RX_AFS_GLOCK();
 	    }
 	    XSTATS_END_TIME;
+
+	    if (code == 0) {
+		code = afs_CheckBulkStatus(tcp, fidIndex, &statParm, &cbParm);
+	    }
 	} else
 	    code = -1;
     } while (afs_Analyze
diff --git a/src/afs/VNOPS/afs_vnop_symlink.c b/src/afs/VNOPS/afs_vnop_symlink.c
index 3e08108..faf103e 100644
--- a/src/afs/VNOPS/afs_vnop_symlink.c
+++ b/src/afs/VNOPS/afs_vnop_symlink.c
@@ -277,7 +277,8 @@ afs_symlink(OSI_VC_DECL(adp), char *aname, struct vattr *attrs,
     }
 
     if (!tvc->linkData) {
-	tvc->linkData = (char *)afs_osi_Alloc(alen);
+	tvc->linkData = afs_osi_Alloc(alen);
+	osi_Assert(tvc->linkData != NULL);
 	strncpy(tvc->linkData, atargetName, alen - 1);
 	tvc->linkData[alen - 1] = 0;
     }
@@ -334,6 +335,7 @@ afs_MemHandleLink(struct vcache *avc, struct vrequest *areq)
 	rbuf[alen - 1] = 0;
 	alen = strlen(rbuf) + 1;
 	tp = afs_osi_Alloc(alen);	/* make room for terminating null */
+	osi_Assert(tp != NULL);
 	memcpy(tp, rbuf, alen);
 	osi_FreeLargeSpace(rbuf);
 	if (code != len) {
@@ -390,6 +392,7 @@ afs_UFSHandleLink(struct vcache *avc, struct vrequest *areq)
 	rbuf[alen - 1] = '\0';
 	alen = strlen(rbuf) + 1;
 	tp = afs_osi_Alloc(alen);	/* make room for terminating null */
+	osi_Assert(tp != NULL);
 	memcpy(tp, rbuf, alen);
 	osi_FreeLargeSpace(rbuf);
 	if (code != tlen) {
diff --git a/src/afs/afs.h b/src/afs/afs.h
index 542617a..25b69b6 100644
--- a/src/afs/afs.h
+++ b/src/afs/afs.h
@@ -244,6 +244,7 @@ struct vrequest {
     char tokenError;            /* a token error other than expired. */
     char idleError;             /* the server idled too long */
     char skipserver[AFS_MAXHOSTS];
+    afs_int32 lasterror[AFS_MAXHOSTS];
 };
 #define VOLMISSING 1
 #define VOLBUSY 2
@@ -879,6 +880,13 @@ struct vcache {
 #if defined(AFS_LINUX26_ENV)
     cred_t *cred;		/* last writer's cred */
 #endif
+#ifdef AFS_LINUX24_ENV
+    struct dentry *target_link; /* dentry we prefer, when we are redirecting
+                                 * all requests due to duplicate dentry aliases.
+                                 * See LINUX/osi_vnodeops.c. Note that this is
+                                 * NOT an actual reference to a dentry, so this
+                                 * pointer MUST NOT be dereferenced on its own. */
+#endif
     afs_int32 vc_error;		/* stash write error for this vnode. */
     int xlatordv;		/* Used by nfs xlator */
     afs_ucred_t *uncred;
@@ -1307,6 +1315,11 @@ extern struct brequest afs_brs[NBRS];	/* request structures */
 #define IS_SLOCK 4
 #define IS_WLOCK 8
 
+/* values for adown value of afs_LoopServers */
+#define AFS_LS_UP 0
+#define AFS_LS_DOWN 1
+#define AFS_LS_ALL 2
+
 /* values for flag param of afs_CheckVolumeNames */
 #define AFS_VOLCHECK_EXPIRED	0x1	/* volumes whose callbacks have expired */
 #define AFS_VOLCHECK_BUSY	0x2	/* volumes which were marked busy */
diff --git a/src/afs/afs_analyze.c b/src/afs/afs_analyze.c
index efda1be..b7f4aea 100644
--- a/src/afs/afs_analyze.c
+++ b/src/afs/afs_analyze.c
@@ -111,6 +111,7 @@ VLDB_Same(struct VenusFid *afid, struct vrequest *areq)
     if ((i = afs_InitReq(&treq, afs_osi_credp)))
 	return DUNNO;
     v = afs_osi_Alloc(sizeof(*v));
+    osi_Assert(v != NULL);
     tcell = afs_GetCell(afid->Cell, READ_LOCK);
     bp = afs_cv2string(&tbuf[CVBS], afid->Fid.Volume);
     do {
@@ -332,6 +333,55 @@ afs_ClearStatus(struct VenusFid *afid, int op, struct volume *avp)
     return 0;
 }
 
+/*!
+ * \brief
+ *      Print the last errors from the servers for the volume on
+ *      this request.
+ *
+ * \param[in] areq   The request record associated with this operation.
+ * \param[in] afid   The FID of the file involved in the action.  This argument
+ *		     may be null if none was involved.
+ *
+ * \return
+ *      None
+ *
+ * \note
+ *      This routine is called before a hard-mount retry, to display
+ *      the servers by primary address and the errors encountered.
+ */
+static void
+afs_PrintServerErrors(struct vrequest *areq, struct VenusFid *afid)
+{
+    int i;
+    struct volume *tvp;
+    struct srvAddr *sa;
+    afs_uint32 address;
+    char *sep = " (";
+    char *term = "";
+
+    if (afid) {
+	tvp = afs_FindVolume(afid, READ_LOCK);
+	if (tvp) {
+	    for (i = 0; i < AFS_MAXHOSTS; i++) {
+		if (tvp->serverHost[i]) {
+		    sa = tvp->serverHost[i]->addr;
+		    if (sa) {
+			address = ntohl(sa->sa_ip);
+			afs_warnuser("%s%d.%d.%d.%d code=%d", sep,
+				     (address >> 24), (address >> 16) & 0xff,
+				     (address >> 8) & 0xff, (address) & 0xff,
+				     areq->lasterror[i]);
+			sep = ", ";
+			term = ")";
+		    }
+		}
+	    }
+	    afs_PutVolume(tvp, READ_LOCK);
+	}
+    }
+    afs_warnuser("%s\n", term);
+}
+
 /*------------------------------------------------------------------------
  * EXPORTED afs_Analyze
  *
@@ -377,7 +427,6 @@ afs_Analyze(struct afs_conn *aconn, struct rx_connection *rxconn,
     afs_int32 shouldRetry = 0;
     afs_int32 serversleft = 1;
     struct afs_stats_RPCErrors *aerrP;
-    afs_int32 markeddown;
     afs_uint32 address;
 
     if (AFS_IS_DISCONNECTED && !AFS_IN_SYNC) {
@@ -501,8 +550,9 @@ afs_Analyze(struct afs_conn *aconn, struct rx_connection *rxconn,
 		    if (shouldRetry) {
 			if (warn) {
 			    afs_warnuser
-			        ("afs: hard-mount waiting for volume %u\n",
+			        ("afs: hard-mount waiting for volume %u",
 			         afid->Fid.Volume);
+			    afs_PrintServerErrors(areq, afid);
 			}
 
 			VSleep(hm_retry_int);
@@ -533,6 +583,8 @@ afs_Analyze(struct afs_conn *aconn, struct rx_connection *rxconn,
 		}
 	    }
 	}
+	if (aconn) /* simply lacking aconn->server doesn't absolve this */
+	    afs_PutConn(aconn, rxconn, locktype);
 	return shouldRetry;
     }
 
@@ -564,6 +616,17 @@ afs_Analyze(struct afs_conn *aconn, struct rx_connection *rxconn,
 	return 0;
     }
 
+    /* Save the last code of this server on this request. */
+    tvp = afs_FindVolume(afid, READ_LOCK);
+    if (tvp) {
+	for (i = 0; i < AFS_MAXHOSTS; i++) {
+	    if (tvp->serverHost[i] == tsp) {
+		areq->lasterror[i] = acode;
+	    }
+	}
+	afs_PutVolume(tvp, READ_LOCK);
+    }
+
     /* If network troubles, mark server as having bogued out again. */
     /* VRESTARTING is < 0 because of backward compatibility issues
      * with 3.4 file servers and older cache managers */
@@ -601,7 +664,7 @@ afs_Analyze(struct afs_conn *aconn, struct rx_connection *rxconn,
 	     */
 	    goto out;
 	}
-	markeddown = afs_ServerDown(sa);
+	afs_ServerDown(sa, acode);
 	ForceNewConnections(sa); /**multi homed clients lock:afs_xsrvAddr? */
 	if (aerrP)
 	    (aerrP->err_Server)++;
@@ -727,7 +790,7 @@ afs_Analyze(struct afs_conn *aconn, struct rx_connection *rxconn,
     }
     /* check for ubik errors; treat them like crashed servers */
     else if (acode >= ERROR_TABLE_BASE_U && acode < ERROR_TABLE_BASE_U + 255) {
-	afs_ServerDown(sa);
+	afs_ServerDown(sa, acode);
 	if (aerrP)
 	    (aerrP->err_Server)++;
 	shouldRetry = 1;	/* retryable (maybe one is working) */
diff --git a/src/afs/afs_axscache.c b/src/afs/afs_axscache.c
index 790a238..08f233a 100644
--- a/src/afs/afs_axscache.c
+++ b/src/afs/afs_axscache.c
@@ -69,6 +69,7 @@ axs_Alloc(void)
 	return i;
     } else {
 	h = afs_osi_Alloc(sizeof(struct xfreelist));
+	osi_Assert(h != NULL);
 	afs_xaxscnt++;
 	xsp = xfreemallocs;
 	xfreemallocs = h;
diff --git a/src/afs/afs_buffer.c b/src/afs/afs_buffer.c
index e65d789..bf04c42 100644
--- a/src/afs/afs_buffer.c
+++ b/src/afs/afs_buffer.c
@@ -119,8 +119,8 @@ DInit(int abuffers)
     abuffers = ((abuffers - 1) | (NPB - 1)) + 1;
     afs_max_buffers = abuffers << 2;		/* possibly grow up to 4 times as big */
     LOCK_INIT(&afs_bufferLock, "afs_bufferLock");
-    Buffers =
-	(struct buffer *)afs_osi_Alloc(afs_max_buffers * sizeof(struct buffer));
+    Buffers = afs_osi_Alloc(afs_max_buffers * sizeof(struct buffer));
+    osi_Assert(Buffers != NULL);
     timecounter = 1;
     afs_stats_cmperf.bufAlloced = nbuffers = abuffers;
     for (i = 0; i < PHSIZE; i++)
@@ -128,7 +128,8 @@ DInit(int abuffers)
     for (i = 0; i < abuffers; i++) {
 	if ((i & (NPB - 1)) == 0) {
 	    /* time to allocate a fresh buffer */
-	    BufferData = (char *) afs_osi_Alloc(AFS_BUFFER_PAGESIZE * NPB);
+	    BufferData = afs_osi_Alloc(AFS_BUFFER_PAGESIZE * NPB);
+	    osi_Assert(BufferData != NULL);
 	}
 	/* Fill in each buffer with an empty indication. */
 	tb = &Buffers[i];
@@ -337,7 +338,8 @@ afs_newslot(struct dcache *adc, afs_int32 apage, struct buffer *lp)
 	    return 0;
 	}
 
-	BufferData = (char *) afs_osi_Alloc(AFS_BUFFER_PAGESIZE * NPB);
+	BufferData = afs_osi_Alloc(AFS_BUFFER_PAGESIZE * NPB);
+	osi_Assert(BufferData != NULL);
 	for (i = 0; i< NPB; i++) {
 	    /* Fill in each buffer with an empty indication. */
 	    tp = &Buffers[i + nbuffers];
@@ -555,7 +557,7 @@ DNew(struct dcache *adc, int page)
      * DFlush due to lock hierarchy issues */
     if ((page + 1) * AFS_BUFFER_PAGESIZE > adc->f.chunkBytes) {
 	afs_AdjustSize(adc, (page + 1) * AFS_BUFFER_PAGESIZE);
-	afs_WriteDCache(adc, 1);
+	osi_Assert(afs_WriteDCache(adc, 1) == 0);
     }
     ObtainWriteLock(&tb->lock, 265);
     tb->lockers++;
diff --git a/src/afs/afs_bypasscache.c b/src/afs/afs_bypasscache.c
index e447024..4dca01c 100644
--- a/src/afs/afs_bypasscache.c
+++ b/src/afs/afs_bypasscache.c
@@ -270,49 +270,12 @@ done:
 #ifdef UKERNEL
 typedef void * bypass_page_t;
 
-#define copy_page(pp, pageoff, rxiov, iovno, iovoff, auio, curiov)	\
-    do { \
-	int dolen = auio->uio_iov[curiov].iov_len - pageoff; \
-	memcpy(((char *)pp) + pageoff,		       \
-	       ((char *)rxiov[iovno].iov_base) + iovoff, dolen);	\
-	auio->uio_resid -= dolen; \
-    } while(0)
-
-#define copy_pages(pp, pageoff, rxiov, iovno, iovoff, auio, curiov)	\
-    do { \
-	int dolen = rxiov[iovno].iov_len - iovoff; \
-	memcpy(((char *)pp) + pageoff,				\
-	       ((char *)rxiov[iovno].iov_base) + iovoff, dolen);	\
-	auio->uio_resid -= dolen;	\
-    } while(0)
-
 #define unlock_and_release_pages(auio)
 #define release_full_page(pp, pageoff)
 
 #else
 typedef struct page * bypass_page_t;
 
-#define copy_page(pp, pageoff, rxiov, iovno, iovoff, auio, curiov)	\
-    do { \
-        char *address;						\
-	int dolen = auio->uio_iov[curiov].iov_len - pageoff; \
-	address = kmap_atomic(pp, KM_USER0); \
-	memcpy(address + pageoff, \
-	       (char *)(rxiov[iovno].iov_base) + iovoff, dolen);	\
-	kunmap_atomic(address, KM_USER0); \
-    } while(0)
-
-#define copy_pages(pp, pageoff, rxiov, iovno, iovoff, auio, curiov)	\
-    do { \
-        char *address; \
-	int dolen = rxiov[iovno].iov_len - iovoff; \
-	address = kmap_atomic(pp, KM_USER0); \
-	memcpy(address + pageoff, \
-	       (char *)(rxiov[iovno].iov_base) + iovoff, dolen);	\
-	kunmap_atomic(address, KM_USER0); \
-    } while(0)
-
-
 #define unlock_and_release_pages(auio) \
     do { \
 	struct iovec *ciov;	\
@@ -347,8 +310,38 @@ typedef struct page * bypass_page_t;
 	    afs_warn("afs_NoCacheFetchProc: page not locked!\n"); \
 	put_page(pp); /* decrement refcount */ \
     } while(0)
+#endif
 
+static void
+afs_bypass_copy_page(bypass_page_t pp, int pageoff, struct iovec *rxiov,
+	int iovno, int iovoff, struct uio *auio, int curiov, int partial)
+{
+    char *address;
+    int dolen;
+
+    if (partial)
+	dolen = rxiov[iovno].iov_len - iovoff;
+    else
+	dolen = auio->uio_iov[curiov].iov_len - pageoff;
+
+#if !defined(UKERNEL)
+# if defined(KMAP_ATOMIC_TAKES_NO_KM_TYPE)
+    address = kmap_atomic(pp);
+# else
+    address = kmap_atomic(pp, KM_USER0);
+# endif
+#else
+    address = pp;
 #endif
+    memcpy(address + pageoff, (char *)(rxiov[iovno].iov_base) + iovoff, dolen);
+#if !defined(UKERNEL)
+# if defined(KMAP_ATOMIC_TAKES_NO_KM_TYPE)
+    kunmap_atomic(address);
+# else
+    kunmap_atomic(address, KM_USER0);
+# endif
+#endif
+}
 
 /* no-cache prefetch routine */
 static afs_int32
@@ -447,7 +440,7 @@ afs_NoCacheFetchProc(struct rx_call *acall,
 		if (pageoff + (rxiov[iovno].iov_len - iovoff) <= auio->uio_iov[curpage].iov_len) {
 		    /* Copy entire (or rest of) current iovec into current page */
 		    if (pp)
-			copy_pages(pp, pageoff, rxiov, iovno, iovoff, auio, curpage);
+			afs_bypass_copy_page(pp, pageoff, rxiov, iovno, iovoff, auio, curpage, 0);
 		    length -= (rxiov[iovno].iov_len - iovoff);
 		    pageoff += rxiov[iovno].iov_len - iovoff;
 		    iovno++;
@@ -455,7 +448,7 @@ afs_NoCacheFetchProc(struct rx_call *acall,
 		} else {
 		    /* Copy only what's needed to fill current page */
 		    if (pp)
-			copy_page(pp, pageoff, rxiov, iovno, iovoff, auio, curpage);
+			afs_bypass_copy_page(pp, pageoff, rxiov, iovno, iovoff, auio, curpage, 1);
 		    length -= (auio->uio_iov[curpage].iov_len - pageoff);
 		    iovoff += auio->uio_iov[curpage].iov_len - pageoff;
 		    pageoff = auio->uio_iov[curpage].iov_len;
@@ -568,7 +561,6 @@ afs_PrefetchNoCache(struct vcache *avc,
 #endif
 
     struct afs_conn *tc;
-    afs_int32 i;
     struct rx_call *tcall;
     struct tlocal1 {
 	struct AFSVolSync tsync;
@@ -588,7 +580,6 @@ afs_PrefetchNoCache(struct vcache *avc,
       tc = afs_Conn(&avc->f.fid, areq, SHARED_LOCK /* ignored */, &rxconn);
 	if (tc) {
 	    avc->callback = tc->srvr->server;
-	    i = osi_Time();
 	    tcall = rx_NewCall(rxconn);
 #ifdef AFS_64BIT_CLIENT
 	    if (!afs_serverHasNo64Bit(tc)) {
diff --git a/src/afs/afs_call.c b/src/afs/afs_call.c
index 0841090..3d184b5 100644
--- a/src/afs/afs_call.c
+++ b/src/afs/afs_call.c
@@ -66,7 +66,9 @@ static int AFS_Running = 0;
 static int afs_CacheInit_Done = 0;
 static int afs_Go_Done = 0;
 extern struct interfaceAddr afs_cb_interface;
+#ifdef RXK_LISTENER_ENV
 static int afs_RX_Running = 0;
+#endif
 static int afs_InitSetup_done = 0;
 afs_int32 afs_numcachefiles = -1;
 afs_int32 afs_numfilesperdir = -1;
@@ -662,7 +664,9 @@ afs_syscall_call(long parm, long parm2, long parm3,
 		   sizeof(struct afs_uspc_param), code);
 	namebufsz = mvParam->bufSz;
 	param1 = afs_osi_Alloc(namebufsz);
+	osi_Assert(param1 != NULL);
 	param2 = afs_osi_Alloc(namebufsz);
+	osi_Assert(param2 != NULL);
 
 	while (afs_initState < AFSOP_START_BKG)
 	    afs_osi_Sleep(&afs_initState);
@@ -867,6 +871,7 @@ afs_syscall_call(long parm, long parm2, long parm3,
 	 * home cell flag (0x1 bit) and the nosuid flag (0x2 bit) */
 	struct afsop_cell *tcell = afs_osi_Alloc(sizeof(struct afsop_cell));
 
+	osi_Assert(tcell != NULL);
 	code = afs_InitDynroot();
 	if (!code) {
 	    AFS_COPYIN(AFSKPTR(parm2), (caddr_t)tcell->hosts, sizeof(tcell->hosts),
@@ -889,6 +894,9 @@ afs_syscall_call(long parm, long parm2, long parm3,
 	char *tbuffer1 = osi_AllocSmallSpace(AFS_SMALLOCSIZ);
 	int cflags = parm4;
 
+	osi_Assert(tcell != NULL);
+	osi_Assert(tbuffer != NULL);
+	osi_Assert(tbuffer1 != NULL);
 	code = afs_InitDynroot();
 	if (!code) {
 #if 0
@@ -1093,6 +1101,9 @@ afs_syscall_call(long parm, long parm2, long parm3,
 	    afs_osi_Alloc(sizeof(afs_int32) * AFS_MAX_INTERFACE_ADDR);
 	int i;
 
+	osi_Assert(buffer != NULL);
+	osi_Assert(maskbuffer != NULL);
+	osi_Assert(mtubuffer != NULL);
 	/* This is a refresh */
 	if (count & 0x40000000) {
 	    count &= ~0x40000000;
@@ -1158,7 +1169,7 @@ afs_syscall_call(long parm, long parm2, long parm3,
 
 	if (refresh) {
 	    afs_CheckServers(1, NULL);     /* check down servers */
-	    afs_CheckServers(0, NULL);     /* check down servers */
+	    afs_CheckServers(0, NULL);     /* check up servers */
 	}
     }
 #ifdef	AFS_SGI53_ENV
@@ -1271,6 +1282,8 @@ afs_syscall_call(long parm, long parm2, long parm3,
 	afs_int32 *kmsg = afs_osi_Alloc(kmsgLen);
 	char *cellname = afs_osi_Alloc(cellLen);
 
+	osi_Assert(kmsg != NULL);
+	osi_Assert(cellname != NULL);
 #ifndef UKERNEL
 	afs_osi_MaskUserLoop();
 #endif
@@ -1373,6 +1386,15 @@ afs_shutdown(void)
     afs_FlushAllVCaches();
 #endif
 
+    afs_termState = AFSOP_STOP_BKG;
+
+    afs_warn("BkG... ");
+    /* Wake-up afs_brsDaemons so that we don't have to wait for a bkg job! */
+    while (afs_termState == AFSOP_STOP_BKG) {
+	afs_osi_Wakeup(&afs_brsDaemons);
+	afs_osi_Sleep(&afs_termState);
+    }
+
     afs_warn("CB... ");
 
     afs_termState = AFSOP_STOP_RXCALLBACK;
@@ -1395,12 +1417,6 @@ afs_shutdown(void)
 	    afs_osi_Sleep(&afs_termState);
 	}
     }
-    afs_warn("BkG... ");
-    /* Wake-up afs_brsDaemons so that we don't have to wait for a bkg job! */
-    while (afs_termState == AFSOP_STOP_BKG) {
-	afs_osi_Wakeup(&afs_brsDaemons);
-	afs_osi_Sleep(&afs_termState);
-    }
     afs_warn("CTrunc... ");
     /* Cancel cache truncate daemon. */
     while (afs_termState == AFSOP_STOP_TRUNCDAEMON) {
diff --git a/src/afs/afs_callback.c b/src/afs/afs_callback.c
index d24e070..51b6b61 100644
--- a/src/afs/afs_callback.c
+++ b/src/afs/afs_callback.c
@@ -898,6 +898,7 @@ SRXAFSCB_GetXStats(struct rx_call *a_call, afs_int32 a_clientVersionNum,
 	 */
 	dataBytes = sizeof(struct afs_CMStats);
 	dataBuffP = (afs_int32 *) afs_osi_Alloc(dataBytes);
+	osi_Assert(dataBuffP != NULL);
 	memcpy((char *)dataBuffP, (char *)&afs_cmstats, dataBytes);
 	a_dataP->AFSCB_CollData_len = dataBytes >> 2;
 	a_dataP->AFSCB_CollData_val = dataBuffP;
@@ -918,6 +919,7 @@ SRXAFSCB_GetXStats(struct rx_call *a_call, afs_int32 a_clientVersionNum,
 	afs_CountServers();
 	dataBytes = sizeof(afs_stats_cmperf);
 	dataBuffP = (afs_int32 *) afs_osi_Alloc(dataBytes);
+	osi_Assert(dataBuffP != NULL);
 	memcpy((char *)dataBuffP, (char *)&afs_stats_cmperf, dataBytes);
 	a_dataP->AFSCB_CollData_len = dataBytes >> 2;
 	a_dataP->AFSCB_CollData_val = dataBuffP;
@@ -942,6 +944,7 @@ SRXAFSCB_GetXStats(struct rx_call *a_call, afs_int32 a_clientVersionNum,
 
 	dataBytes = sizeof(afs_stats_cmfullperf);
 	dataBuffP = (afs_int32 *) afs_osi_Alloc(dataBytes);
+	osi_Assert(dataBuffP != NULL);
 	memcpy((char *)dataBuffP, (char *)(&afs_stats_cmfullperf), dataBytes);
 	a_dataP->AFSCB_CollData_len = dataBytes >> 2;
 	a_dataP->AFSCB_CollData_val = dataBuffP;
@@ -1295,8 +1298,8 @@ SRXAFSCB_GetCellServDB(struct rx_call *a_call, afs_int32 a_index,
 	p_name = tcell->cellName;
 	for (j = 0; j < AFSMAXCELLHOSTS && tcell->cellHosts[j]; j++);
 	i = strlen(p_name);
-	a_hosts->serverList_val =
-	    (afs_int32 *) afs_osi_Alloc(j * sizeof(afs_int32));
+	a_hosts->serverList_val = afs_osi_Alloc(j * sizeof(afs_int32));
+	osi_Assert(a_hosts->serverList_val != NULL);
 	a_hosts->serverList_len = j;
 	for (j = 0; j < AFSMAXCELLHOSTS && tcell->cellHosts[j]; j++)
 	    a_hosts->serverList_val[j] =
@@ -1304,7 +1307,7 @@ SRXAFSCB_GetCellServDB(struct rx_call *a_call, afs_int32 a_index,
 	afs_PutCell(tcell, READ_LOCK);
     }
 
-    t_name = (char *)afs_osi_Alloc(i + 1);
+    t_name = afs_osi_Alloc(i + 1);
     if (t_name == NULL) {
 	afs_osi_Free(a_hosts->serverList_val, (j * sizeof(afs_int32)));
 	RX_AFS_GUNLOCK();
@@ -1362,7 +1365,7 @@ SRXAFSCB_GetLocalCell(struct rx_call *a_call, char **a_name)
 	plen = strlen(p_name);
     else
 	plen = 0;
-    t_name = (char *)afs_osi_Alloc(plen + 1);
+    t_name = afs_osi_Alloc(plen + 1);
     if (t_name == NULL) {
 	if (tcell)
 	    afs_PutCell(tcell, READ_LOCK);
@@ -1459,7 +1462,7 @@ SRXAFSCB_GetCacheConfig(struct rx_call *a_call, afs_uint32 callerVersion,
      * Currently only support version 1
      */
     allocsize = sizeof(cm_initparams_v1);
-    t_config = (afs_uint32 *) afs_osi_Alloc(allocsize);
+    t_config = afs_osi_Alloc(allocsize);
     if (t_config == NULL) {
 	RX_AFS_GUNLOCK();
 	return ENOMEM;
@@ -1600,8 +1603,8 @@ SRXAFSCB_GetCellByNum(struct rx_call *a_call, afs_int32 a_cellnum,
 
     for (sn = 0; sn < AFSMAXCELLHOSTS && tcell->cellHosts[sn]; sn++);
     a_hosts->serverList_len = sn;
-    a_hosts->serverList_val =
-	(afs_int32 *) afs_osi_Alloc(sn * sizeof(afs_int32));
+    a_hosts->serverList_val = afs_osi_Alloc(sn * sizeof(afs_int32));
+    osi_Assert(a_hosts->serverList_val != NULL);
 
     for (i = 0; i < sn; i++)
 	a_hosts->serverList_val[i] = ntohl(tcell->cellHosts[i]->addr->sa_ip);
@@ -1642,7 +1645,8 @@ SRXAFSCB_TellMeAboutYourself(struct rx_call *a_call,
     RX_AFS_GUNLOCK();
 
     dataBytes = 1 * sizeof(afs_uint32);
-    dataBuffP = (afs_uint32 *) afs_osi_Alloc(dataBytes);
+    dataBuffP = afs_osi_Alloc(dataBytes);
+    osi_Assert(dataBuffP != NULL);
     dataBuffP[0] = CLIENT_CAPABILITY_ERRORTRANS;
     capabilities->Capabilities_len = dataBytes / sizeof(afs_uint32);
     capabilities->Capabilities_val = dataBuffP;
diff --git a/src/afs/afs_cell.c b/src/afs/afs_cell.c
index f688689..3e4259a 100644
--- a/src/afs/afs_cell.c
+++ b/src/afs/afs_cell.c
@@ -57,7 +57,11 @@ afs_StopAFSDB(void)
 	afs_osi_Wakeup(&afsdb_req);
     } else {
 	afsdb_handler_shutdown = 1;
+#if defined(AFS_SUN5_ENV) || defined(RXK_LISTENER_ENV) || defined(RXK_UPCALL_ENV)
 	afs_termState = AFSOP_STOP_RXEVENT;
+#else
+	afs_termState = AFSOP_STOP_COMPLETE;
+#endif
 	afs_osi_Wakeup(&afs_termState);
     }
 }
@@ -229,7 +233,8 @@ afs_cellname_new(char *name, afs_int32 cellnum)
     if (cellnum == 0)
 	cellnum = afs_cellnum_next;
 
-    cn = (struct cell_name *)afs_osi_Alloc(sizeof(*cn));
+    cn = afs_osi_Alloc(sizeof(*cn));
+    osi_Assert(cn != NULL);
     cn->next = afs_cellname_head;
     cn->cellnum = cellnum;
     cn->cellname = afs_strdup(name);
@@ -326,7 +331,6 @@ afs_cellname_init(afs_dcache_id_t *inode, int lookupcode)
 
     while (1) {
 	afs_int32 cellnum, clen, magic;
-	struct cell_name *cn;
 	char *cellname;
 
 	cc = afs_osi_Read(tfile, off, &magic, sizeof(magic));
@@ -364,7 +368,7 @@ afs_cellname_init(afs_dcache_id_t *inode, int lookupcode)
 	    break;
 	}
 
-	cn = afs_cellname_new(cellname, cellnum);
+	afs_cellname_new(cellname, cellnum);
 	afs_osi_Free(cellname, clen + 1);
     }
 
@@ -511,7 +515,8 @@ afs_NewCellAlias(char *alias, char *cell)
     }
 
     UpgradeSToWLock(&afs_xcell, 682);
-    tc = (struct cell_alias *)afs_osi_Alloc(sizeof(struct cell_alias));
+    tc = afs_osi_Alloc(sizeof(struct cell_alias));
+    osi_Assert(tc != NULL);
     tc->alias = afs_strdup(alias);
     tc->cell = afs_strdup(cell);
     tc->next = afs_cellalias_head;
@@ -913,7 +918,8 @@ afs_NewCell(char *acellName, afs_int32 * acellHosts, int aflags,
     if (tc) {
 	aflags &= ~CNoSUID;
     } else {
-	tc = (struct cell *)afs_osi_Alloc(sizeof(struct cell));
+	tc = afs_osi_Alloc(sizeof(struct cell));
+	osi_Assert(tc != NULL);
 	memset(tc, 0, sizeof(*tc));
 	tc->cellName = afs_strdup(acellName);
 	tc->fsport = AFS_FSPORT;
diff --git a/src/afs/afs_chunkops.h b/src/afs/afs_chunkops.h
index d3a5090..2aa19c1 100644
--- a/src/afs/afs_chunkops.h
+++ b/src/afs/afs_chunkops.h
@@ -63,8 +63,7 @@ struct afs_cacheOps {
 		  int noLock);
     int (*vwrite) (struct vcache * avc, struct uio * auio, int aio,
 		   afs_ucred_t * acred, int noLock);
-    struct dcache *(*GetDSlot) (afs_int32 aslot,
-				struct dcache * tmpdc);
+    struct dcache *(*GetDSlot) (afs_int32 aslot, int needvalid);
     struct volume *(*GetVolSlot) (void);
     int (*HandleLink) (struct vcache * avc, struct vrequest * areq);
 };
@@ -75,7 +74,8 @@ struct afs_cacheOps {
 #define	afs_CFileRead(file, offset, data, size) (*(afs_cacheType->fread))(file, offset, data, size)
 #define	afs_CFileWrite(file, offset, data, size) (*(afs_cacheType->fwrite))(file, offset, data, size)
 #define	afs_CFileClose(handle)		(*(afs_cacheType->close))(handle)
-#define	afs_GetDSlot(slot, adc)		(*(afs_cacheType->GetDSlot))(slot, adc)
+#define	afs_GetValidDSlot(slot)	(*(afs_cacheType->GetDSlot))(slot, 1)
+#define	afs_GetNewDSlot(slot)	(*(afs_cacheType->GetDSlot))(slot, 0)
 #define	afs_GetVolSlot()		(*(afs_cacheType->GetVolSlot))()
 #define	afs_HandleLink(avc, areq)	(*(afs_cacheType->HandleLink))(avc, areq)
 
diff --git a/src/afs/afs_conn.c b/src/afs/afs_conn.c
index 108df40..692e7c2 100644
--- a/src/afs/afs_conn.c
+++ b/src/afs/afs_conn.c
@@ -148,6 +148,7 @@ afs_Conn(struct VenusFid *afid, struct vrequest *areq,
 
     /* First is always lowest rank, if it's up */
     if ((tv->status[0] == not_busy) && tv->serverHost[0]
+	&& tv->serverHost[0]->addr
 	&& !(tv->serverHost[0]->addr->sa_flags & SRVR_ISDOWN) &&
 	!(((areq->idleError > 0) || (areq->tokenError > 0))
 	  && (areq->skipserver[0] == 1)))
@@ -269,7 +270,8 @@ afs_ConnBySA(struct srvAddr *sap, unsigned short aport, afs_int32 acell,
 	 * gets set, marking the time of its ``birth''.
 	 */
 	UpgradeSToWLock(&afs_xconn, 37);
-	tc = (struct afs_conn *)afs_osi_Alloc(sizeof(struct afs_conn));
+	tc = afs_osi_Alloc(sizeof(struct afs_conn));
+	osi_Assert(tc != NULL);
 	memset(tc, 0, sizeof(struct afs_conn));
 
 	tc->user = tu;
diff --git a/src/afs/afs_daemons.c b/src/afs/afs_daemons.c
index 23655e3..dd710b7 100644
--- a/src/afs/afs_daemons.c
+++ b/src/afs/afs_daemons.c
@@ -90,7 +90,7 @@ afs_CheckServerDaemon(void)
     last10MinCheck = lastCheck = osi_Time();
     while (1) {
 	if (afs_termState == AFSOP_STOP_CS) {
-	    afs_termState = AFSOP_STOP_BKG;
+	    afs_termState = AFSOP_STOP_TRUNCDAEMON;
 	    afs_osi_Wakeup(&afs_termState);
 	    break;
 	}
@@ -108,7 +108,7 @@ afs_CheckServerDaemon(void)
 	}
 	/* shutdown check. */
 	if (afs_termState == AFSOP_STOP_CS) {
-	    afs_termState = AFSOP_STOP_BKG;
+	    afs_termState = AFSOP_STOP_TRUNCDAEMON;
 	    afs_osi_Wakeup(&afs_termState);
 	    break;
 	}
@@ -308,7 +308,7 @@ afs_Daemon(void)
 	    if (afs_CheckServerDaemonStarted)
 		afs_termState = AFSOP_STOP_CS;
 	    else
-		afs_termState = AFSOP_STOP_BKG;
+		afs_termState = AFSOP_STOP_TRUNCDAEMON;
 	    afs_osi_Wakeup(&afs_termState);
 	    return;
 	}
@@ -396,8 +396,13 @@ afs_CheckRootVolume(void)
 		    spin_lock(&dp->d_lock);
 #endif
 #endif
+#if defined(D_ALIAS_IS_HLIST)
+		    hlist_del_init(&dp->d_alias);
+		    hlist_add_head(&dp->d_alias, &(AFSTOV(vcp)->i_dentry));
+#else
 		    list_del_init(&dp->d_alias);
 		    list_add(&dp->d_alias, &(AFSTOV(vcp)->i_dentry));
+#endif
 		    dp->d_inode = AFSTOV(vcp);
 #if defined(AFS_LINUX24_ENV)
 #if defined(AFS_LINUX26_ENV)
@@ -1045,7 +1050,7 @@ afs_BackgroundDaemon(void)
 
 	if (afs_termState == AFSOP_STOP_BKG) {
 	    if (--afs_nbrs <= 0)
-		afs_termState = AFSOP_STOP_TRUNCDAEMON;
+		afs_termState = AFSOP_STOP_RXCALLBACK;
 	    ReleaseWriteLock(&afs_xbrs);
 	    afs_osi_Wakeup(&afs_termState);
 #ifdef AFS_DARWIN80_ENV
@@ -1176,7 +1181,7 @@ afs_sgidaemon(void)
 	    SPUNLOCK(afs_sgibklock, s);
 	    AFS_GLOCK();
 	    tdc->dflags &= ~DFEntryMod;
-	    afs_WriteDCache(tdc, 1);
+	    osi_Assert(afs_WriteDCache(tdc, 1) == 0);
 	    AFS_GUNLOCK();
 	    s = SPLOCK(afs_sgibklock);
 	}
diff --git a/src/afs/afs_dcache.c b/src/afs/afs_dcache.c
index b5773d0..ff5ee5c 100644
--- a/src/afs/afs_dcache.c
+++ b/src/afs/afs_dcache.c
@@ -672,15 +672,17 @@ afs_GetDownD(int anumber, int *aneedSpace, afs_int32 buckethint)
 	 * during the truncate operation.
 	 */
 	for (i = 0; i < victimPtr; i++) {
-	    tdc = afs_GetDSlot(victims[i], 0);
+	    tdc = afs_GetValidDSlot(victims[i]);
 	    /* We got tdc->tlock(R) here */
-	    if (tdc->refCount == 1)
+	    if (tdc && tdc->refCount == 1)
 		victimDCs[i] = tdc;
 	    else
 		victimDCs[i] = 0;
-	    ReleaseReadLock(&tdc->tlock);
-	    if (!victimDCs[i])
-		afs_PutDCache(tdc);
+	    if (tdc) {
+		ReleaseReadLock(&tdc->tlock);
+		if (!victimDCs[i])
+		    afs_PutDCache(tdc);
+	    }
 	}
 	for (i = 0; i < victimPtr; i++) {
 	    /* q is first elt in dcache entry */
@@ -689,7 +691,7 @@ afs_GetDownD(int anumber, int *aneedSpace, afs_int32 buckethint)
 	     * have to verify, before proceeding, that there are no other
 	     * references to this dcache entry, even now.  Note that we
 	     * compare with 1, since we bumped it above when we called
-	     * afs_GetDSlot to preserve the entry's identity.
+	     * afs_GetValidDSlot to preserve the entry's identity.
 	     */
 	    if (tdc && tdc->refCount == 1) {
 		unsigned char chunkFlags;
@@ -1085,7 +1087,7 @@ afs_FreeDiscardedDCache(void)
     /*
      * Get an entry from the list of discarded cache elements
      */
-    tdc = afs_GetDSlot(afs_discardDCList, 0);
+    tdc = afs_GetNewDSlot(afs_discardDCList);
     osi_Assert(tdc->refCount == 1);
     ReleaseReadLock(&tdc->tlock);
 
@@ -1201,7 +1203,7 @@ afs_GetDownDSlot(int anumber)
 		}
 #else
 		tdc->dflags &= ~DFEntryMod;
-		afs_WriteDCache(tdc, 1);
+		osi_Assert(afs_WriteDCache(tdc, 1) == 0);
 #endif
 	    }
 
@@ -1311,7 +1313,8 @@ afs_TryToSmush(struct vcache *avc, afs_ucred_t *acred, int sync)
 	i = afs_dvnextTbl[index];	/* next pointer this hash table */
 	if (afs_indexUnique[index] == avc->f.fid.Fid.Unique) {
 	    int releaseTlock = 1;
-	    tdc = afs_GetDSlot(index, NULL);
+	    tdc = afs_GetValidDSlot(index);
+	    if (!tdc) osi_Panic("afs_TryToSmush tdc");
 	    if (!FidCmp(&tdc->f.fid, &avc->f.fid)) {
 		if (sync) {
 		    if ((afs_indexFlags[index] & IFDataMod) == 0
@@ -1400,12 +1403,14 @@ afs_DCacheMissingChunks(struct vcache *avc)
     for (index = afs_dvhashTbl[i]; index != NULLIDX; index = i) {
         i = afs_dvnextTbl[index];
         if (afs_indexUnique[index] == avc->f.fid.Fid.Unique) {
-            tdc = afs_GetDSlot(index, NULL);
-            if (!FidCmp(&tdc->f.fid, &avc->f.fid)) {
-		totalChunks--;
-            }
-            ReleaseReadLock(&tdc->tlock);
-            afs_PutDCache(tdc);
+            tdc = afs_GetValidDSlot(index);
+	    if (tdc) {
+		if (!FidCmp(&tdc->f.fid, &avc->f.fid)) {
+		    totalChunks--;
+		}
+		ReleaseReadLock(&tdc->tlock);
+		afs_PutDCache(tdc);
+	    }
         }
     }
     ReleaseWriteLock(&afs_xdcache);
@@ -1453,7 +1458,8 @@ afs_FindDCache(struct vcache *avc, afs_size_t abyte)
     ObtainWriteLock(&afs_xdcache, 278);
     for (index = afs_dchashTbl[i]; index != NULLIDX;) {
 	if (afs_indexUnique[index] == avc->f.fid.Fid.Unique) {
-	    tdc = afs_GetDSlot(index, NULL);
+	    tdc = afs_GetValidDSlot(index);
+	    if (!tdc) osi_Panic("afs_FindDCache tdc");
 	    ReleaseReadLock(&tdc->tlock);
 	    if (!FidCmp(&tdc->f.fid, &avc->f.fid) && chunk == tdc->f.chunk) {
 		break;		/* leaving refCount high for caller */
@@ -1501,7 +1507,7 @@ afs_AllocDCache(struct vcache *avc, afs_int32 chunk, afs_int32 lock,
 	|| ((lock & 2) && afs_freeDCList != NULLIDX)) {
 
 	afs_indexFlags[afs_freeDCList] &= ~IFFree;
-	tdc = afs_GetDSlot(afs_freeDCList, 0);
+	tdc = afs_GetNewDSlot(afs_freeDCList);
 	osi_Assert(tdc->refCount == 1);
 	ReleaseReadLock(&tdc->tlock);
 	ObtainWriteLock(&tdc->lock, 604);
@@ -1509,7 +1515,7 @@ afs_AllocDCache(struct vcache *avc, afs_int32 chunk, afs_int32 lock,
 	afs_freeDCCount--;
     } else {
 	afs_indexFlags[afs_discardDCList] &= ~IFDiscarded;
-	tdc = afs_GetDSlot(afs_discardDCList, 0);
+	tdc = afs_GetNewDSlot(afs_discardDCList);
 	osi_Assert(tdc->refCount == 1);
 	ReleaseReadLock(&tdc->tlock);
 	ObtainWriteLock(&tdc->lock, 605);
@@ -1627,7 +1633,6 @@ afs_GetDCache(struct vcache *avc, afs_size_t abyte,
     afs_int32 index;
     afs_int32 us;
     afs_int32 chunk;
-    afs_size_t maxGoodLength;	/* amount of good data at server */
     afs_size_t Position = 0;
     afs_int32 size, tlen;	/* size of segment to transfer */
     struct afs_FetchOutput *tsmall = 0;
@@ -1769,7 +1774,11 @@ afs_GetDCache(struct vcache *avc, afs_size_t abyte,
 	us = NULLIDX;
 	for (index = afs_dchashTbl[i]; index != NULLIDX;) {
 	    if (afs_indexUnique[index] == avc->f.fid.Fid.Unique) {
-		tdc = afs_GetDSlot(index, NULL);
+		tdc = afs_GetValidDSlot(index);
+		if (!tdc) {
+		    ReleaseWriteLock(&afs_xdcache);
+		    goto done;
+		}
 		ReleaseReadLock(&tdc->tlock);
 		/*
 		 * Locks held:
@@ -2077,10 +2086,6 @@ afs_GetDCache(struct vcache *avc, afs_size_t abyte,
 	    goto RetryGetDCache;
 	}
 
-	/* Do not fetch data beyond truncPos. */
-	maxGoodLength = avc->f.m.Length;
-	if (avc->f.truncPos < maxGoodLength)
-	    maxGoodLength = avc->f.truncPos;
 	Position = AFS_CHUNKBASE(abyte);
 	if (vType(avc) == VDIR) {
 	    size = avc->f.m.Length;
@@ -2090,16 +2095,49 @@ afs_GetDCache(struct vcache *avc, afs_size_t abyte,
 	    }
 	    size = 999999999;	/* max size for transfer */
 	} else {
+	    afs_size_t maxGoodLength;
+
+	    /* estimate how much data we're expecting back from the server,
+	     * and reserve space in the dcache entry for it */
+
+	    maxGoodLength = avc->f.m.Length;
+	    if (avc->f.truncPos < maxGoodLength)
+		maxGoodLength = avc->f.truncPos;
+
 	    size = AFS_CHUNKSIZE(abyte);	/* expected max size */
-	    /* don't read past end of good data on server */
 	    if (Position + size > maxGoodLength)
 		size = maxGoodLength - Position;
 	    if (size < 0)
 		size = 0;	/* Handle random races */
 	    if (size > tdc->f.chunkBytes) {
-		/* pre-reserve space for file */
+		/* pre-reserve estimated space for file */
 		afs_AdjustSize(tdc, size);	/* changes chunkBytes */
-		/* max size for transfer still in size */
+	    }
+
+	    if (size) {
+		/* For the actual fetch, do not limit the request to the
+		 * length of the file. If this results in a read past EOF on
+		 * the server, the server will just reply with less data than
+		 * requested. If we limit ourselves to only requesting data up
+		 * to the avc file length, we open ourselves up to races if the
+		 * file is extended on the server at about the same time.
+		 *
+		 * However, we must restrict ourselves to the avc->f.truncPos
+		 * length, since this represents an outstanding local
+		 * truncation of the file that will be committed to the
+		 * fileserver when we actually write the fileserver contents.
+		 * If we do not restrict the fetch length based on
+		 * avc->f.truncPos, a different truncate operation extending
+		 * the file length could cause the old data after
+		 * avc->f.truncPos to reappear, instead of extending the file
+		 * with NUL bytes. */
+		size = AFS_CHUNKSIZE(abyte);
+		if (Position + size > avc->f.truncPos) {
+		    size = avc->f.truncPos - Position;
+		}
+		if (size < 0) {
+		    size = 0;
+		}
 	    }
 	}
 	if (afs_mariner && !tdc->f.chunk)
@@ -2523,7 +2561,7 @@ afs_WriteThroughDSlots(void)
 	    if (wrLock && (tdc->dflags & DFEntryMod)) {
 		tdc->dflags &= ~DFEntryMod;
 		ObtainWriteLock(&afs_xdcache, 620);
-		afs_WriteDCache(tdc, 1);
+		osi_Assert(afs_WriteDCache(tdc, 1) == 0);
 		ReleaseWriteLock(&afs_xdcache);
 		touchedit = 1;
 	    }
@@ -2561,14 +2599,14 @@ afs_WriteThroughDSlots(void)
  *
  * Parameters:
  *	aslot : Dcache slot to look at.
- *	tmpdc : Ptr to dcache entry.
+ *      needvalid : Whether the specified slot should already exist
  *
  * Environment:
  *	Must be called with afs_xdcache write-locked.
  */
 
 struct dcache *
-afs_MemGetDSlot(afs_int32 aslot, struct dcache *tmpdc)
+afs_MemGetDSlot(afs_int32 aslot, int needvalid)
 {
     struct dcache *tdc;
     int existing = 0;
@@ -2588,30 +2626,32 @@ afs_MemGetDSlot(afs_int32 aslot, struct dcache *tmpdc)
 	ConvertWToRLock(&tdc->tlock);
 	return tdc;
     }
-    if (tmpdc == NULL) {
-	if (!afs_freeDSList)
-	    afs_GetDownDSlot(4);
-	if (!afs_freeDSList) {
-	    /* none free, making one is better than a panic */
-	    afs_stats_cmperf.dcacheXAllocs++;	/* count in case we have a leak */
-	    tdc = (struct dcache *)afs_osi_Alloc(sizeof(struct dcache));
+
+    /* if 'needvalid' is true, the slot must already exist and be populated
+     * somewhere. for memcache, the only place that dcache entries exist is
+     * in memory, so if we did not find it above, something is very wrong. */
+    osi_Assert(!needvalid);
+
+    if (!afs_freeDSList)
+	afs_GetDownDSlot(4);
+    if (!afs_freeDSList) {
+	/* none free, making one is better than a panic */
+	afs_stats_cmperf.dcacheXAllocs++;	/* count in case we have a leak */
+	tdc = afs_osi_Alloc(sizeof(struct dcache));
+	osi_Assert(tdc != NULL);
 #ifdef	KERNEL_HAVE_PIN
-	    pin((char *)tdc, sizeof(struct dcache));	/* XXX */
+	pin((char *)tdc, sizeof(struct dcache));	/* XXX */
 #endif
-	} else {
-	    tdc = afs_freeDSList;
-	    afs_freeDSList = (struct dcache *)tdc->lruq.next;
-	    existing = 1;
-	}
-	tdc->dflags = 0;	/* up-to-date, not in free q */
-	tdc->mflags = 0;
-	QAdd(&afs_DLRU, &tdc->lruq);
-	if (tdc->lruq.prev == &tdc->lruq)
-	    osi_Panic("lruq 3");
     } else {
-	tdc = tmpdc;
-	tdc->f.states = 0;
+	tdc = afs_freeDSList;
+	afs_freeDSList = (struct dcache *)tdc->lruq.next;
+	existing = 1;
     }
+    tdc->dflags = 0;	/* up-to-date, not in free q */
+    tdc->mflags = 0;
+    QAdd(&afs_DLRU, &tdc->lruq);
+    if (tdc->lruq.prev == &tdc->lruq)
+	osi_Panic("lruq 3");
 
     /* initialize entry */
     tdc->f.fid.Cell = 0;
@@ -2635,8 +2675,7 @@ afs_MemGetDSlot(afs_int32 aslot, struct dcache *tmpdc)
     AFS_RWLOCK_INIT(&tdc->mflock, "dcache flock");
     ObtainReadLock(&tdc->tlock);
 
-    if (tmpdc == NULL)
-	afs_indexTable[aslot] = tdc;
+    afs_indexTable[aslot] = tdc;
     return tdc;
 
 }				/*afs_MemGetDSlot */
@@ -2652,18 +2691,19 @@ unsigned int last_error = 0, lasterrtime = 0;
  *
  * Parameters:
  *	aslot : Dcache slot to look at.
- *	tmpdc : Ptr to dcache entry.
+ *      needvalid : Whether the specified slot should already exist
  *
  * Environment:
  *	afs_xdcache lock write-locked.
  */
 struct dcache *
-afs_UFSGetDSlot(afs_int32 aslot, struct dcache *tmpdc)
+afs_UFSGetDSlot(afs_int32 aslot, int needvalid)
 {
     afs_int32 code;
     struct dcache *tdc;
     int existing = 0;
     int entryok;
+    int off;
 
     AFS_STATCNT(afs_UFSGetDSlot);
     if (CheckLock(&afs_xdcache) != -1)
@@ -2680,49 +2720,74 @@ afs_UFSGetDSlot(afs_int32 aslot, struct dcache *tmpdc)
 	ConvertWToRLock(&tdc->tlock);
 	return tdc;
     }
+
     /* otherwise we should read it in from the cache file */
-    /*
-     * If we weren't passed an in-memory region to place the file info,
-     * we have to allocate one.
-     */
-    if (tmpdc == NULL) {
-	if (!afs_freeDSList)
-	    afs_GetDownDSlot(4);
-	if (!afs_freeDSList) {
-	    /* none free, making one is better than a panic */
-	    afs_stats_cmperf.dcacheXAllocs++;	/* count in case we have a leak */
-	    tdc = (struct dcache *)afs_osi_Alloc(sizeof(struct dcache));
+    if (!afs_freeDSList)
+	afs_GetDownDSlot(4);
+    if (!afs_freeDSList) {
+	/* none free, making one is better than a panic */
+	afs_stats_cmperf.dcacheXAllocs++;	/* count in case we have a leak */
+	tdc = afs_osi_Alloc(sizeof(struct dcache));
+	osi_Assert(tdc != NULL);
 #ifdef	KERNEL_HAVE_PIN
-	    pin((char *)tdc, sizeof(struct dcache));	/* XXX */
+	pin((char *)tdc, sizeof(struct dcache));	/* XXX */
 #endif
-	} else {
-	    tdc = afs_freeDSList;
-	    afs_freeDSList = (struct dcache *)tdc->lruq.next;
-	    existing = 1;
-	}
-	tdc->dflags = 0;	/* up-to-date, not in free q */
-	tdc->mflags = 0;
-	QAdd(&afs_DLRU, &tdc->lruq);
-	if (tdc->lruq.prev == &tdc->lruq)
-	    osi_Panic("lruq 3");
     } else {
-	tdc = tmpdc;
-	tdc->f.states = 0;
+	tdc = afs_freeDSList;
+	afs_freeDSList = (struct dcache *)tdc->lruq.next;
+	existing = 1;
     }
+    tdc->dflags = 0;	/* up-to-date, not in free q */
+    tdc->mflags = 0;
+    QAdd(&afs_DLRU, &tdc->lruq);
+    if (tdc->lruq.prev == &tdc->lruq)
+	osi_Panic("lruq 3");
 
     /*
      * Seek to the aslot'th entry and read it in.
      */
+    off = sizeof(struct fcache)*aslot + sizeof(struct afs_fheader);
     code =
 	afs_osi_Read(afs_cacheInodep,
-		     sizeof(struct fcache) * aslot +
-		     sizeof(struct afs_fheader), (char *)(&tdc->f),
+		     off, (char *)(&tdc->f),
 		     sizeof(struct fcache));
     entryok = 1;
-    if (code != sizeof(struct fcache))
+    if (code != sizeof(struct fcache)) {
 	entryok = 0;
-    if (!afs_CellNumValid(tdc->f.fid.Cell))
+#if defined(KERNEL_HAVE_UERROR)
+	last_error = getuerror();
+#endif
+	lasterrtime = osi_Time();
+	if (needvalid) {
+	    struct osi_stat tstat;
+	    if (afs_osi_Stat(afs_cacheInodep, &tstat)) {
+		tstat.size = -1;
+	    }
+	    afs_warn("afs: disk cache read error in CacheItems off %d/%d "
+	             "code %d/%d\n",
+	             off, (int)tstat.size,
+	             (int)code, (int)sizeof(struct fcache));
+	    /* put tdc back on the free dslot list */
+	    QRemove(&tdc->lruq);
+	    tdc->index = NULLIDX;
+	    tdc->lruq.next = (struct afs_q *)afs_freeDSList;
+	    afs_freeDSList = tdc;
+	    return NULL;
+	}
+    }
+    if (!afs_CellNumValid(tdc->f.fid.Cell)) {
 	entryok = 0;
+	if (needvalid) {
+	    osi_Panic("afs: needed valid dcache but index %d off %d has "
+	              "invalid cell num %d\n",
+	              (int)aslot, off, (int)tdc->f.fid.Cell);
+	}
+    }
+
+    if (needvalid && tdc->f.fid.Fid.Volume == 0) {
+	osi_Panic("afs: invalid zero-volume dcache entry at slot %d off %d",
+	          (int)aslot, off);
+    }
 
     if (!entryok) {
 	tdc->f.fid.Cell = 0;
@@ -2730,10 +2795,6 @@ afs_UFSGetDSlot(afs_int32 aslot, struct dcache *tmpdc)
 	tdc->f.chunk = -1;
 	hones(tdc->f.versionNo);
 	tdc->dflags |= DFEntryMod;
-#if defined(KERNEL_HAVE_UERROR)
-	last_error = getuerror();
-#endif
-	lasterrtime = osi_Time();
 	afs_indexUnique[aslot] = tdc->f.fid.Fid.Unique;
 	tdc->f.states &= ~(DRO|DBackup|DRW);
 	afs_DCMoveBucket(tdc, 0, 0);
@@ -2770,8 +2831,7 @@ afs_UFSGetDSlot(afs_int32 aslot, struct dcache *tmpdc)
      * If we didn't read into a temporary dcache region, update the
      * slot pointer table.
      */
-    if (tmpdc == NULL)
-	afs_indexTable[aslot] = tdc;
+    afs_indexTable[aslot] = tdc;
     return tdc;
 
 }				/*afs_UFSGetDSlot */
@@ -2802,6 +2862,19 @@ afs_WriteDCache(struct dcache *adc, int atime)
     osi_Assert(WriteLocked(&afs_xdcache));
     if (atime)
 	adc->f.modTime = osi_Time();
+
+    if ((afs_indexFlags[adc->index] & (IFFree | IFDiscarded)) == 0 &&
+        adc->f.fid.Fid.Volume == 0) {
+	/* If a dcache slot is not on the free or discard list, it must be
+	 * in the hash table. Thus, the volume must be non-zero, since that
+	 * is how we determine whether or not to unhash the entry when kicking
+	 * it out of the cache. Do this check now, since otherwise this can
+	 * cause hash table corruption and a panic later on after we read the
+	 * entry back in. */
+	osi_Panic("afs_WriteDCache zero volume index %d flags 0x%x\n",
+	          adc->index, (unsigned)afs_indexFlags[adc->index]);
+    }
+
     /*
      * Seek to the right dcache slot and write the in-memory image out to disk.
      */
@@ -2811,8 +2884,12 @@ afs_WriteDCache(struct dcache *adc, int atime)
 		      sizeof(struct fcache) * adc->index +
 		      sizeof(struct afs_fheader), (char *)(&adc->f),
 		      sizeof(struct fcache));
-    if (code != sizeof(struct fcache))
+    if (code != sizeof(struct fcache)) {
+	afs_warn("afs: failed to write to CacheItems off %ld code %d/%d\n",
+	         (long)(sizeof(struct fcache) * adc->index + sizeof(struct afs_fheader)),
+	         (int)code, (int)sizeof(struct fcache));
 	return EIO;
+    }
     return 0;
 }
 
@@ -2861,7 +2938,6 @@ afs_wakeup(struct vcache *avc)
     return 0;
 }
 
-
 /*!
  * Given a file name and inode, set up that file to be an
  * active member in the AFS cache.  This also involves checking
@@ -2889,62 +2965,67 @@ afs_InitCacheFile(char *afile, ino_t ainode)
 	return EINVAL;
 
     ObtainWriteLock(&afs_xdcache, 282);
-    tdc = afs_GetDSlot(index, NULL);
+    tdc = afs_GetNewDSlot(index);
     ReleaseReadLock(&tdc->tlock);
     ReleaseWriteLock(&afs_xdcache);
 
     ObtainWriteLock(&tdc->lock, 621);
     ObtainWriteLock(&afs_xdcache, 622);
-    if (afile) {
-	code = afs_LookupInodeByPath(afile, &tdc->f.inode.ufs, NULL);
-	if (code) {
-	    ReleaseWriteLock(&afs_xdcache);
-	    ReleaseWriteLock(&tdc->lock);
-	    afs_PutDCache(tdc);
-	    return code;
-	}
+    if (!afile && !ainode) {
+	tfile = NULL;
+	fileIsBad = 1;
     } else {
-	/* Add any other 'complex' inode types here ... */
+	if (afile) {
+	    code = afs_LookupInodeByPath(afile, &tdc->f.inode.ufs, NULL);
+	    if (code) {
+		ReleaseWriteLock(&afs_xdcache);
+		ReleaseWriteLock(&tdc->lock);
+		afs_PutDCache(tdc);
+		return code;
+	    }
+	} else {
+	    /* Add any other 'complex' inode types here ... */
 #if !defined(AFS_LINUX26_ENV) && !defined(AFS_CACHE_VNODE_PATH)
-	tdc->f.inode.ufs = ainode;
+	    tdc->f.inode.ufs = ainode;
 #else
-	osi_Panic("Can't init cache with inode numbers when complex inodes are "
-	          "in use\n");
+	    osi_Panic("Can't init cache with inode numbers when complex inodes are "
+		      "in use\n");
 #endif
-    }
-    fileIsBad = 0;
-    if ((tdc->f.states & DWriting) || tdc->f.fid.Fid.Volume == 0)
-	fileIsBad = 1;
-    tfile = osi_UFSOpen(&tdc->f.inode);
-    code = afs_osi_Stat(tfile, &tstat);
-    if (code)
-	osi_Panic("initcachefile stat");
+	}
+	fileIsBad = 0;
+	if ((tdc->f.states & DWriting) || tdc->f.fid.Fid.Volume == 0)
+	    fileIsBad = 1;
+	tfile = osi_UFSOpen(&tdc->f.inode);
+	code = afs_osi_Stat(tfile, &tstat);
+	if (code)
+	    osi_Panic("initcachefile stat");
 
-    /*
-     * If file size doesn't match the cache info file, it's probably bad.
-     */
-    if (tdc->f.chunkBytes != tstat.size)
-	fileIsBad = 1;
+	/*
+	 * If file size doesn't match the cache info file, it's probably bad.
+	 */
+	if (tdc->f.chunkBytes != tstat.size)
+	    fileIsBad = 1;
+	/*
+	 * If file changed within T (120?) seconds of cache info file, it's
+	 * probably bad.  In addition, if slot changed within last T seconds,
+	 * the cache info file may be incorrectly identified, and so slot
+	 * may be bad.
+	 */
+	if (cacheInfoModTime < tstat.mtime + 120)
+	    fileIsBad = 1;
+	if (cacheInfoModTime < tdc->f.modTime + 120)
+	    fileIsBad = 1;
+	/* In case write through is behind, make sure cache items entry is
+	 * at least as new as the chunk.
+	 */
+	if (tdc->f.modTime < tstat.mtime)
+	    fileIsBad = 1;
+    }
     tdc->f.chunkBytes = 0;
 
-    /*
-     * If file changed within T (120?) seconds of cache info file, it's
-     * probably bad.  In addition, if slot changed within last T seconds,
-     * the cache info file may be incorrectly identified, and so slot
-     * may be bad.
-     */
-    if (cacheInfoModTime < tstat.mtime + 120)
-	fileIsBad = 1;
-    if (cacheInfoModTime < tdc->f.modTime + 120)
-	fileIsBad = 1;
-    /* In case write through is behind, make sure cache items entry is
-     * at least as new as the chunk.
-     */
-    if (tdc->f.modTime < tstat.mtime)
-	fileIsBad = 1;
     if (fileIsBad) {
 	tdc->f.fid.Fid.Volume = 0;	/* not in the hash table */
-	if (tstat.size != 0)
+	if (tfile && tstat.size != 0)
 	    osi_UFSTruncate(tfile, 0);
 	tdc->f.states &= ~(DRO|DBackup|DRW);
 	afs_DCMoveBucket(tdc, 0, 0);
@@ -2981,11 +3062,12 @@ afs_InitCacheFile(char *afile, ino_t ainode)
 	afs_indexUnique[index] = tdc->f.fid.Fid.Unique;
     }				/*File is not bad */
 
-    osi_UFSClose(tfile);
+    if (tfile)
+	osi_UFSClose(tfile);
     tdc->f.states &= ~DWriting;
     tdc->dflags &= ~DFEntryMod;
     /* don't set f.modTime; we're just cleaning up */
-    afs_WriteDCache(tdc, 0);
+    osi_Assert(afs_WriteDCache(tdc, 0) == 0);
     ReleaseWriteLock(&afs_xdcache);
     ReleaseWriteLock(&tdc->lock);
     afs_PutDCache(tdc);
@@ -3038,63 +3120,44 @@ afs_dcacheInit(int afiles, int ablocks, int aDentries, int achunk, int aflags)
     if (!aDentries)
 	aDentries = DDSIZE;
 
-    if (aflags & AFSCALL_INIT_MEMCACHE) {
-	/*
-	 * Use a memory cache instead of a disk cache
-	 */
-	cacheDiskType = AFS_FCACHE_TYPE_MEM;
-	afs_cacheType = &afs_MemCacheOps;
-	afiles = (afiles < aDentries) ? afiles : aDentries;	/* min */
-	ablocks = afiles * (AFS_FIRSTCSIZE / 1024);
-	/* ablocks is reported in 1K blocks */
-	code = afs_InitMemCache(afiles, AFS_FIRSTCSIZE, aflags);
-	if (code != 0) {
-	    afs_warn("afsd: memory cache too large for available memory.\n");
-	    afs_warn("afsd: AFS files cannot be accessed.\n\n");
-	    dcacheDisabled = 1;
-	    afiles = ablocks = 0;
-	} else
-	    afs_warn("Memory cache: Allocating %d dcache entries...",
-		   aDentries);
-    } else {
-	cacheDiskType = AFS_FCACHE_TYPE_UFS;
-	afs_cacheType = &afs_UfsCacheOps;
-    }
-
     if (aDentries > 512)
 	afs_dhashsize = 2048;
     /* initialize hash tables */
-    afs_dvhashTbl =
-	(afs_int32 *) afs_osi_Alloc(afs_dhashsize * sizeof(afs_int32));
-    afs_dchashTbl =
-	(afs_int32 *) afs_osi_Alloc(afs_dhashsize * sizeof(afs_int32));
+    afs_dvhashTbl = afs_osi_Alloc(afs_dhashsize * sizeof(afs_int32));
+    osi_Assert(afs_dvhashTbl != NULL);
+    afs_dchashTbl = afs_osi_Alloc(afs_dhashsize * sizeof(afs_int32));
+    osi_Assert(afs_dchashTbl != NULL);
     for (i = 0; i < afs_dhashsize; i++) {
 	afs_dvhashTbl[i] = NULLIDX;
 	afs_dchashTbl[i] = NULLIDX;
     }
-    afs_dvnextTbl = (afs_int32 *) afs_osi_Alloc(afiles * sizeof(afs_int32));
-    afs_dcnextTbl = (afs_int32 *) afs_osi_Alloc(afiles * sizeof(afs_int32));
+    afs_dvnextTbl = afs_osi_Alloc(afiles * sizeof(afs_int32));
+    osi_Assert(afs_dvnextTbl != NULL);
+    afs_dcnextTbl = afs_osi_Alloc(afiles * sizeof(afs_int32));
+    osi_Assert(afs_dcnextTbl != NULL);
     for (i = 0; i < afiles; i++) {
 	afs_dvnextTbl[i] = NULLIDX;
 	afs_dcnextTbl[i] = NULLIDX;
     }
 
     /* Allocate and zero the pointer array to the dcache entries */
-    afs_indexTable = (struct dcache **)
-	afs_osi_Alloc(sizeof(struct dcache *) * afiles);
+    afs_indexTable = afs_osi_Alloc(sizeof(struct dcache *) * afiles);
+    osi_Assert(afs_indexTable != NULL);
     memset(afs_indexTable, 0, sizeof(struct dcache *) * afiles);
-    afs_indexTimes =
-	(afs_hyper_t *) afs_osi_Alloc(afiles * sizeof(afs_hyper_t));
+    afs_indexTimes = afs_osi_Alloc(afiles * sizeof(afs_hyper_t));
+    osi_Assert(afs_indexTimes != NULL);
     memset(afs_indexTimes, 0, afiles * sizeof(afs_hyper_t));
-    afs_indexUnique =
-	(afs_int32 *) afs_osi_Alloc(afiles * sizeof(afs_uint32));
+    afs_indexUnique = afs_osi_Alloc(afiles * sizeof(afs_uint32));
+    osi_Assert(afs_indexUnique != NULL);
     memset(afs_indexUnique, 0, afiles * sizeof(afs_uint32));
-    afs_indexFlags = (u_char *) afs_osi_Alloc(afiles * sizeof(u_char));
+    afs_indexFlags = afs_osi_Alloc(afiles * sizeof(u_char));
+    osi_Assert(afs_indexFlags != NULL);
     memset(afs_indexFlags, 0, afiles * sizeof(char));
 
     /* Allocate and thread the struct dcache entries themselves */
     tdp = afs_Initial_freeDSList =
-	(struct dcache *)afs_osi_Alloc(aDentries * sizeof(struct dcache));
+	afs_osi_Alloc(aDentries * sizeof(struct dcache));
+    osi_Assert(tdp != NULL);
     memset(tdp, 0, aDentries * sizeof(struct dcache));
 #ifdef	KERNEL_HAVE_PIN
     pin((char *)afs_indexTable, sizeof(struct dcache *) * afiles);	/* XXX */
@@ -3131,6 +3194,29 @@ afs_dcacheInit(int afiles, int ablocks, int aDentries, int achunk, int aflags)
 	afs_stats_cmperf.cacheBucket2_Discarded = 0;
     afs_DCSizeInit();
     QInit(&afs_DLRU);
+
+    if (aflags & AFSCALL_INIT_MEMCACHE) {
+	/*
+	 * Use a memory cache instead of a disk cache
+	 */
+	cacheDiskType = AFS_FCACHE_TYPE_MEM;
+	afs_cacheType = &afs_MemCacheOps;
+	afiles = (afiles < aDentries) ? afiles : aDentries;	/* min */
+	ablocks = afiles * (AFS_FIRSTCSIZE / 1024);
+	/* ablocks is reported in 1K blocks */
+	code = afs_InitMemCache(afiles, AFS_FIRSTCSIZE, aflags);
+	if (code != 0) {
+	    afs_warn("afsd: memory cache too large for available memory.\n");
+	    afs_warn("afsd: AFS files cannot be accessed.\n\n");
+	    dcacheDisabled = 1;
+	    afiles = ablocks = 0;
+	} else
+	    afs_warn("Memory cache: Allocating %d dcache entries...",
+		   aDentries);
+    } else {
+	cacheDiskType = AFS_FCACHE_TYPE_UFS;
+	afs_cacheType = &afs_UfsCacheOps;
+    }
 }
 
 /*!
@@ -3348,7 +3434,7 @@ afs_MakeShadowDir(struct vcache *avc, struct dcache *adc)
     ReleaseWriteLock(&afs_xdcache);
 
     /* Alloc a 4k block. */
-    data = (char *) afs_osi_Alloc(4096);
+    data = afs_osi_Alloc(4096);
     if (!data) {
 	afs_warn("afs_MakeShadowDir: could not alloc data\n");
 	ret_code = ENOMEM;
diff --git a/src/afs/afs_disconnected.c b/src/afs/afs_disconnected.c
index d07df60..a587538 100644
--- a/src/afs/afs_disconnected.c
+++ b/src/afs/afs_disconnected.c
@@ -71,12 +71,14 @@ afs_FindDCacheByFid(struct VenusFid *afid)
     ObtainWriteLock(&afs_xdcache, 758);
     for (index = afs_dvhashTbl[i]; index != NULLIDX;) {
 	if (afs_indexUnique[index] == afid->Fid.Unique) {
-	    tdc = afs_GetDSlot(index, NULL);
-	    ReleaseReadLock(&tdc->tlock);
-	    if (!FidCmp(&tdc->f.fid, afid)) {
-		break;		/* leaving refCount high for caller */
+	    tdc = afs_GetValidDSlot(index);
+	    if (tdc) {
+		ReleaseReadLock(&tdc->tlock);
+		if (!FidCmp(&tdc->f.fid, afid)) {
+		    break;		/* leaving refCount high for caller */
+		}
+		afs_PutDCache(tdc);
 	    }
-	    afs_PutDCache(tdc);
 	}
 	index = afs_dvnextTbl[index];
     }
@@ -563,7 +565,7 @@ afs_ProcessOpRename(struct vcache *avc, struct vrequest *areq)
     old_pdir_fid.Fid.Unique = avc->f.oldParent.unique;
 
     /* Get old name. */
-    old_name = (char *) afs_osi_Alloc(AFSNAMEMAX);
+    old_name = afs_osi_Alloc(AFSNAMEMAX);
     if (!old_name) {
 	/* printf("afs_ProcessOpRename: Couldn't alloc space for old name.\n"); */
 	return ENOMEM;
@@ -575,7 +577,7 @@ afs_ProcessOpRename(struct vcache *avc, struct vrequest *areq)
     }
 
     /* Alloc data first. */
-    new_name = (char *) afs_osi_Alloc(AFSNAMEMAX);
+    new_name = afs_osi_Alloc(AFSNAMEMAX);
     if (!new_name) {
 	/* printf("afs_ProcessOpRename: Couldn't alloc space for new name.\n"); */
 	code = ENOMEM;
@@ -853,7 +855,7 @@ afs_ProcessOpCreate(struct vcache *avc, struct vrequest *areq,
     ObtainWriteLock(&afs_xdcache, 743);
     for (index = afs_dvhashTbl[hash]; index != NULLIDX; index = hash) {
         hash = afs_dvnextTbl[index];
-        tdc = afs_GetDSlot(index, NULL);
+        tdc = afs_GetValidDSlot(index);
         ReleaseReadLock(&tdc->tlock);
 	if (afs_indexUnique[index] == avc->f.fid.Fid.Unique) {
             if (!FidCmp(&tdc->f.fid, &avc->f.fid)) {
diff --git a/src/afs/afs_dynroot.c b/src/afs/afs_dynroot.c
index 24b8140..1177fbe 100644
--- a/src/afs/afs_dynroot.c
+++ b/src/afs/afs_dynroot.c
@@ -347,6 +347,7 @@ afs_RebuildDynroot(void)
 	}
 	dotLen = strlen(c->cellName) + 2;
 	dotCell = afs_osi_Alloc(dotLen);
+	osi_Assert(dotCell != NULL);
 	strcpy(dotCell, ".");
 	afs_strcat(dotCell, c->cellName);
 
@@ -365,6 +366,7 @@ afs_RebuildDynroot(void)
 
 	dotLen = strlen(ca->alias) + 2;
 	dotCell = afs_osi_Alloc(dotLen);
+	osi_Assert(dotCell != NULL);
 	strcpy(dotCell, ".");
 	afs_strcat(dotCell, ca->alias);
 
@@ -385,6 +387,7 @@ afs_RebuildDynroot(void)
 
     dirSize = (curPage + 1) * AFS_PAGESIZE;
     newDir = afs_osi_Alloc(dirSize);
+    osi_Assert(newDir != NULL);
 
     /*
      * Now actually construct the directory.
@@ -424,6 +427,7 @@ afs_RebuildDynroot(void)
 
 	dotLen = strlen(c->cellName) + 2;
 	dotCell = afs_osi_Alloc(dotLen);
+	osi_Assert(dotCell != NULL);
 	strcpy(dotCell, ".");
 	afs_strcat(dotCell, c->cellName);
 	afs_dynroot_addDirEnt(dirHeader, &curPage, &curChunk, c->cellName,
@@ -443,6 +447,7 @@ afs_RebuildDynroot(void)
 
 	dotLen = strlen(ca->alias) + 2;
 	dotCell = afs_osi_Alloc(dotLen);
+	osi_Assert(dotCell != NULL);
 	strcpy(dotCell, ".");
 	afs_strcat(dotCell, ca->alias);
 	afs_dynroot_addDirEnt(dirHeader, &curPage, &curChunk, ca->alias,
@@ -481,6 +486,7 @@ afs_RebuildDynrootMount(void)
     struct DirHeader *dirHeader;
 
     newDir = afs_osi_Alloc(AFS_PAGESIZE);
+    osi_Assert(newDir != NULL);
 
     /*
      * Now actually construct the directory.
@@ -648,6 +654,7 @@ afs_DynrootNewVnode(struct vcache *avc, struct AFSFetchStatus *status)
 	    if (ts) {
 		linklen = strlen(ts->target);
 		avc->linkData = afs_osi_Alloc(linklen + 1);
+		osi_Assert(avc->linkData != NULL);
 		strcpy(avc->linkData, ts->target);
 
 		status->Length = linklen;
@@ -696,6 +703,7 @@ afs_DynrootNewVnode(struct vcache *avc, struct AFSFetchStatus *status)
 		int namelen = strlen(realName);
 		linklen = rw + namelen;
 		avc->linkData = afs_osi_Alloc(linklen + 1);
+		osi_Assert(avc->linkData != NULL);
 		strcpy(avc->linkData, rw ? "." : "");
 		afs_strcat(avc->linkData, realName);
 	    }
@@ -718,6 +726,7 @@ afs_DynrootNewVnode(struct vcache *avc, struct AFSFetchStatus *status)
 	    bp = afs_cv2string(&tbuf[CVBS], avc->f.fid.Fid.Unique);
 	    linklen = 2 + namelen + strlen(bp);
 	    avc->linkData = afs_osi_Alloc(linklen + 1);
+	    osi_Assert(avc->linkData != NULL);
 	    strcpy(avc->linkData, "%");
 	    afs_strcat(avc->linkData, c->cellName);
 	    afs_strcat(avc->linkData, ":");
@@ -741,6 +750,7 @@ afs_DynrootNewVnode(struct vcache *avc, struct AFSFetchStatus *status)
 	    namelen = strlen(c->cellName);
 	    linklen = 1 + namelen + 10;
 	    avc->linkData = afs_osi_Alloc(linklen + 1);
+	    osi_Assert(avc->linkData != NULL);
 	    strcpy(avc->linkData, rw ? "%" : "#");
 	    afs_strcat(avc->linkData, c->cellName);
 	    afs_strcat(avc->linkData, ":root.cell");
@@ -881,11 +891,14 @@ afs_DynrootVOPSymlink(struct vcache *avc, afs_ucred_t *acred,
 
     /* Doesn't already exist -- go ahead and create it */
     tps = afs_osi_Alloc(sizeof(*tps));
+    osi_Assert(tps != NULL);
     tps->index = afs_dynSymlinkIndex++;
     tps->next = afs_dynSymlinkBase;
     tps->name = afs_osi_Alloc(strlen(aname) + 1);
+    osi_Assert(tps->name != NULL);
     strcpy(tps->name, aname);
     tps->target = afs_osi_Alloc(strlen(atargetName) + 1);
+    osi_Assert(tps->target != NULL);
     strcpy(tps->target, atargetName);
     afs_dynSymlinkBase = tps;
     ReleaseWriteLock(&afs_dynSymlinkLock);
diff --git a/src/afs/afs_exporter.c b/src/afs/afs_exporter.c
index 4bc777a..891b11b 100644
--- a/src/afs/afs_exporter.c
+++ b/src/afs/afs_exporter.c
@@ -35,7 +35,8 @@ exporter_add(afs_int32 size, struct exporterops *ops, afs_int32 state,
 	LOCK_INIT(&afs_xexp, "afs_xexp");
     }
     length = (size ? size : sizeof(struct afs_exporter));
-    ex = (struct afs_exporter *)afs_osi_Alloc(length);
+    ex = afs_osi_Alloc(length);
+    osi_Assert(ex != NULL);
     memset(ex, 0, length);
     ObtainWriteLock(&afs_xexp, 308);
     for (op = root_exported; op; op = op->exp_next) {
diff --git a/src/afs/afs_fetchstore.c b/src/afs/afs_fetchstore.c
index 3473646..6746f1b 100644
--- a/src/afs/afs_fetchstore.c
+++ b/src/afs/afs_fetchstore.c
@@ -540,6 +540,7 @@ afs_CacheStoreDCaches(struct vcache *avc, struct dcache **dclist,
 
     if (!code) {
 	code = (*ops->close)(rock, OutStatus, doProcessFS);
+	/* if this succeeds, dv has been bumped. */
 	if (*doProcessFS) {
 	    hadd32(*anewDV, 1);
 	}
@@ -547,6 +548,11 @@ afs_CacheStoreDCaches(struct vcache *avc, struct dcache **dclist,
     }
     if (ops)
 	code = (*ops->destroy)(&rock, code);
+
+    /* if we errored, can't trust this. */
+    if (code)
+	*doProcessFS = 0;
+
     return code;
 }
 
diff --git a/src/afs/afs_icl.c b/src/afs/afs_icl.c
index 7b99e90..759342b 100644
--- a/src/afs/afs_icl.c
+++ b/src/afs/afs_icl.c
@@ -931,8 +931,8 @@ afs_icl_LogUse(struct afs_icl_log *logp)
 	    /* we weren't passed in a hint and it wasn't set */
 	    logp->logSize = ICL_DEFAULT_LOGSIZE;
 	}
-	logp->datap =
-	    (afs_int32 *) afs_osi_Alloc(sizeof(afs_int32) * logp->logSize);
+	logp->datap = afs_osi_Alloc(sizeof(afs_int32) * logp->logSize);
+	osi_Assert(logp->datap != NULL);
 #ifdef	KERNEL_HAVE_PIN
 	pin((char *)logp->datap, sizeof(afs_int32) * logp->logSize);
 #endif
@@ -979,8 +979,8 @@ afs_icl_LogSetSize(struct afs_icl_log *logp, afs_int32 logSize)
 #ifdef	KERNEL_HAVE_PIN
 	unpin((char *)logp->datap, sizeof(afs_int32) * logp->logSize);
 #endif
-	logp->datap =
-	    (afs_int32 *) afs_osi_Alloc(sizeof(afs_int32) * logSize);
+	logp->datap = afs_osi_Alloc(sizeof(afs_int32) * logSize);
+	osi_Assert(logp->datap != NULL);
 #ifdef	KERNEL_HAVE_PIN
 	pin((char *)logp->datap, sizeof(afs_int32) * logSize);
 #endif
@@ -1170,6 +1170,7 @@ afs_icl_CreateSetWithFlags(char *name, struct afs_icl_log *baseLogp,
     strcpy(setp->name, name);
     setp->nevents = ICL_DEFAULTEVENTS;
     setp->eventFlags = afs_osi_Alloc(ICL_DEFAULTEVENTS);
+    osi_Assert(setp->eventFlags != NULL);
 #ifdef	KERNEL_HAVE_PIN
     pin((char *)setp->eventFlags, ICL_DEFAULTEVENTS);
 #endif
diff --git a/src/afs/afs_init.c b/src/afs/afs_init.c
index 748531f..431d89d 100644
--- a/src/afs/afs_init.c
+++ b/src/afs/afs_init.c
@@ -141,7 +141,8 @@ afs_CacheInit(afs_int32 astatSize, afs_int32 afiles, afs_int32 ablocks,
     else if (aVolumes > 32767)
 	aVolumes = 32767;
 
-    tv = (struct volume *)afs_osi_Alloc(aVolumes * sizeof(struct volume));
+    tv = afs_osi_Alloc(aVolumes * sizeof(struct volume));
+    osi_Assert(tv != NULL);
     for (i = 0; i < aVolumes - 1; i++)
 	tv[i].next = &tv[i + 1];
     tv[aVolumes - 1].next = NULL;
@@ -533,8 +534,10 @@ afs_ResourceInit(int preallocs)
 	afs_resourceinit_flag = 1;
 	for (i = 0; i < NFENTRIES; i++)
 	    fvTable[i] = 0;
-	for (i = 0; i < MAXNUMSYSNAMES; i++)
+	for (i = 0; i < MAXNUMSYSNAMES; i++) {
 	    afs_sysnamelist[i] = afs_osi_Alloc(MAXSYSNAME);
+	    osi_Assert(afs_sysnamelist[i] != NULL);
+	}
 	afs_sysname = afs_sysnamelist[0];
 	strcpy(afs_sysname, SYS_NAME);
 	afs_sysnamecount = 1;
@@ -721,11 +724,6 @@ shutdown_cache(void)
 void
 shutdown_vnodeops(void)
 {
-#if !defined(AFS_SGI_ENV) && !defined(AFS_SUN5_ENV)
-    struct buf *afs_bread_freebp = 0;
-#endif
-
-
     AFS_STATCNT(shutdown_vnodeops);
     if (afs_cold_shutdown) {
 #ifndef	AFS_SUN5_ENV		/* XXX */
@@ -734,9 +732,6 @@ shutdown_vnodeops(void)
 #ifndef AFS_LINUX20_ENV
 	afs_rd_stash_i = 0;
 #endif
-#if !defined(AFS_SGI_ENV) && !defined(AFS_SUN5_ENV)
-	afs_bread_freebp = 0;
-#endif
 	shutdown_mariner();
     }
 }
diff --git a/src/afs/afs_memcache.c b/src/afs/afs_memcache.c
index 51b7561..23513a8 100644
--- a/src/afs/afs_memcache.c
+++ b/src/afs/afs_memcache.c
@@ -35,8 +35,9 @@ afs_InitMemCache(int blkCount, int blkSize, int flags)
 	memCacheBlkSize = blkSize;
 
     memMaxBlkNumber = blkCount;
-    memCache = (struct memCacheEntry *)
+    memCache =
 	afs_osi_Alloc(memMaxBlkNumber * sizeof(struct memCacheEntry));
+    osi_Assert(memCache != NULL);
 
     for (index = 0; index < memMaxBlkNumber; index++) {
 	char *blk;
@@ -52,7 +53,8 @@ afs_InitMemCache(int blkCount, int blkSize, int flags)
 #if defined(AFS_HAVE_VXFS)
     afs_InitDualFSCacheOps((struct vnode *)0);
 #endif
-
+    for (index = 0; index < blkCount; index++)
+	afs_InitCacheFile(NULL, 0);
     return 0;
 
   nomem:
diff --git a/src/afs/afs_nfsclnt.c b/src/afs/afs_nfsclnt.c
index 782ce7f..b8bf179 100644
--- a/src/afs/afs_nfsclnt.c
+++ b/src/afs/afs_nfsclnt.c
@@ -76,7 +76,8 @@ afs_GetNfsClientPag(afs_int32 uid, afs_uint32 host)
 	    return np;
 	}
     }
-    np = (struct nfsclientpag *)afs_osi_Alloc(sizeof(struct nfsclientpag));
+    np = afs_osi_Alloc(sizeof(struct nfsclientpag));
+    osi_Assert(np != NULL);
     memset(np, 0, sizeof(struct nfsclientpag));
     /* Copy the necessary afs_exporter fields */
     memcpy((char *)np, (char *)afs_nfsexporter, sizeof(struct afs_exporter));
@@ -479,6 +480,7 @@ afs_nfsclient_sysname(struct nfsclientpag *np, char *inname,
 	    }
 	for(count=0; count < *num;++count) {
 	    np->sysname[count]= afs_osi_Alloc(MAXSYSNAME);
+	    osi_Assert(np->sysname[count] != NULL);
 	}
 	cp = inname;
 	for(count=0; count < *num;++count) {
diff --git a/src/afs/afs_osi_alloc.c b/src/afs/afs_osi_alloc.c
index 3039995..1822acc 100644
--- a/src/afs/afs_osi_alloc.c
+++ b/src/afs/afs_osi_alloc.c
@@ -168,7 +168,7 @@ osi_AllocLargeSpace(size_t size)
 	char *p;
 
 	afs_stats_cmperf.LargeBlocksAlloced++;
-	p = (char *)afs_osi_Alloc(AFS_LRALLOCSIZ);
+	p = afs_osi_Alloc(AFS_LRALLOCSIZ);
 #ifdef  KERNEL_HAVE_PIN
 	/*
 	 * Need to pin this memory since under heavy conditions this memory
diff --git a/src/afs/afs_osi_pag.c b/src/afs/afs_osi_pag.c
index 20cee62..efce229 100644
--- a/src/afs/afs_osi_pag.c
+++ b/src/afs/afs_osi_pag.c
@@ -481,7 +481,7 @@ afs_InitReq(struct vrequest *av, afs_ucred_t *acred)
 #elif defined(AFS_SUN510_ENV)
         av->uid = crgetruid(acred);
 #else
-	av->uid = afs_cr_uid(acred);	/* default when no pag is set */
+	av->uid = afs_cr_ruid(acred);	/* default when no pag is set */
 #endif
     }
     return 0;
diff --git a/src/afs/afs_osidnlc.c b/src/afs/afs_osidnlc.c
index d2a6616..0309e9a 100644
--- a/src/afs/afs_osidnlc.c
+++ b/src/afs/afs_osidnlc.c
@@ -190,10 +190,9 @@ struct vcache *
 osi_dnlc_lookup(struct vcache *adp, char *aname, int locktype)
 {
     struct vcache *tvc;
-    int LRUme;
     unsigned int key, skey;
     char *ts = aname;
-    struct nc *tnc, *tnc1 = 0;
+    struct nc *tnc;
     int safety;
 #ifdef AFS_DARWIN80_ENV
     vnode_t tvp;
@@ -218,7 +217,6 @@ osi_dnlc_lookup(struct vcache *adp, char *aname, int locktype)
 	if ( /* (tnc->key == key)  && */ (tnc->dirp == adp)
 	    && (!strcmp((char *)tnc->name, aname))) {
 	    tvc = tnc->vp;
-	    tnc1 = tnc;
 	    break;
 	} else if (tnc->next == nameHash[skey]) {	/* end of list */
 	    break;
@@ -232,7 +230,6 @@ osi_dnlc_lookup(struct vcache *adp, char *aname, int locktype)
 	}
     }
 
-    LRUme = 0;			/* (tnc != nameHash[skey]); */
     ReleaseReadLock(&afs_xdnlc);
 
     if (!tvc) {
diff --git a/src/afs/afs_pag_call.c b/src/afs/afs_pag_call.c
index 9d23e90..39f78b1 100644
--- a/src/afs/afs_pag_call.c
+++ b/src/afs/afs_pag_call.c
@@ -113,8 +113,10 @@ afspag_Init(afs_int32 nfs_server_addr)
 
     afs_resourceinit_flag = 1;
     afs_nfs_server_addr = nfs_server_addr;
-    for (i = 0; i < MAXNUMSYSNAMES; i++)
+    for (i = 0; i < MAXNUMSYSNAMES; i++) {
 	afs_sysnamelist[i] = afs_osi_Alloc(MAXSYSNAME);
+        osi_Assert(afs_sysnamelist[i] != NULL);
+    }
     afs_sysname = afs_sysnamelist[0];
     strcpy(afs_sysname, SYS_NAME);
     afs_sysnamecount = 1;
diff --git a/src/afs/afs_pag_cred.c b/src/afs/afs_pag_cred.c
index e35cc82..48a50ec 100644
--- a/src/afs/afs_pag_cred.c
+++ b/src/afs/afs_pag_cred.c
@@ -45,10 +45,10 @@ afspag_GetCell(char *acell)
     }
 
     if (!tcell) {
-	tcell = (struct afspag_cell *)afs_osi_Alloc(sizeof(struct afspag_cell));
+	tcell = afs_osi_Alloc(sizeof(struct afspag_cell));
 	if (!tcell)
 	    goto out;
-	tcell->cellname = (char *)afs_osi_Alloc(strlen(acell) + 1);
+	tcell->cellname = afs_osi_Alloc(strlen(acell) + 1);
 	if (!tcell->cellname) {
 	    afs_osi_Free(tcell, sizeof(struct afspag_cell));
 	    tcell = 0;
@@ -251,8 +251,7 @@ SPAGCB_GetCreds(struct rx_call *a_call, afs_int32 a_uid,
 	return UAESRCH;
     }
 
-    a_creds->CredInfos_val =
-	(CredInfo *)afs_osi_Alloc(count * sizeof(CredInfo));
+    a_creds->CredInfos_val = afs_osi_Alloc(count * sizeof(CredInfo));
     if (!a_creds->CredInfos_val)
 	goto out;
     a_creds->CredInfos_len = count;
diff --git a/src/afs/afs_pioctl.c b/src/afs/afs_pioctl.c
index 440d617..d96a842 100644
--- a/src/afs/afs_pioctl.c
+++ b/src/afs/afs_pioctl.c
@@ -1937,6 +1937,8 @@ DECL_PIOCTL(PGetVolumeStatus)
     struct rx_connection *rxconn;
     XSTATS_DECLS;
 
+    osi_Assert(offLineMsg != NULL);
+    osi_Assert(motd != NULL);
     AFS_STATCNT(PGetVolumeStatus);
     if (!avc) {
 	code = EINVAL;
@@ -3481,7 +3483,10 @@ DECL_PIOCTL(PFlushVolumeData)
     for (i = 0; i < afs_cacheFiles; i++) {
 	if (!(afs_indexFlags[i] & IFEverUsed))
 	    continue;		/* never had any data */
-	tdc = afs_GetDSlot(i, NULL);
+	tdc = afs_GetValidDSlot(i);
+	if (!tdc) {
+	    continue;
+	}
 	if (tdc->refCount <= 1) {    /* too high, in use by running sys call */
 	    ReleaseReadLock(&tdc->tlock);
 	    if (tdc->f.fid.Fid.Volume == volume && tdc->f.fid.Cell == cell) {
@@ -3824,7 +3829,8 @@ ReSortCells(int s, afs_int32 * l, int vlonly)
 
     if (vlonly) {
 	afs_int32 *p;
-	p = (afs_int32 *) afs_osi_Alloc(sizeof(afs_int32) * (s + 1));
+	p = afs_osi_Alloc(sizeof(afs_int32) * (s + 1));
+        osi_Assert(p != NULL);
 	p[0] = s;
 	memcpy(p + 1, l, s * sizeof(afs_int32));
 	afs_TraverseCells(&ReSortCells_cb, p);
@@ -4848,8 +4854,8 @@ DECL_PIOCTL(PRxStatPeer)
 
 DECL_PIOCTL(PPrefetchFromTape)
 {
-    afs_int32 code, code1;
-    afs_int32 bytes, outval;
+    afs_int32 code;
+    afs_int32 outval;
     struct afs_conn *tc;
     struct rx_call *tcall;
     struct AFSVolSync tsync;
@@ -4892,11 +4898,11 @@ DECL_PIOCTL(PPrefetchFromTape)
 		StartRXAFS_FetchData(tcall, (struct AFSFid *)&tvc->f.fid.Fid, 0,
 				     0);
 	    if (!code) {
-		bytes = rx_Read(tcall, (char *)&outval, sizeof(afs_int32));
+		rx_Read(tcall, (char *)&outval, sizeof(afs_int32));
 		code =
 		    EndRXAFS_FetchData(tcall, &OutStatus, &CallBack, &tsync);
 	    }
-	    code1 = rx_EndCall(tcall, code);
+	    code = rx_EndCall(tcall, code);
 	    RX_AFS_GLOCK();
 	} else
 	    code = -1;
@@ -5082,6 +5088,7 @@ DECL_PIOCTL(PCallBackAddr)
     }
 
     addrs = afs_osi_Alloc(srvAddrCount * sizeof(*addrs));
+    osi_Assert(addrs != NULL);
     j = 0;
     for (i = 0; i < NSERVERS; i++) {
 	for (sa = afs_srvAddrs[i]; sa; sa = sa->next_bkt) {
diff --git a/src/afs/afs_prototypes.h b/src/afs/afs_prototypes.h
index 6e8a87b..f411ddd 100644
--- a/src/afs/afs_prototypes.h
+++ b/src/afs/afs_prototypes.h
@@ -258,8 +258,7 @@ extern void afs_FlushDCache(struct dcache *adc);
 extern void shutdown_dcache(void);
 extern void afs_CacheTruncateDaemon(void);
 extern afs_int32 afs_fsfragsize;
-extern struct dcache *afs_MemGetDSlot(afs_int32 aslot,
-				      struct dcache *tmpdc);
+extern struct dcache *afs_MemGetDSlot(afs_int32 aslot, int needvalid);
 extern struct dcache *afs_GetDCache(struct vcache *avc,
 				    afs_size_t abyte,
 				    struct vrequest *areq,
@@ -281,8 +280,7 @@ extern void afs_TryToSmush(struct vcache *avc,
 extern void updateV2DC(int lockVc, struct vcache *v, struct dcache *d,
 		       int src);
 extern void afs_WriteThroughDSlots(void);
-extern struct dcache *afs_UFSGetDSlot(afs_int32 aslot,
-				      struct dcache *tmpdc);
+extern struct dcache *afs_UFSGetDSlot(afs_int32 aslot, int needvalid);
 extern int afs_WriteDCache(struct dcache *adc, int atime);
 extern int afs_wakeup(struct vcache *avc);
 extern int afs_InitCacheFile(char *afile, ino_t ainode);
@@ -853,9 +851,18 @@ extern struct server *afs_GetServer(afs_uint32 * aserver, afs_int32 nservers,
 extern void afs_GetCapabilities(struct server *ts);
 extern void ForceAllNewConnections(void);
 extern void afs_MarkServerUpOrDown(struct srvAddr *sa, int a_isDown);
-extern afs_int32 afs_ServerDown(struct srvAddr *sa);
+extern afs_int32 afs_ServerDown(struct srvAddr *sa, int code);
 extern void afs_CountServers(void);
 extern void afs_CheckServers(int adown, struct cell *acellp);
+extern void afs_LoopServers(int adown, struct cell *acellp, int vlalso,
+			    void (*func1) (struct rx_connection **rxconns,
+					   int nconns, int nservers,
+					   struct afs_conn **conns,
+					   struct srvAddr **addrs),
+			    void (*func2) (struct rx_connection **rxconns,
+					   int nconns, int nservers,
+					   struct afs_conn **conns,
+					   struct srvAddr **addrs));
 extern unsigned int afs_random(void);
 extern int afs_randomMod15(void);
 extern int afs_randomMod127(void);
@@ -968,7 +975,8 @@ extern void afs_MarkUserExpired(afs_int32 pag);
 
 /* afs_util.c */
 extern afs_int32 afs_strtoi_r(const char *str, char **endptr, afs_uint32 *ret);
-extern afs_int32 afs_calc_inum (afs_int32 volume, afs_int32 vnode);
+extern afs_int32 afs_calc_inum(afs_int32 cell, afs_int32 volume,
+                               afs_int32 vnode);
 #ifndef afs_cv2string
 extern char *afs_cv2string(char *ttp, afs_uint32 aval);
 #endif
@@ -989,7 +997,7 @@ extern char *afs_strrchr(char *s, int c);
 #endif
 extern char *afs_strdup(char *s);
 extern void print_internet_address(char *preamble, struct srvAddr *sa,
-				   char *postamble, int flag);
+				   char *postamble, int flag, int code);
 extern afs_int32 afs_data_pointer_to_int32(const void *p);
 
 extern void afs_CheckLocks(void);
@@ -1033,6 +1041,9 @@ extern void afs_FlushReclaimedVcaches(void);
 void afs_vcacheInit(int astatSize);
 extern struct vcache *afs_FindVCache(struct VenusFid *afid, afs_int32 * retry,
 				     afs_int32 flag);
+extern void afs_BadFetchStatus(struct afs_conn *tc);
+extern int afs_CheckFetchStatus(struct afs_conn *tc,
+                                struct AFSFetchStatus *status);
 extern afs_int32 afs_FetchStatus(struct vcache *avc, struct VenusFid *afid,
 				 struct vrequest *areq,
 				 struct AFSFetchStatus *Outsp);
diff --git a/src/afs/afs_segments.c b/src/afs/afs_segments.c
index e5c9eb2..192a3d4 100644
--- a/src/afs/afs_segments.c
+++ b/src/afs/afs_segments.c
@@ -169,7 +169,6 @@ afs_StoreAllSegments(struct vcache *avc, struct vrequest *areq,
     afs_hyper_t newDV, oldDV;	/* DV when we start, and finish, respectively */
     struct dcache **dcList;
     unsigned int i, j, minj, moredata, high, off;
-    afs_size_t tlen;
     afs_size_t maxStoredLength;	/* highest offset we've written to server. */
     int safety, marineronce = 0;
 
@@ -238,7 +237,6 @@ afs_StoreAllSegments(struct vcache *avc, struct vrequest *areq,
     origCBs = afs_allCBs;
 
     maxStoredLength = 0;
-    tlen = avc->f.m.Length;
     minj = 0;
 
     do {
@@ -254,7 +252,12 @@ afs_StoreAllSegments(struct vcache *avc, struct vrequest *areq,
 	for (j = 0; index != NULLIDX;) {
 	    if ((afs_indexFlags[index] & IFDataMod)
 		&& (afs_indexUnique[index] == avc->f.fid.Fid.Unique)) {
-		tdc = afs_GetDSlot(index, 0);	/* refcount+1. */
+		tdc = afs_GetValidDSlot(index);	/* refcount+1. */
+		if (!tdc) {
+		    ReleaseWriteLock(&afs_xdcache);
+		    code = EIO;
+		    goto done;
+		}
 		ReleaseReadLock(&tdc->tlock);
 		if (!FidCmp(&tdc->f.fid, &avc->f.fid) && tdc->f.chunk >= minj) {
 		    off = tdc->f.chunk - minj;
@@ -317,6 +320,7 @@ afs_StoreAllSegments(struct vcache *avc, struct vrequest *areq,
 	minj += NCHUNKSATONCE;
     } while (!code && moredata);
 
+ done:
     UpgradeSToWLock(&avc->lock, 29);
 
     /* send a trivial truncation store if did nothing else */
@@ -358,7 +362,8 @@ afs_StoreAllSegments(struct vcache *avc, struct vrequest *areq,
 		 index != NULLIDX && safety < afs_cacheFiles + 2;) {
 
 		if (afs_indexUnique[index] == avc->f.fid.Fid.Unique) {
-		    tdc = afs_GetDSlot(index, 0);
+		    tdc = afs_GetValidDSlot(index);
+		    if (!tdc) osi_Panic("afs_StoreAllSegments tdc dv");
 		    ReleaseReadLock(&tdc->tlock);
 
 		    if (!FidCmp(&tdc->f.fid, &avc->f.fid)
@@ -413,6 +418,9 @@ afs_StoreAllSegments(struct vcache *avc, struct vrequest *areq,
 			UpgradeSToWLock(&tdc->lock, 678);
 			hset(tdc->f.versionNo, avc->f.m.DataVersion);
 			tdc->dflags |= DFEntryMod;
+			/* DWriting may not have gotten cleared above, if all
+			 * we did was a StoreMini */
+			tdc->f.states &= ~DWriting;
 			ConvertWToSLock(&tdc->lock);
 		    }
 		}
@@ -522,7 +530,8 @@ afs_InvalidateAllSegments(struct vcache *avc)
 
     for (index = afs_dvhashTbl[hash]; index != NULLIDX;) {
 	if (afs_indexUnique[index] == avc->f.fid.Fid.Unique) {
-	    tdc = afs_GetDSlot(index, 0);
+	    tdc = afs_GetValidDSlot(index);
+	    if (!tdc) osi_Panic("afs_InvalidateAllSegments tdc count");
 	    ReleaseReadLock(&tdc->tlock);
 	    if (!FidCmp(&tdc->f.fid, &avc->f.fid))
 		dcListMax++;
@@ -536,7 +545,8 @@ afs_InvalidateAllSegments(struct vcache *avc)
 
     for (index = afs_dvhashTbl[hash]; index != NULLIDX;) {
 	if (afs_indexUnique[index] == avc->f.fid.Fid.Unique) {
-	    tdc = afs_GetDSlot(index, 0);
+	    tdc = afs_GetValidDSlot(index);
+	    if (!tdc) osi_Panic("afs_InvalidateAllSegments tdc store");
 	    ReleaseReadLock(&tdc->tlock);
 	    if (!FidCmp(&tdc->f.fid, &avc->f.fid)) {
 		/* same file? we'll zap it */
@@ -593,7 +603,7 @@ afs_ExtendSegments(struct vcache *avc, afs_size_t alen, struct vrequest *areq)
     struct dcache *tdc;
     void *zeros;
 
-    zeros = (void *) afs_osi_Alloc(AFS_PAGESIZE);
+    zeros = afs_osi_Alloc(AFS_PAGESIZE);
     if (zeros == NULL)
 	return ENOMEM;
     memset(zeros, 0, AFS_PAGESIZE);
@@ -714,7 +724,12 @@ afs_TruncateAllSegments(struct vcache *avc, afs_size_t alen,
     dcCount = 0;
     for (index = afs_dvhashTbl[code]; index != NULLIDX;) {
 	if (afs_indexUnique[index] == avc->f.fid.Fid.Unique) {
-	    tdc = afs_GetDSlot(index, 0);
+	    tdc = afs_GetValidDSlot(index);
+	    if (!tdc) {
+		ReleaseWriteLock(&afs_xdcache);
+		code = EIO;
+		goto done;
+	    }
 	    ReleaseReadLock(&tdc->tlock);
 	    if (!FidCmp(&tdc->f.fid, &avc->f.fid))
 		dcCount++;
@@ -732,7 +747,8 @@ afs_TruncateAllSegments(struct vcache *avc, afs_size_t alen,
 
     for (index = afs_dvhashTbl[code]; index != NULLIDX;) {
 	if (afs_indexUnique[index] == avc->f.fid.Fid.Unique) {
-	    tdc = afs_GetDSlot(index, 0);
+	    tdc = afs_GetValidDSlot(index);
+	    if (!tdc) osi_Panic("afs_TruncateAllSegments tdc");
 	    ReleaseReadLock(&tdc->tlock);
 	    if (!FidCmp(&tdc->f.fid, &avc->f.fid)) {
 		/* same file, and modified, we'll store it back */
@@ -762,6 +778,7 @@ afs_TruncateAllSegments(struct vcache *avc, afs_size_t alen,
 	ObtainSharedLock(&tdc->lock, 672);
 	if (newSize < tdc->f.chunkBytes && newSize < MAX_AFS_UINT32) {
 	    UpgradeSToWLock(&tdc->lock, 673);
+	    tdc->f.states |= DWriting;
 	    tfile = afs_CFileOpen(&tdc->f.inode);
 	    afs_CFileTruncate(tfile, (afs_int32)newSize);
 	    afs_CFileClose(tfile);
@@ -780,6 +797,9 @@ afs_TruncateAllSegments(struct vcache *avc, afs_size_t alen,
 
     osi_Free(tdcArray, dcCount * sizeof(struct dcache *));
 
+    code = 0;
+
+ done:
 #if	(defined(AFS_SUN5_ENV))
     ObtainWriteLock(&avc->vlock, 547);
     if (--avc->activeV == 0 && (avc->vstates & VRevokeWait)) {
@@ -789,5 +809,5 @@ afs_TruncateAllSegments(struct vcache *avc, afs_size_t alen,
     ReleaseWriteLock(&avc->vlock);
 #endif
 
-    return 0;
+    return code;
 }
diff --git a/src/afs/afs_server.c b/src/afs/afs_server.c
index 0bfdce6..8470ca6 100644
--- a/src/afs/afs_server.c
+++ b/src/afs/afs_server.c
@@ -238,7 +238,7 @@ afs_MarkServerUpOrDown(struct srvAddr *sa, int a_isDown)
 
 
 afs_int32
-afs_ServerDown(struct srvAddr *sa)
+afs_ServerDown(struct srvAddr *sa, int code)
 {
     struct server *aserver = sa->server;
 
@@ -248,10 +248,10 @@ afs_ServerDown(struct srvAddr *sa)
     afs_MarkServerUpOrDown(sa, SRVR_ISDOWN);
     if (sa->sa_portal == aserver->cell->vlport)
 	print_internet_address
-	    ("afs: Lost contact with volume location server ", sa, "", 1);
+	    ("afs: Lost contact with volume location server ", sa, "", 1, code);
     else
 	print_internet_address("afs: Lost contact with file server ", sa, "",
-			       1);
+			       1, code);
     return 1;
 }				/*ServerDown */
 
@@ -318,7 +318,7 @@ CheckVLServer(struct srvAddr *sa, struct vrequest *areq)
 	if (tc->srvr == sa) {
 	    afs_MarkServerUpOrDown(sa, 0);
 	    print_internet_address("afs: volume location server ", sa,
-				   " is back up", 2);
+				   " is back up", 2, code);
 	}
     }
 
@@ -507,6 +507,7 @@ ForceAllNewConnections(void)
     }
 
     addrs = afs_osi_Alloc(srvAddrCount * sizeof(*addrs));
+    osi_Assert(addrs != NULL);
     j = 0;
     for (i = 0; i < NSERVERS; i++) {
 	for (sa = afs_srvAddrs[i]; sa; sa = sa->next_bkt) {
@@ -524,27 +525,257 @@ ForceAllNewConnections(void)
     }
 }
 
+static void
+CkSrv_MarkUpDown(struct afs_conn **conns, int nconns, afs_int32 *results)
+{
+    struct srvAddr *sa;
+    struct afs_conn *tc;
+    afs_int32 i;
+
+    for(i = 0; i < nconns; i++){
+	tc = conns[i];
+	sa = tc->srvr;
+
+	if (( results[i] >= 0 ) && (sa->sa_flags & SRVADDR_ISDOWN) &&
+	    (tc->srvr == sa)) {
+	    /* server back up */
+	    print_internet_address("afs: file server ", sa, " is back up", 2,
+			           results[i]);
+
+	    ObtainWriteLock(&afs_xserver, 244);
+	    ObtainWriteLock(&afs_xsrvAddr, 245);
+	    afs_MarkServerUpOrDown(sa, 0);
+	    ReleaseWriteLock(&afs_xsrvAddr);
+	    ReleaseWriteLock(&afs_xserver);
+
+	    if (afs_waitForeverCount) {
+		afs_osi_Wakeup(&afs_waitForever);
+	    }
+	} else {
+	    if (results[i] < 0) {
+		/* server crashed */
+		afs_ServerDown(sa, results[i]);
+		ForceNewConnections(sa);  /* multi homed clients */
+	    }
+	}
+    }
+}
+
+void
+CkSrv_SetTime(struct rx_connection **rxconns, int nconns, int nservers,
+	      struct afs_conn **conns, struct srvAddr **addrs)
+{
+    struct afs_conn *tc;
+    afs_int32 start, end = 0, delta;
+    osi_timeval_t tv;
+    struct srvAddr *sa;
+    afs_int32 *conntimer, *results, *deltas;
+    afs_int32 i = 0;
+    char tbuffer[CVBS];
+
+    conntimer = afs_osi_Alloc(nservers * sizeof (afs_int32));
+    osi_Assert(conntimer != NULL);
+    results = afs_osi_Alloc(nservers * sizeof (afs_int32));
+    osi_Assert(results != NULL);
+    deltas = afs_osi_Alloc(nservers * sizeof (afs_int32));
+    osi_Assert(deltas != NULL);
+
+    /* make sure we're starting from zero */
+    memset(&deltas, 0, sizeof(deltas));
+
+    start = osi_Time();         /* time the gettimeofday call */
+    AFS_GUNLOCK();
+    if ( afs_setTimeHost == NULL ) {
+	multi_Rx(rxconns,nconns)
+	{
+	    tv.tv_sec = tv.tv_usec = 0;
+	    multi_RXAFS_GetTime(
+		(afs_uint32 *)&tv.tv_sec, (afs_uint32 *)&tv.tv_usec);
+	    tc = conns[multi_i];
+	    sa = tc->srvr;
+	    if (conntimer[multi_i] == 1)
+		rx_SetConnDeadTime(tc->id, afs_rx_deadtime);
+	    end = osi_Time();
+	    results[multi_i]=multi_error;
+	    if ((start == end) && !multi_error)
+		deltas[multi_i] = end - tv.tv_sec;
+	} multi_End;
+    } else {			/* find and query setTimeHost only */
+	for ( i = 0 ; i < nservers ; i++ ) {
+	    if ( conns[i] == NULL || conns[i]->srvr == NULL )
+		continue;
+	    if ( conns[i]->srvr->server == afs_setTimeHost ) {
+		tv.tv_sec = tv.tv_usec = 0;
+		results[i] = RXAFS_GetTime(rxconns[i],
+					   (afs_uint32 *)&tv.tv_sec,
+					   (afs_uint32 *)&tv.tv_usec);
+		end = osi_Time();
+		if ((start == end) && !results[i])
+		    deltas[i] = end - tv.tv_sec;
+		break;
+	    }
+	}
+    }
+    AFS_GLOCK();
+
+    if ( afs_setTimeHost == NULL )
+	CkSrv_MarkUpDown(conns, nconns, results);
+    else /* We lack info for other than this host */
+	CkSrv_MarkUpDown(&conns[i], 1, &results[i]);
+
+    /*
+     * If we're supposed to set the time, and the call worked
+     * quickly (same second response) and this is the host we
+     * use for the time and the time is really different, then
+     * really set the time
+     */
+    if (afs_setTime != 0) {
+	for (i=0; i<nconns; i++) {
+	    delta = deltas[i];
+	    tc = conns[i];
+	    sa = tc->srvr;
+
+	    if ((tc->srvr->server == afs_setTimeHost ||
+		 /* Sync only to a server in the local cell */
+		 (afs_setTimeHost == (struct server *)0 &&
+		  afs_IsPrimaryCell(sa->server->cell)))) {
+		/* set the time */
+		char msgbuf[90];  /* strlen("afs: setting clock...") + slop */
+		delta = end - tv.tv_sec;   /* how many secs fast we are */
+
+		afs_setTimeHost = tc->srvr->server;
+		/* see if clock has changed enough to make it worthwhile */
+		if (delta >= AFS_MINCHANGE || delta <= -AFS_MINCHANGE) {
+		    end = osi_Time();
+		    if (delta > AFS_MAXCHANGEBACK) {
+			/* setting clock too far back, just do it a little */
+			tv.tv_sec = end - AFS_MAXCHANGEBACK;
+		    } else {
+			tv.tv_sec = end - delta;
+		    }
+		    afs_osi_SetTime(&tv);
+		    if (delta > 0) {
+			strcpy(msgbuf, "afs: setting clock back ");
+			if (delta > AFS_MAXCHANGEBACK) {
+			    afs_strcat(msgbuf,
+				       afs_cv2string(&tbuffer[CVBS],
+						     AFS_MAXCHANGEBACK));
+			    afs_strcat(msgbuf, " seconds (of ");
+			    afs_strcat(msgbuf,
+				       afs_cv2string(&tbuffer[CVBS],
+						     delta -
+						     AFS_MAXCHANGEBACK));
+			    afs_strcat(msgbuf, ", via ");
+			    print_internet_address(msgbuf, sa,
+						   "); clock is still fast.",
+						   0, 0);
+			} else {
+			    afs_strcat(msgbuf,
+				       afs_cv2string(&tbuffer[CVBS], delta));
+			    afs_strcat(msgbuf, " seconds (via ");
+			    print_internet_address(msgbuf, sa, ").", 0, 0);
+			}
+		    } else {
+			strcpy(msgbuf, "afs: setting clock ahead ");
+			afs_strcat(msgbuf,
+				   afs_cv2string(&tbuffer[CVBS], -delta));
+			afs_strcat(msgbuf, " seconds (via ");
+			print_internet_address(msgbuf, sa, ").", 0, 0);
+		    }
+                    /* We're only going to set it once; why bother looping? */
+		    break;
+		}
+	    }
+	}
+    }
+    afs_osi_Free(conntimer, nservers * sizeof(afs_int32));
+    afs_osi_Free(deltas, nservers * sizeof(afs_int32));
+    afs_osi_Free(results, nservers * sizeof(afs_int32));
+}
+
+void
+CkSrv_GetCaps(struct rx_connection **rxconns, int nconns, int nservers,
+	      struct afs_conn **conns, struct srvAddr **addrs)
+{
+    Capabilities *caps;
+    afs_int32 *results;
+    afs_int32 i;
+    struct server *ts;
+
+    caps = afs_osi_Alloc(nservers * sizeof (Capabilities));
+    osi_Assert(caps != NULL);
+    memset(caps, 0, nservers * sizeof(Capabilities));
+
+    results = afs_osi_Alloc(nservers * sizeof (afs_int32));
+    osi_Assert(results != NULL);
+
+    AFS_GUNLOCK();
+    multi_Rx(rxconns,nconns)
+      {
+	multi_RXAFS_GetCapabilities(&caps[multi_i]);
+	results[multi_i] = multi_error;
+      } multi_End;
+    AFS_GLOCK();
+
+    for ( i = 0 ; i < nconns ; i++ ) {
+	ts = addrs[i]->server;
+	if ( !ts )
+	    continue;
+	ts->capabilities = 0;
+	ts->flags |= SCAPS_KNOWN;
+	if ( results[i] == RXGEN_OPCODE ) {
+	    /* Mark server as up - it responded */
+	    results[i] = 0;
+	    continue;
+	}
+	if ( results[i] >= 0 )
+	    /* we currently handle 32-bits of capabilities */
+	    if (caps[i].Capabilities_len > 0) {
+		ts->capabilities = caps[i].Capabilities_val[0];
+		xdr_free((xdrproc_t)xdr_Capabilities, &caps[i]);
+		caps[i].Capabilities_val = NULL;
+		caps[i].Capabilities_len = 0;
+	    }
+    }
+    CkSrv_MarkUpDown(conns, nconns, results);
+
+    afs_osi_Free(caps, nservers * sizeof(Capabilities));
+    afs_osi_Free(results, nservers * sizeof(afs_int32));
+}
+
 /* check down servers (if adown), or running servers (if !adown) */
 void
 afs_CheckServers(int adown, struct cell *acellp)
 {
+    afs_LoopServers(adown?AFS_LS_DOWN:AFS_LS_UP, acellp, 1, CkSrv_GetCaps,
+		    afs_setTime?CkSrv_SetTime:NULL);
+}
+
+/* adown: AFS_LS_UP   - check only up
+ *        AFS_LS_DOWN - check only down.
+ *        AFS_LS_ALL  - check all */
+void
+afs_LoopServers(int adown, struct cell *acellp, int vlalso,
+		void (*func1) (struct rx_connection **rxconns, int nconns,
+			       int nservers, struct afs_conn **conns,
+			       struct srvAddr **addrs),
+		void (*func2) (struct rx_connection **rxconns, int nconns,
+			       int nservers, struct afs_conn **conns,
+			       struct srvAddr **addrs))
+{
     struct vrequest treq;
     struct server *ts;
     struct srvAddr *sa;
-    struct afs_conn *tc;
+    struct afs_conn *tc = NULL;
     afs_int32 i, j;
     afs_int32 code;
-    afs_int32 start, end = 0, delta;
-    osi_timeval_t tv;
     struct unixuser *tu;
-    char tbuffer[CVBS];
     int srvAddrCount;
     struct srvAddr **addrs;
     struct afs_conn **conns;
     int nconns;
     struct rx_connection **rxconns;
-    afs_int32 *conntimer, *deltas, *results;
-    Capabilities *caps = NULL;
+    afs_int32 *conntimer, *results;
 
     AFS_STATCNT(afs_CheckServers);
 
@@ -573,6 +804,7 @@ afs_CheckServers(int adown, struct cell *acellp)
     }
 
     addrs = afs_osi_Alloc(srvAddrCount * sizeof(*addrs));
+    osi_Assert(addrs != NULL);
     j = 0;
     for (i = 0; i < NSERVERS; i++) {
 	for (sa = afs_srvAddrs[i]; sa; sa = sa->next_bkt) {
@@ -585,19 +817,18 @@ afs_CheckServers(int adown, struct cell *acellp)
     ReleaseReadLock(&afs_xsrvAddr);
     ReleaseReadLock(&afs_xserver);
 
-    conns = (struct afs_conn **)afs_osi_Alloc(j * sizeof(struct afs_conn *));
-    rxconns = (struct rx_connection **)afs_osi_Alloc(j * sizeof(struct rx_connection *));
-    conntimer = (afs_int32 *)afs_osi_Alloc(j * sizeof (afs_int32));
-    deltas = (afs_int32 *)afs_osi_Alloc(j * sizeof (afs_int32));
-    results = (afs_int32 *)afs_osi_Alloc(j * sizeof (afs_int32));
-
-    caps = (Capabilities *)afs_osi_Alloc(j * sizeof (Capabilities));
-    memset(caps, 0, j * sizeof(Capabilities));
+    conns = afs_osi_Alloc(j * sizeof(struct afs_conn *));
+    osi_Assert(conns != NULL);
+    rxconns = afs_osi_Alloc(j * sizeof(struct rx_connection *));
+    osi_Assert(rxconns != NULL);
+    conntimer = afs_osi_Alloc(j * sizeof (afs_int32));
+    osi_Assert(conntimer != NULL);
+    results = afs_osi_Alloc(j * sizeof (afs_int32));
+    osi_Assert(results != NULL);
 
     for (i = 0; i < j; i++) {
 	struct rx_connection *rxconn;
 
-	deltas[i] = 0;
 	sa = addrs[i];
 	ts = sa->server;
 	if (!ts)
@@ -609,13 +840,14 @@ afs_CheckServers(int adown, struct cell *acellp)
 	if (acellp && acellp != ts->cell)
 	    continue;
 
-	if ((!adown && (sa->sa_flags & SRVADDR_ISDOWN))
-	    || (adown && !(sa->sa_flags & SRVADDR_ISDOWN)))
+	if (((adown==AFS_LS_DOWN) && !(sa->sa_flags & SRVADDR_ISDOWN))
+	    || ((adown==AFS_LS_UP) && (sa->sa_flags & SRVADDR_ISDOWN)))
 	    continue;
 
 	/* check vlserver with special code */
 	if (sa->sa_portal == AFS_VLPORT) {
-	    CheckVLServer(sa, &treq);
+	    if (vlalso)
+		CheckVLServer(sa, &treq);
 	    continue;
 	}
 
@@ -646,165 +878,15 @@ afs_CheckServers(int adown, struct cell *acellp)
 	    afs_PutConn(tc, rxconn, SHARED_LOCK);
     } /* Outer loop over addrs */
 
-    AFS_GUNLOCK();
-    multi_Rx(rxconns,nconns)
-      {
-	multi_RXAFS_GetCapabilities(&caps[multi_i]);
-	results[multi_i] = multi_error;
-      } multi_End;
-    AFS_GLOCK();
+    (*func1)(rxconns, nconns, j, conns, addrs);
 
-    for ( i = 0 ; i < nconns ; i++ ) {
-	ts = addrs[i]->server;
-	if ( !ts )
-	    continue;
-	ts->capabilities = 0;
-	ts->flags |= SCAPS_KNOWN;
-	if ( results[i] == RXGEN_OPCODE ) {
-	    /* Mark server as up - it responded */
-	    results[i] = 0;
-	    continue;
-	}
-	if ( results[i] >= 0 )
-	    /* we currently handle 32-bits of capabilities */
-	    if (caps[i].Capabilities_len > 0) {
-		ts->capabilities = caps[i].Capabilities_val[0];
-		xdr_free((xdrproc_t)xdr_Capabilities, &caps[i]);
-		caps[i].Capabilities_val = NULL;
-		caps[i].Capabilities_len = 0;
-	    }
-    }
-
-    if ( afs_setTime != 0 ) {
-	start = osi_Time();         /* time the gettimeofday call */
-	AFS_GUNLOCK();
-	if ( afs_setTimeHost == NULL ) {
-	    multi_Rx(rxconns,nconns)
-	      {
-		tv.tv_sec = tv.tv_usec = 0;
-		multi_RXAFS_GetTime(
-			(afs_uint32 *)&tv.tv_sec, (afs_uint32 *)&tv.tv_usec);
-		tc = conns[multi_i];
-		sa = tc->srvr;
-		if (conntimer[multi_i] == 1)
-		    rx_SetConnDeadTime(rxconns[multi_i], afs_rx_deadtime);
-		end = osi_Time();
-		results[multi_i]=multi_error;
-		if ((start == end) && !multi_error)
-		  deltas[multi_i] = end - tv.tv_sec;
-
-	      } multi_End;
-	    }
-	else {			/* find and query setTimeHost only */
-	    for ( i = 0 ; i < nconns ; i++ ) {
-		if ( conns[i] == NULL || conns[i]->srvr == NULL )
-		    continue;
-		if ( conns[i]->srvr->server == afs_setTimeHost ) {
-		    tv.tv_sec = tv.tv_usec = 0;
-		    results[i] = RXAFS_GetTime(rxconns[i],
-				(afs_uint32 *)&tv.tv_sec, (afs_uint32 *)&tv.tv_usec);
-		    end = osi_Time();
-		    if ((start == end) && !results[i])
-			deltas[i] = end - tv.tv_sec;
-		    break;
-		}
-	    }
-	}
-	AFS_GLOCK();
-    }
-
-    for(i=0;i<nconns;i++){
-      tc = conns[i];
-      sa = tc->srvr;
-
-      if (( results[i] >= 0 ) && (sa->sa_flags & SRVADDR_ISDOWN) && (tc->srvr == sa)) {
-	/* server back up */
-	print_internet_address("afs: file server ", sa, " is back up", 2);
-
-	ObtainWriteLock(&afs_xserver, 244);
-	ObtainWriteLock(&afs_xsrvAddr, 245);
-	afs_MarkServerUpOrDown(sa, 0);
-	ReleaseWriteLock(&afs_xsrvAddr);
-	ReleaseWriteLock(&afs_xserver);
-
-	if (afs_waitForeverCount) {
-	  afs_osi_Wakeup(&afs_waitForever);
-	}
-      } else {
-	  if ((results[i] < 0) && (results[i] != RXGEN_OPCODE)) {
-	      /* server crashed */
-	      afs_ServerDown(sa);
-	      ForceNewConnections(sa);  /* multi homed clients */
-	  }
-      }
+    if (func2) {
+	(*func2)(rxconns, nconns, j, conns, addrs);
     }
 
-    /*
-     * If we're supposed to set the time, and the call worked
-     * quickly (same second response) and this is the host we
-     * use for the time and the time is really different, then
-     * really set the time
-     */
-    if (afs_setTime != 0) {
-	for (i=0; i<nconns; i++) {
-	    delta = deltas[i];
-	    tc = conns[i];
-	    sa = tc->srvr;
-
-	    if ((tc->srvr->server == afs_setTimeHost ||
-		 /* Sync only to a server in the local cell */
-		 (afs_setTimeHost == (struct server *)0 &&
-		  afs_IsPrimaryCell(sa->server->cell)))) {
-		/* set the time */
-		char msgbuf[90];  /* strlen("afs: setting clock...") + slop */
-		delta = end - tv.tv_sec;   /* how many secs fast we are */
-
-		afs_setTimeHost = tc->srvr->server;
-		/* see if clock has changed enough to make it worthwhile */
-		if (delta >= AFS_MINCHANGE || delta <= -AFS_MINCHANGE) {
-		    end = osi_Time();
-		    if (delta > AFS_MAXCHANGEBACK) {
-			/* setting clock too far back, just do it a little */
-			tv.tv_sec = end - AFS_MAXCHANGEBACK;
-		    } else {
-			tv.tv_sec = end - delta;
-		    }
-		    afs_osi_SetTime(&tv);
-		    if (delta > 0) {
-			strcpy(msgbuf, "afs: setting clock back ");
-			if (delta > AFS_MAXCHANGEBACK) {
-			    afs_strcat(msgbuf,
-				       afs_cv2string(&tbuffer[CVBS],
-						     AFS_MAXCHANGEBACK));
-			    afs_strcat(msgbuf, " seconds (of ");
-			    afs_strcat(msgbuf,
-				       afs_cv2string(&tbuffer[CVBS],
-						     delta -
-						     AFS_MAXCHANGEBACK));
-			    afs_strcat(msgbuf, ", via ");
-			    print_internet_address(msgbuf, sa,
-						   "); clock is still fast.",
-						   0);
-			} else {
-			    afs_strcat(msgbuf,
-				       afs_cv2string(&tbuffer[CVBS], delta));
-			    afs_strcat(msgbuf, " seconds (via ");
-			    print_internet_address(msgbuf, sa, ").", 0);
-			}
-		    } else {
-			strcpy(msgbuf, "afs: setting clock ahead ");
-			afs_strcat(msgbuf,
-				   afs_cv2string(&tbuffer[CVBS], -delta));
-			afs_strcat(msgbuf, " seconds (via ");
-			print_internet_address(msgbuf, sa, ").", 0);
-		    }
-                    /* We're only going to set it once; why bother looping? */
-		    break;
-		}
-	    }
-	}
-    }
     for (i = 0; i < nconns; i++) {
+	if (conntimer[i] == 1)
+	    rx_SetConnDeadTime(tc->id, afs_rx_deadtime);
 	afs_PutConn(conns[i], rxconns[i], SHARED_LOCK);     /* done with it now */
     }
 
@@ -812,9 +894,7 @@ afs_CheckServers(int adown, struct cell *acellp)
     afs_osi_Free(conns, j * sizeof(struct afs_conn *));
     afs_osi_Free(rxconns, j * sizeof(struct rx_connection *));
     afs_osi_Free(conntimer, j * sizeof(afs_int32));
-    afs_osi_Free(deltas, j * sizeof(afs_int32));
     afs_osi_Free(results, j * sizeof(afs_int32));
-    afs_osi_Free(caps, j * sizeof(Capabilities));
 
 } /*afs_CheckServers*/
 
@@ -1731,11 +1811,10 @@ afs_GetCapabilities(struct server *ts)
     ObtainWriteLock(&afs_xserver, 723);
     /* we forced a conn above; important we mark it down if needed */
     if ((code < 0) && (code != RXGEN_OPCODE)) {
-	afs_PutConn(tc, rxconn, SHARED_LOCK);
-	afs_ServerDown(tc->srvr);
+	afs_ServerDown(tc->srvr, code);
 	ForceNewConnections(tc->srvr); /* multi homed clients */
     }
-
+    afs_PutConn(tc, rxconn, SHARED_LOCK);
     if ( code && code != RXGEN_OPCODE ) {
 	afs_warn("RXAFS_GetCapabilities failed with code %d\n", code);
 	/* better not be anything to free. we failed! */
@@ -1803,7 +1882,6 @@ afs_GetServer(afs_uint32 *aserverp, afs_int32 nservers, afs_int32 acell,
 {
     struct server *oldts = 0, *ts, *newts, *orphts = 0;
     struct srvAddr *oldsa, *newsa, *nextsa, *orphsa;
-    u_short fsport;
     afs_int32 iphash, k, srvcount = 0;
     unsigned int srvhash;
 
@@ -1865,7 +1943,7 @@ afs_GetServer(afs_uint32 *aserverp, afs_int32 nservers, afs_int32 acell,
     if (oldts) {
 	newts = oldts;
     } else {
-	newts = (struct server *)afs_osi_Alloc(sizeof(struct server));
+	newts = afs_osi_Alloc(sizeof(struct server));
 	if (!newts)
 	    panic("malloc of server struct");
 	afs_totalServers++;
@@ -1887,8 +1965,6 @@ afs_GetServer(afs_uint32 *aserverp, afs_int32 nservers, afs_int32 acell,
     if (acell)
 	newts->cell = afs_GetCell(acell, 0);
 
-    fsport = (newts->cell ? newts->cell->fsport : AFS_FSPORT);
-
     /* For each IP address we are registering */
     for (k = 0; k < nservers; k++) {
 	iphash = SHash(aserverp[k]);
@@ -1910,7 +1986,7 @@ afs_GetServer(afs_uint32 *aserverp, afs_int32 nservers, afs_int32 acell,
 	if (oldsa) {
 	    newsa = oldsa;
 	} else {
-	    newsa = (struct srvAddr *)afs_osi_Alloc(sizeof(struct srvAddr));
+	    newsa = afs_osi_Alloc(sizeof(struct srvAddr));
 	    if (!newsa)
 		panic("malloc of srvAddr struct");
 	    afs_totalSrvAddrs++;
@@ -1960,8 +2036,7 @@ afs_GetServer(afs_uint32 *aserverp, afs_int32 nservers, afs_int32 acell,
 
 	    /* Have a srvAddr struct. Now get a server struct (if not already) */
 	    if (!orphts) {
-		orphts =
-		    (struct server *)afs_osi_Alloc(sizeof(struct server));
+		orphts = afs_osi_Alloc(sizeof(struct server));
 		if (!orphts)
 		    panic("malloc of lo server struct");
 		memset(orphts, 0, sizeof(struct server));
diff --git a/src/afs/afs_user.c b/src/afs/afs_user.c
index f471216..df18a7f 100644
--- a/src/afs/afs_user.c
+++ b/src/afs/afs_user.c
@@ -485,7 +485,8 @@ afs_GetUser(afs_int32 auid, afs_int32 acell, afs_int32 locktype)
 	    }
 	}
     }
-    tu = (struct unixuser *)afs_osi_Alloc(sizeof(struct unixuser));
+    tu = afs_osi_Alloc(sizeof(struct unixuser));
+    osi_Assert(tu != NULL);
 #ifndef AFS_NOSTATS
     afs_stats_cmfullperf.authent.PAGCreations++;
 #endif /* AFS_NOSTATS */
diff --git a/src/afs/afs_util.c b/src/afs/afs_util.c
index 2b20a94..d324499 100644
--- a/src/afs/afs_util.c
+++ b/src/afs/afs_util.c
@@ -187,7 +187,7 @@ afs_strdup(char *s)
     int cc;
 
     cc = strlen(s) + 1;
-    n = (char *)afs_osi_Alloc(cc);
+    n = afs_osi_Alloc(cc);
     if (n)
 	memcpy(n, s, cc);
 
@@ -196,7 +196,7 @@ afs_strdup(char *s)
 
 void
 print_internet_address(char *preamble, struct srvAddr *sa, char *postamble,
-		       int flag)
+		       int flag, int code)
 {
     struct server *aserver = sa->server;
     char *ptr = "\n";
@@ -216,12 +216,12 @@ print_internet_address(char *preamble, struct srvAddr *sa, char *postamble,
 		" (multi-homed address; other same-host interfaces may still be down)\n";
 	}
     }
-    afs_warn("%s%d.%d.%d.%d in cell %s%s%s", preamble, (address >> 24),
+    afs_warn("%s%d.%d.%d.%d in cell %s%s (code %d)%s", preamble, (address >> 24),
 	     (address >> 16) & 0xff, (address >> 8) & 0xff, (address) & 0xff,
-	     aserver->cell->cellName, postamble, ptr);
-    afs_warnuser("%s%d.%d.%d.%d in cell %s%s%s", preamble, (address >> 24),
+	     aserver->cell->cellName, postamble, code, ptr);
+    afs_warnuser("%s%d.%d.%d.%d in cell %s%s (code %d)%s", preamble, (address >> 24),
 		 (address >> 16) & 0xff, (address >> 8) & 0xff,
-		 (address) & 0xff, aserver->cell->cellName, postamble, ptr);
+		 (address) & 0xff, aserver->cell->cellName, postamble, code, ptr);
 
 }				/*print_internet_address */
 
@@ -370,20 +370,35 @@ afs_data_pointer_to_int32(const void *p)
 #ifdef AFS_LINUX20_ENV
 
 afs_int32
-afs_calc_inum(afs_int32 volume, afs_int32 vnode)
+afs_calc_inum(afs_int32 cell, afs_int32 volume, afs_int32 vnode)
 {
-    afs_int32 ino, vno = vnode;
+    afs_int32 ino = 0, vno = vnode;
     char digest[16];
     struct afs_md5 ct;
 
     if (afs_new_inum) {
+	int offset;
 	AFS_MD5_Init(&ct);
+	AFS_MD5_Update(&ct, &cell, 4);
 	AFS_MD5_Update(&ct, &volume, 4);
 	AFS_MD5_Update(&ct, &vnode, 4);
 	AFS_MD5_Final(digest, &ct);
-	memcpy(&ino, digest, sizeof(afs_int32));
-	ino ^= (ino ^ vno) & 1;
-    } else {
+
+	/* Userspace may react oddly to an inode number of 0 or 1, so keep
+	 * reading more of the md5 digest if we get back one of those.
+	 * Make sure not to read beyond the end of the digest; if we somehow
+	 * still have a 0, we will fall through to the non-md5 calculation. */
+	for (offset = 0;
+	     (ino == 0 || ino == 1) &&
+	      offset + sizeof(ino) <= sizeof(digest);
+	     offset++) {
+
+	    memcpy(&ino, &digest[offset], sizeof(ino));
+	    ino ^= (ino ^ vno) & 1;
+	    ino &= 0x7fffffff;      /* Assumes 32 bit ino_t ..... */
+	}
+    }
+    if (ino == 0 || ino == 1) {
 	ino = (volume << 16) + vnode;
     }
     ino &= 0x7fffffff;      /* Assumes 32 bit ino_t ..... */
@@ -393,7 +408,7 @@ afs_calc_inum(afs_int32 volume, afs_int32 vnode)
 #else
 
 afs_int32
-afs_calc_inum (afs_int32 volume, afs_int32 vnode)
+afs_calc_inum(afs_int32 cell, afs_int32 volume, afs_int32 vnode)
 {
     return (volume << 16) + vnode;
 }
diff --git a/src/afs/afs_vcache.c b/src/afs/afs_vcache.c
index ec45a1a..ca07e92 100644
--- a/src/afs/afs_vcache.c
+++ b/src/afs/afs_vcache.c
@@ -205,8 +205,6 @@ afs_FlushVCache(struct vcache *avc, int *slept)
     vn_reinit(AFSTOV(avc));
 #endif
     afs_FreeAllAxs(&(avc->Access));
-    if (!afs_shuttingdown)
-	afs_QueueVCB(avc, slept);
     ObtainWriteLock(&afs_xcbhash, 460);
     afs_DequeueCallback(avc);	/* remove it from queued callbacks list */
     avc->f.states &= ~(CStatd | CUnique);
@@ -216,6 +214,9 @@ afs_FlushVCache(struct vcache *avc, int *slept)
     else
 	osi_dnlc_purgevp(avc);
 
+    if (!afs_shuttingdown)
+	afs_QueueVCB(avc, slept);
+
     /*
      * Next, keep track of which vnodes we've deleted for create's
      * optimistic synchronization algorithm
@@ -308,9 +309,8 @@ afs_AllocCBR(void)
 	    afs_stats_cmperf.CallBackFlushes++;
 	} else {
 	    /* try allocating */
-	    tsp =
-		(struct afs_cbr *)afs_osi_Alloc(AFS_NCBRS *
-						sizeof(struct afs_cbr));
+	    tsp = afs_osi_Alloc(AFS_NCBRS * sizeof(struct afs_cbr));
+	    osi_Assert(tsp != NULL);
 	    for (i = 0; i < AFS_NCBRS - 1; i++) {
 		tsp[i].next = &tsp[i + 1];
 	    }
@@ -378,6 +378,7 @@ afs_FlushVCBs(afs_int32 lockit)
 	return code;
     treq.flags |= O_NONBLOCK;
     tfids = afs_osi_Alloc(sizeof(struct AFSFid) * AFS_MAXCBRSCALL);
+    osi_Assert(tfids != NULL);
 
     if (lockit)
 	ObtainWriteLock(&afs_xvcb, 273);
@@ -689,10 +690,11 @@ afs_ShakeLooseVCaches(afs_int32 anumber)
 	    i = 0;
 	    continue;	/* start over - may have raced. */
 	}
-	if (tq == uq) {
+	if (uq == &VLRU) {
 	    if (anumber && !defersleep) {
 		defersleep = 1;
-		tq = VLRU.prev;
+		uq = VLRU.prev;
+		i = 0;
 		continue;
 	    }
 	    break;
@@ -1409,9 +1411,6 @@ afs_ProcessFS(struct vcache *avc,
 	      struct AFSFetchStatus *astat, struct vrequest *areq)
 {
     afs_size_t length;
-#ifdef AFS_DARWIN80_ENV
-    int fixup = 0;
-#endif
     AFS_STATCNT(afs_ProcessFS);
 
 #ifdef AFS_64BIT_CLIENT
@@ -1446,32 +1445,16 @@ afs_ProcessFS(struct vcache *avc,
     avc->f.m.Group = astat->Group;
     avc->f.m.LinkCount = astat->LinkCount;
     if (astat->FileType == File) {
-#ifdef AFS_DARWIN80_ENV
-	if (avc->f.m.Type != VREG)
-	    fixup = 1;
-#endif
 	vSetType(avc, VREG);
 	avc->f.m.Mode |= S_IFREG;
     } else if (astat->FileType == Directory) {
-#ifdef AFS_DARWIN80_ENV
-	if (avc->f.m.Type != VDIR)
-	    fixup = 1;
-#endif
 	vSetType(avc, VDIR);
 	avc->f.m.Mode |= S_IFDIR;
     } else if (astat->FileType == SymbolicLink) {
 	if (afs_fakestat_enable && (avc->f.m.Mode & 0111) == 0) {
-#ifdef AFS_DARWIN80_ENV
-	    if (avc->f.m.Type != VDIR)
-		fixup = 1;
-#endif
 	    vSetType(avc, VDIR);
 	    avc->f.m.Mode |= S_IFDIR;
 	} else {
-#ifdef AFS_DARWIN80_ENV
-	    if (avc->f.m.Type != VLNK)
-		fixup = 1;
-#endif
 	    vSetType(avc, VLNK);
 	    avc->f.m.Mode |= S_IFLNK;
 	}
@@ -1479,10 +1462,6 @@ afs_ProcessFS(struct vcache *avc,
 	    avc->mvstat = 1;
 	}
     }
-#ifdef AFS_DARWIN80_ENV
-    if (fixup)
-	printf("found mistyped vnode!\n");
-#endif
     avc->f.anyAccess = astat->AnonymousAccess;
 #ifdef badidea
     if ((astat->CallerAccess & ~astat->AnonymousAccess))
@@ -1532,7 +1511,6 @@ afs_RemoteLookup(struct VenusFid *afid, struct vrequest *areq,
 		 struct AFSVolSync *tsyncp)
 {
     afs_int32 code;
-    afs_uint32 start;
     struct afs_conn *tc;
     struct rx_connection *rxconn;
     struct AFSFetchStatus OutDirStatus;
@@ -1544,7 +1522,6 @@ afs_RemoteLookup(struct VenusFid *afid, struct vrequest *areq,
 	if (tc) {
 	    if (serverp)
 		*serverp = tc->srvr->server;
-	    start = osi_Time();
 	    XSTATS_START_TIME(AFS_STATS_FS_RPCIDX_XLOOKUP);
 	    RX_AFS_GUNLOCK();
 	    code =
@@ -2302,6 +2279,49 @@ afs_UpdateStatus(struct vcache *avc, struct VenusFid *afid,
     	afs_PutVolume(volp, READ_LOCK);
 }
 
+void
+afs_BadFetchStatus(struct afs_conn *tc)
+{
+    int addr = ntohl(tc->srvr->sa_ip);
+    afs_warn("afs: Invalid AFSFetchStatus from server %u.%u.%u.%u\n",
+             (addr >> 24) & 0xff, (addr >> 16) & 0xff, (addr >> 8) & 0xff,
+             (addr) & 0xff);
+    afs_warn("afs: This suggests the server may be sending bad data that "
+             "can lead to availability issues or data corruption. The "
+             "issue has been avoided for now, but it may not always be "
+             "detectable. Please upgrade the server if possible.\n");
+}
+
+/**
+ * Check if a given AFSFetchStatus structure is sane.
+ *
+ * @param[in] tc The server from which we received the status
+ * @param[in] status The status we received
+ *
+ * @return whether the given structure is valid or not
+ *  @retval 0 the structure is fine
+ *  @retval nonzero the structure looks like garbage; act as if we received
+ *                  the returned error code from the server
+ */
+int
+afs_CheckFetchStatus(struct afs_conn *tc, struct AFSFetchStatus *status)
+{
+    if (status->errorCode ||
+        status->InterfaceVersion != 1 ||
+        !(status->FileType > Invalid && status->FileType <= SymbolicLink) ||
+        status->ParentVnode == 0 || status->ParentUnique == 0) {
+
+	afs_warn("afs: FetchStatus ec %u iv %u ft %u pv %u pu %u\n",
+	         (unsigned)status->errorCode, (unsigned)status->InterfaceVersion,
+	         (unsigned)status->FileType, (unsigned)status->ParentVnode,
+	         (unsigned)status->ParentUnique);
+	afs_BadFetchStatus(tc);
+
+	return VBUSY;
+    }
+    return 0;
+}
+
 /*!
  * Must be called with avc write-locked
  * don't absolutely have to invalidate the hint unless the dv has
@@ -2333,6 +2353,10 @@ afs_FetchStatus(struct vcache * avc, struct VenusFid * afid,
 
 	    XSTATS_END_TIME;
 
+	    if (code == 0) {
+		code = afs_CheckFetchStatus(tc, Outsp);
+	    }
+
 	} else
 	    code = -1;
     } while (afs_Analyze
@@ -2919,7 +2943,8 @@ afs_vcacheInit(int astatSize)
 
 #if !defined(AFS_LINUX22_ENV)
     /* Allocate and thread the struct vcache entries */
-    tvp = (struct vcache *)afs_osi_Alloc(astatSize * sizeof(struct vcache));
+    tvp = afs_osi_Alloc(astatSize * sizeof(struct vcache));
+    osi_Assert(tvp != NULL);
     memset(tvp, 0, sizeof(struct vcache) * astatSize);
 
     Initial_freeVCList = tvp;
diff --git a/src/afs/afs_volume.c b/src/afs/afs_volume.c
index 2b278c3..df0e64f 100644
--- a/src/afs/afs_volume.c
+++ b/src/afs/afs_volume.c
@@ -245,7 +245,8 @@ afs_MemGetVolSlot(void)
     if (!afs_freeVolList) {
 	struct volume *newVp;
 
-	newVp = (struct volume *)afs_osi_Alloc(sizeof(struct volume));
+	newVp = afs_osi_Alloc(sizeof(struct volume));
+	osi_Assert(newVp != NULL);
 
 	newVp->next = NULL;
 	afs_freeVolList = newVp;
@@ -317,7 +318,7 @@ afs_CheckVolumeNames(int flags)
 	    for (tv = afs_volumes[i]; tv; tv = tv->next)
 		++vsize;
 
-	volumeID = (afs_int32 *) afs_osi_Alloc(2 * vsize * sizeof(*volumeID));
+	volumeID = afs_osi_Alloc(2 * vsize * sizeof(*volumeID));
 	cellID = (volumeID) ? volumeID + vsize : 0;
     }
 
@@ -635,6 +636,7 @@ afs_SetupVolume(afs_int32 volid, char *aname, void *ve, struct cell *tcell,
     if (agood) {
 	if (!tv->name) {
 	    tv->name = afs_osi_Alloc(strlen(aname) + 1);
+	    osi_Assert(tv->name != NULL);
 	    strcpy(tv->name, aname);
 	}
     }
@@ -702,6 +704,7 @@ afs_NewDynrootVolume(struct VenusFid *fid)
     if (!tcell)
 	return NULL;
     tve = afs_osi_Alloc(sizeof(*tve));
+    osi_Assert(tve != NULL);
     if (!(tcell->states & CHasVolRef))
 	tcell->states |= CHasVolRef;
 
diff --git a/src/afsd/afsd.c b/src/afsd/afsd.c
index 5822530..603551f 100644
--- a/src/afsd/afsd.c
+++ b/src/afsd/afsd.c
@@ -2123,23 +2123,25 @@ afsd_run(void)
 	       cacheFiles, inode_for_V, (cacheFiles * sizeof(AFSD_INO_T)));
 #endif
 
-    /*
-     * Set up all the pathnames we'll need for later.
-     */
-    sprintf(fullpn_DCacheFile, "%s/%s", cacheBaseDir, DCACHEFILE);
-    sprintf(fullpn_VolInfoFile, "%s/%s", cacheBaseDir, VOLINFOFILE);
-    sprintf(fullpn_CellInfoFile, "%s/%s", cacheBaseDir, CELLINFOFILE);
-    sprintf(fullpn_VFile, "%s/", cacheBaseDir);
-    vFilePtr = fullpn_VFile + strlen(fullpn_VFile);
-
-    if (!(cacheFlags & AFSCALL_INIT_MEMCACHE)
-	&& (fsTypeMsg = CheckCacheBaseDir(cacheBaseDir))) {
+    if (!(cacheFlags & AFSCALL_INIT_MEMCACHE)) {
+	/*
+	 * Set up all the pathnames we'll need for later.
+	 */
+	sprintf(fullpn_DCacheFile, "%s/%s", cacheBaseDir, DCACHEFILE);
+	sprintf(fullpn_VolInfoFile, "%s/%s", cacheBaseDir, VOLINFOFILE);
+	sprintf(fullpn_CellInfoFile, "%s/%s", cacheBaseDir, CELLINFOFILE);
+	sprintf(fullpn_VFile, "%s/", cacheBaseDir);
+	vFilePtr = fullpn_VFile + strlen(fullpn_VFile);
+
+	fsTypeMsg = CheckCacheBaseDir(cacheBaseDir);
+	if (fsTypeMsg) {
 #ifdef AFS_SUN5_ENV
-	printf("%s: WARNING: Cache dir check failed (%s)\n", rn, fsTypeMsg);
+	    printf("%s: WARNING: Cache dir check failed (%s)\n", rn, fsTypeMsg);
 #else
-	printf("%s: ERROR: Cache dir check failed (%s)\n", rn, fsTypeMsg);
-	exit(1);
+	    printf("%s: ERROR: Cache dir check failed (%s)\n", rn, fsTypeMsg);
+	    exit(1);
 #endif
+	}
     }
 
     /*
@@ -2410,13 +2412,13 @@ afsd_run(void)
      * Give the kernel the names of the AFS files cached on the workstation's
      * disk.
      */
-    if (afsd_debug)
-	printf
-	    ("%s: Calling AFSOP_CACHEFILE for each of the %d files in '%s'\n",
-	     rn, cacheFiles, cacheBaseDir);
     if (!(cacheFlags & AFSCALL_INIT_MEMCACHE)) {
-	/* ... and again ... */
 	int nocachefile = 0;
+	if (afsd_debug)
+	    printf
+	        ("%s: Calling AFSOP_CACHEFILE for each of the %d files in '%s'\n",
+	         rn, cacheFiles, cacheBaseDir);
+	/* ... and again ... */
 	for (currVFile = 0; currVFile < cacheFiles; currVFile++) {
 	    if (!nocachefile) {
 		sprintf(fullpn_VFile, "%s/D%d/V%d", cacheBaseDir, dir_for_V[currVFile], currVFile);
diff --git a/src/afsd/afsd_kernel.c b/src/afsd/afsd_kernel.c
index 1f7fdbb..e1e87a7 100644
--- a/src/afsd/afsd_kernel.c
+++ b/src/afsd/afsd_kernel.c
@@ -37,6 +37,10 @@
 #include <sys/param.h>
 #endif
 
+#if defined(AFS_LINUX20_ENV)
+#include <sys/resource.h>
+#endif
+
 #ifdef HAVE_SYS_FS_TYPES_H
 #include <sys/fs_types.h>
 #endif
diff --git a/src/afsmonitor/afsmon-win.c b/src/afsmonitor/afsmon-win.c
index f3e2188..550d313 100644
--- a/src/afsmonitor/afsmon-win.c
+++ b/src/afsmonitor/afsmon-win.c
@@ -1036,7 +1036,6 @@ create_ovwFrame_objects(void)
     int hostLines;		/* number of lines of host names to display */
     struct onode **ovw_fsNames_o_Ptr;	/* index to list of fs names onodes */
     struct onode **ovw_cmNames_o_Ptr;	/* index to list of cm names onodes */
-    int code;
     int i;
 
     if (afsmon_debug) {
@@ -1066,8 +1065,8 @@ create_ovwFrame_objects(void)
 	sprintf(errMsg, "[ %s ] Failed to create initMsg_o onode\n", rn);
 	afsmon_Exit(250);
     }
-    code = gtxframe_AddToList(ovwFrame, initMsg_o);
-    code = gator_light_set(initMsg_o, HIGHLIGHT);
+    gtxframe_AddToList(ovwFrame, initMsg_o);
+    gator_light_set(initMsg_o, HIGHLIGHT);
     initMsg_on = 1;
 
 
@@ -1079,8 +1078,8 @@ create_ovwFrame_objects(void)
 	sprintf(errMsg, "[ %s ] Failed to create command onode\n", rn);
 	afsmon_Exit(265);
     }
-    code = gtxframe_AddToList(ovwFrame, ovw_cmd_o);
-    code = gator_light_set(ovw_cmd_o, HIGHLIGHT);
+    gtxframe_AddToList(ovwFrame, ovw_cmd_o);
+    gator_light_set(ovw_cmd_o, HIGHLIGHT);
 
     /* create the program name object */
 
@@ -1089,8 +1088,8 @@ create_ovwFrame_objects(void)
 	sprintf(errMsg, "[ %s ] Failed to create programName onode\n", rn);
 	afsmon_Exit(255);
     }
-    code = gtxframe_AddToList(ovwFrame, ovw_progName_o);
-    code = gator_light_set(ovw_progName_o, HIGHLIGHT);
+    gtxframe_AddToList(ovwFrame, ovw_progName_o);
+    gator_light_set(ovw_progName_o, HIGHLIGHT);
 
     /* create the page number object */
 
@@ -1101,8 +1100,8 @@ create_ovwFrame_objects(void)
 	sprintf(errMsg, "[ %s ] Failed to create pageNumber onode\n", rn);
 	afsmon_Exit(260);
     }
-    code = gtxframe_AddToList(ovwFrame, ovw_pageNum_o);
-    code = gator_light_set(ovw_pageNum_o, HIGHLIGHT);
+    gtxframe_AddToList(ovwFrame, ovw_pageNum_o);
+    gator_light_set(ovw_pageNum_o, HIGHLIGHT);
 
     /* create the probe number object */
     ovw_probeNum_o =
@@ -1112,8 +1111,8 @@ create_ovwFrame_objects(void)
 	sprintf(errMsg, "[ %s ] Failed to create probe number onode\n", rn);
 	afsmon_Exit(270);
     }
-    code = gtxframe_AddToList(ovwFrame, ovw_probeNum_o);
-    code = gator_light_set(ovw_probeNum_o, HIGHLIGHT);
+    gtxframe_AddToList(ovwFrame, ovw_probeNum_o);
+    gator_light_set(ovw_probeNum_o, HIGHLIGHT);
 
     /* create the numFS monitored object */
     ovw_numFS_o = initLightObject("", 0, 2, FC_NUMHOSTS_O_WIDTH, afsmon_win);
@@ -1121,7 +1120,7 @@ create_ovwFrame_objects(void)
 	sprintf(errMsg, "[ %s ] Failed to create numFS onode\n", rn);
 	afsmon_Exit(275);
     }
-    code = gtxframe_AddToList(ovwFrame, ovw_numFS_o);
+    gtxframe_AddToList(ovwFrame, ovw_numFS_o);
 
     /* create the numCM monitored object */
     ovw_numCM_o =
@@ -1130,7 +1129,7 @@ create_ovwFrame_objects(void)
 	sprintf(errMsg, "[ %s ] Failed to create numCM_o onode\n", rn);
 	afsmon_Exit(280);
     }
-    code = gtxframe_AddToList(ovwFrame, ovw_numCM_o);
+    gtxframe_AddToList(ovwFrame, ovw_numCM_o);
 
     /* create the number-of-FS-alerts object */
     ovw_FSalerts_o =
@@ -1139,7 +1138,7 @@ create_ovwFrame_objects(void)
 	sprintf(errMsg, "[ %s ] Failed to create FSalerts_o onode\n", rn);
 	afsmon_Exit(285);
     }
-    code = gtxframe_AddToList(ovwFrame, ovw_FSalerts_o);
+    gtxframe_AddToList(ovwFrame, ovw_FSalerts_o);
 
     /* create the number-of-CM-alerts object */
     ovw_CMalerts_o =
@@ -1148,7 +1147,7 @@ create_ovwFrame_objects(void)
 	sprintf(errMsg, "[ %s ] Failed to create CMalerts_o onode\n", rn);
 	afsmon_Exit(290);
     }
-    code = gtxframe_AddToList(ovwFrame, ovw_CMalerts_o);
+    gtxframe_AddToList(ovwFrame, ovw_CMalerts_o);
 
     /* create file-server-name and cache-manager-names objects */
     ovw_numHosts_perPage = maxY - OVW_NUM_FIXED_LINES;
@@ -1180,7 +1179,7 @@ create_ovwFrame_objects(void)
 	 * fflush(debugFD);
 	 * }
 	 */
-	code = gtxframe_AddToList(ovwFrame, *ovw_fsNames_o_Ptr);
+	gtxframe_AddToList(ovwFrame, *ovw_fsNames_o_Ptr);
 	ovw_fsNames_o_Ptr++;
 
     }
@@ -1206,7 +1205,7 @@ create_ovwFrame_objects(void)
 	    sprintf(errMsg, "[ %s ] Failed to create a CM name onode\n", rn);
 	    afsmon_Exit(310);
 	}
-	code = gtxframe_AddToList(ovwFrame, *ovw_cmNames_o_Ptr);
+	gtxframe_AddToList(ovwFrame, *ovw_cmNames_o_Ptr);
 	ovw_cmNames_o_Ptr++;
     }
 
@@ -2080,7 +2079,6 @@ create_FSframe_objects(void)
     struct onode **fsLabels_o_Ptr;
     int x_pos;
     int y_pos;
-    int code;
     int i;
     int j;
     int numBytes;
@@ -2100,13 +2098,13 @@ create_FSframe_objects(void)
 	sprintf(errMsg, "[ %s ] Failed to create fs command onode\n", rn);
 	afsmon_Exit(340);
     }
-    code = gtxframe_AddToList(fsFrame, fs_cmd_o);
-    code = gator_light_set(fs_cmd_o, HIGHLIGHT);
+    gtxframe_AddToList(fsFrame, fs_cmd_o);
+    gator_light_set(fs_cmd_o, HIGHLIGHT);
 
     /* we already have the dimensions for the frame - same as the ovw frame */
     /* use the ovw program name object for the fs screen too */
 
-    code = gtxframe_AddToList(fsFrame, ovw_progName_o);
+    gtxframe_AddToList(fsFrame, ovw_progName_o);
 
 
     /* create the page number object */
@@ -2118,8 +2116,8 @@ create_FSframe_objects(void)
 	sprintf(errMsg, "[ %s ] Failed to create pageNumber onode\n", rn);
 	afsmon_Exit(335);
     }
-    code = gtxframe_AddToList(fsFrame, fs_pageNum_o);
-    code = gator_light_set(fs_pageNum_o, HIGHLIGHT);
+    gtxframe_AddToList(fsFrame, fs_pageNum_o);
+    gator_light_set(fs_pageNum_o, HIGHLIGHT);
 
     /* create the probe number object */
     fs_probeNum_o =
@@ -2130,8 +2128,8 @@ create_FSframe_objects(void)
 	sprintf(errMsg, "[ %s ] Failed to create fs probeNum onode\n", rn);
 	afsmon_Exit(345);
     }
-    code = gtxframe_AddToList(fsFrame, fs_probeNum_o);
-    code = gator_light_set(fs_probeNum_o, HIGHLIGHT);
+    gtxframe_AddToList(fsFrame, fs_probeNum_o);
+    gator_light_set(fs_probeNum_o, HIGHLIGHT);
 
 
     /* create the numFS monitored object */
@@ -2144,7 +2142,7 @@ create_FSframe_objects(void)
 		"[ %s ] Failed to create numFS onode for the fs frame\n", rn);
 	afsmon_Exit(350);
     }
-    code = gtxframe_AddToList(fsFrame, fs_numFS_o);
+    gtxframe_AddToList(fsFrame, fs_numFS_o);
 
     /* create the "more columns to left" indicator */
     fs_leftArrows_o =
@@ -2155,7 +2153,7 @@ create_FSframe_objects(void)
 		rn);
 	afsmon_Exit(355);
     }
-    code = gtxframe_AddToList(fsFrame, fs_leftArrows_o);
+    gtxframe_AddToList(fsFrame, fs_leftArrows_o);
 
     /* create the "more columns to right" indicator */
     fs_rightArrows_o =
@@ -2167,7 +2165,7 @@ create_FSframe_objects(void)
 		rn);
 	afsmon_Exit(360);
     }
-    code = gtxframe_AddToList(fsFrame, fs_rightArrows_o);
+    gtxframe_AddToList(fsFrame, fs_rightArrows_o);
 
 
 
@@ -2230,7 +2228,7 @@ create_FSframe_objects(void)
 	    sprintf(errMsg, "[ %s ] Failed to create an FS name onode\n", rn);
 	    afsmon_Exit(375);
 	}
-	code = gtxframe_AddToList(fsFrame, fs_lines_Ptr->host_o);
+	gtxframe_AddToList(fsFrame, fs_lines_Ptr->host_o);
 
 	/* if (afsmon_debug) {
 	 * fprintf(debugFD,"[ %s ] Addr of host_o = %d for line %d\n",
@@ -2261,7 +2259,7 @@ create_FSframe_objects(void)
 			    "[ %s ] Failed to create an FS data onode\n", rn);
 		    afsmon_Exit(380);
 		}
-		code = gtxframe_AddToList(fsFrame, *fs_data_o_Ptr);
+		gtxframe_AddToList(fsFrame, *fs_data_o_Ptr);
 
 		fs_data_o_Ptr++;
 	    }			/* for each column */
@@ -2300,7 +2298,7 @@ create_FSframe_objects(void)
 			rn);
 		afsmon_Exit(390);
 	    }
-	    code = gtxframe_AddToList(fsFrame, *fsLabels_o_Ptr);
+	    gtxframe_AddToList(fsFrame, *fsLabels_o_Ptr);
 	    fsLabels_o_Ptr++;
 	}
 
@@ -2861,7 +2859,6 @@ create_CMframe_objects(void)
     struct onode **cmLabels_o_Ptr;
     int x_pos;
     int y_pos;
-    int code;
     int i;
     int j;
     int numBytes;
@@ -2882,14 +2879,14 @@ create_CMframe_objects(void)
 	sprintf(errMsg, "[ %s ] Failed to create cm command onode\n", rn);
 	afsmon_Exit(420);
     }
-    code = gtxframe_AddToList(cmFrame, cm_cmd_o);
-    code = gator_light_set(cm_cmd_o, HIGHLIGHT);
+    gtxframe_AddToList(cmFrame, cm_cmd_o);
+    gator_light_set(cm_cmd_o, HIGHLIGHT);
 
 
     /* we already have the dimensions for the frame - same as the ovw frame */
     /* use the ovw program name object for the cm screen too */
 
-    code = gtxframe_AddToList(cmFrame, ovw_progName_o);
+    gtxframe_AddToList(cmFrame, ovw_progName_o);
 
 
     /* create the page number object */
@@ -2901,8 +2898,8 @@ create_CMframe_objects(void)
 	sprintf(errMsg, "[ %s ] Failed to create pageNumber onode\n", rn);
 	afsmon_Exit(415);
     }
-    code = gtxframe_AddToList(cmFrame, cm_pageNum_o);
-    code = gator_light_set(cm_pageNum_o, HIGHLIGHT);
+    gtxframe_AddToList(cmFrame, cm_pageNum_o);
+    gator_light_set(cm_pageNum_o, HIGHLIGHT);
 
     /* create the probe number object */
     cm_probeNum_o =
@@ -2913,8 +2910,8 @@ create_CMframe_objects(void)
 	sprintf(errMsg, "[ %s ] Failed to create cm probeNum onode\n", rn);
 	afsmon_Exit(425);
     }
-    code = gtxframe_AddToList(cmFrame, cm_probeNum_o);
-    code = gator_light_set(cm_probeNum_o, HIGHLIGHT);
+    gtxframe_AddToList(cmFrame, cm_probeNum_o);
+    gator_light_set(cm_probeNum_o, HIGHLIGHT);
 
 
     /* create the numCM monitored object */
@@ -2927,7 +2924,7 @@ create_CMframe_objects(void)
 		"[ %s ] Failed to create numCM onode for the cm frame\n", rn);
 	afsmon_Exit(430);
     }
-    code = gtxframe_AddToList(cmFrame, cm_numCM_o);
+    gtxframe_AddToList(cmFrame, cm_numCM_o);
 
     /* create the "more columns to left" indicator */
     cm_leftArrows_o =
@@ -2938,7 +2935,7 @@ create_CMframe_objects(void)
 		rn);
 	afsmon_Exit(435);
     }
-    code = gtxframe_AddToList(cmFrame, cm_leftArrows_o);
+    gtxframe_AddToList(cmFrame, cm_leftArrows_o);
 
     /* create the "more columns to right" indicator */
     cm_rightArrows_o =
@@ -2950,7 +2947,7 @@ create_CMframe_objects(void)
 		rn);
 	afsmon_Exit(440);
     }
-    code = gtxframe_AddToList(cmFrame, cm_rightArrows_o);
+    gtxframe_AddToList(cmFrame, cm_rightArrows_o);
 
 
 
@@ -3013,7 +3010,7 @@ create_CMframe_objects(void)
 	    sprintf(errMsg, "[ %s ] Failed to create an CM name onode\n", rn);
 	    afsmon_Exit(455);
 	}
-	code = gtxframe_AddToList(cmFrame, cm_lines_Ptr->host_o);
+	gtxframe_AddToList(cmFrame, cm_lines_Ptr->host_o);
 
 	/* if (afsmon_debug) {
 	 * fprintf(debugFD,"[ %s ] Addr of host_o = %d for line %d\n",
@@ -3044,7 +3041,7 @@ create_CMframe_objects(void)
 			    "[ %s ] Failed to create an CM data onode\n", rn);
 		    afsmon_Exit(460);
 		}
-		code = gtxframe_AddToList(cmFrame, *cm_data_o_Ptr);
+		gtxframe_AddToList(cmFrame, *cm_data_o_Ptr);
 
 		cm_data_o_Ptr++;
 	    }			/* for each column */
@@ -3083,7 +3080,7 @@ create_CMframe_objects(void)
 			rn);
 		afsmon_Exit(470);
 	    }
-	    code = gtxframe_AddToList(cmFrame, *cmLabels_o_Ptr);
+	    gtxframe_AddToList(cmFrame, *cmLabels_o_Ptr);
 	    cmLabels_o_Ptr++;
 	}
 
diff --git a/src/afsmonitor/afsmonitor.c b/src/afsmonitor/afsmonitor.c
index b5f1c46..f7992d6 100644
--- a/src/afsmonitor/afsmonitor.c
+++ b/src/afsmonitor/afsmonitor.c
@@ -1417,7 +1417,6 @@ process_config_file(char *a_config_filename)
     char *handlerPtr;		/* ptr to pass theresh handler string */
     int code = 0;		/* error code */
     int linenum = 0;		/* config file line number */
-    int threshCount;		/* count of thresholds for each server */
     int error_in_config;	/* syntax errors in config file  ?? */
     int i;
     int numBytes;
@@ -1453,7 +1452,6 @@ process_config_file(char *a_config_filename)
 
     numFS = 0;
     numCM = 0;
-    threshCount = 0;
     error_in_config = 0;	/* flag to note if config file has syntax errors */
 
     while ((fgets(line, CFG_STR_LEN, configFD)) != NULL) {
@@ -2044,7 +2042,6 @@ execute_thresh_handler(char *a_handler,		/* ptr to handler function + args */
     char fileName[256];		/* file name to execute */
     int i;
     char *ch;
-    int code;
     int argNum;
     int anotherArg;		/* boolean used to flag if another arg is available */
 
@@ -2109,7 +2106,7 @@ execute_thresh_handler(char *a_handler,		/* ptr to handler function + args */
 
     if (fork() == 0) {
 	exec_fsThreshHandler = 1;
-	code = afsmon_Exit(60);
+	afsmon_Exit(60);
     }
 
     return (0);
diff --git a/src/aklog/aklog.c b/src/aklog/aklog.c
index 2104bc5..cce3c44 100644
--- a/src/aklog/aklog.c
+++ b/src/aklog/aklog.c
@@ -242,12 +242,11 @@ Done:
 #error "Must have either keyblock or session member of krb5_creds"
 #endif
 
-#ifdef AFS_DARWIN110_ENV
-#define HAVE_NO_KRB5_524 /* MITKerberosShim logs but returns success */
+/* MITKerberosShim logs but returns success */
+#if !defined(HAVE_KRB5_524_CONV_PRINCIPAL) || defined(AFS_DARWIN110_ENV) || (!defined(HAVE_KRB5_524_CONVERT_CREDS) && !defined(HAVE_KRB524_CONVERT_CREDS_KDC))
+#define HAVE_NO_KRB5_524
 #elif !defined(HAVE_KRB5_524_CONVERT_CREDS) && defined(HAVE_KRB524_CONVERT_CREDS_KDC)
 #define krb5_524_convert_creds krb524_convert_creds_kdc
-#elif !defined(HAVE_KRB5_524_CONVERT_CREDS) && !defined(HAVE_KRB524_CONVERT_CREDS_KDC)
-#define HAVE_NO_KRB5_524
 #endif
 
 #if USING_HEIMDAL
diff --git a/src/auth/cellconfig.c b/src/auth/cellconfig.c
index ad95a9b..7b21740 100644
--- a/src/auth/cellconfig.c
+++ b/src/auth/cellconfig.c
@@ -989,7 +989,7 @@ afsconf_LookupServer(const char *service, const char *protocol,
 {
     int code = 0;
     int len;
-    unsigned char answer[1024];
+    unsigned char answer[4096];
     unsigned char *p;
     char *dotcellname;
     char *realCellName;
diff --git a/src/bozo/bnode.c b/src/bozo/bnode.c
index 6f3e2c3..54ebf92 100644
--- a/src/bozo/bnode.c
+++ b/src/bozo/bnode.c
@@ -775,7 +775,7 @@ int
 hdl_notifier(struct bnode_proc *tp)
 {
 #ifndef AFS_NT40_ENV		/* NT notifier callout not yet implemented */
-    int code, pid;
+    int pid;
     struct stat tstat;
 
     if (stat(tp->bnode->notifier, &tstat)) {
@@ -786,16 +786,15 @@ hdl_notifier(struct bnode_proc *tp)
     if ((pid = fork()) == 0) {
 	FILE *fout;
 	struct bnode *tb = tp->bnode;
-	int ec;
 
 #if defined(AFS_HPUX_ENV) || defined(AFS_SUN5_ENV) || defined(AFS_SGI51_ENV)
-	ec = setsid();
+	setsid();
 #elif defined(AFS_DARWIN90_ENV)
-	ec = setpgid(0, 0);
+	setpgid(0, 0);
 #elif defined(AFS_LINUX20_ENV) || defined(AFS_AIX_ENV)
-	ec = setpgrp();
+	setpgrp();
 #else
-	ec = setpgrp(0, 0);
+	setpgrp(0, 0);
 #endif
 	fout = popen(tb->notifier, "w");
 	if (fout == NULL) {
@@ -804,7 +803,7 @@ hdl_notifier(struct bnode_proc *tp)
 	    perror(tb->notifier);
 	    exit(1);
 	}
-	code = SendNotifierData(fileno(fout), tp);
+	SendNotifierData(fileno(fout), tp);
 	pclose(fout);
 	exit(0);
     } else if (pid < 0) {
diff --git a/src/bozo/bnode.p.h b/src/bozo/bnode.p.h
index 971d272..d4b6da2 100644
--- a/src/bozo/bnode.p.h
+++ b/src/bozo/bnode.p.h
@@ -124,9 +124,6 @@ struct bozo_bosEntryStats {
 #ifdef AFS_NT40_ENV
 #define BOSEXIT_RESTART        0xA0
 #define BOSEXIT_DORESTART(code)  (((code) & ~(0xF)) == BOSEXIT_RESTART)
-#define BOSEXIT_NOAUTH_FLAG    0x01
-#define BOSEXIT_LOGGING_FLAG   0x02
-#define BOSEXIT_RXBIND_FLAG    0x04
 #endif
 
 /* max time to wait for fileserver shutdown */
diff --git a/src/bozo/bosserver.c b/src/bozo/bosserver.c
index 632e6ad..562e3b7 100644
--- a/src/bozo/bosserver.c
+++ b/src/bozo/bosserver.c
@@ -66,6 +66,10 @@ struct afsconf_dir *bozo_confdir = 0;	/* bozo configuration dir */
 static PROCESS bozo_pid;
 const char *bozo_fileName;
 FILE *bozo_logFile;
+#ifndef AFS_NT40_ENV
+static int bozo_argc = 0;
+static char** bozo_argv = NULL;
+#endif
 
 const char *DoCore;
 int DoLogging = 0;
@@ -112,62 +116,13 @@ int
 bozo_ReBozo(void)
 {
 #ifdef AFS_NT40_ENV
-    /* exit with restart code; SCM integrator process will restart bosserver */
-    int status = BOSEXIT_RESTART;
-
-    /* if noauth flag is set, pass "-noauth" to new bosserver */
-    if (afsconf_GetNoAuthFlag(bozo_confdir)) {
-	status |= BOSEXIT_NOAUTH_FLAG;
-    }
-    /* if logging is on, pass "-log" to new bosserver */
-    if (DoLogging) {
-	status |= BOSEXIT_LOGGING_FLAG;
-    }
-    /* if rxbind is set, pass "-rxbind" to new bosserver */
-    if (rxBind) {
-	status |= BOSEXIT_RXBIND_FLAG;
-    }
-    exit(status);
+    /* exit with restart code; SCM integrator process will restart bosserver with
+       the same arguments */
+    exit(BOSEXIT_RESTART);
 #else
     /* exec new bosserver process */
-    char *argv[4];
     int i = 0;
 
-    argv[i] = (char *)AFSDIR_SERVER_BOSVR_FILEPATH;
-    i++;
-
-    /* if noauth flag is set, pass "-noauth" to new bosserver */
-    if (afsconf_GetNoAuthFlag(bozo_confdir)) {
-	argv[i] = "-noauth";
-	i++;
-    }
-    /* if logging is on, pass "-log" to new bosserver */
-    if (DoLogging) {
-	argv[i] = "-log";
-	i++;
-    }
-    /* if rxbind is set, pass "-rxbind" to new bosserver */
-    if (rxBind) {
-	argv[i] = "-rxbind";
-	i++;
-    }
-#ifndef AFS_NT40_ENV
-    /* if syslog logging is on, pass "-syslog" to new bosserver */
-    if (DoSyslog) {
-	char *arg = (char *)malloc(40);	/* enough for -syslog=# */
-	if (DoSyslogFacility != LOG_DAEMON) {
-	    snprintf(arg, 40, "-syslog=%d", DoSyslogFacility);
-	} else {
-	    strcpy(arg, "-syslog");
-	}
-	argv[i] = arg;
-	i++;
-    }
-#endif
-
-    /* null-terminate argument list */
-    argv[i] = NULL;
-
     /* close random fd's */
     for (i = 3; i < 64; i++) {
 	close(i);
@@ -175,7 +130,7 @@ bozo_ReBozo(void)
 
     unlink(AFSDIR_SERVER_BOZRXBIND_FILEPATH);
 
-    execv(argv[0], argv);	/* should not return */
+    execv(bozo_argv[0], bozo_argv);	/* should not return */
     _exit(1);
 #endif /* AFS_NT40_ENV */
 }
@@ -923,8 +878,23 @@ main(int argc, char **argv, char **envp)
     }
 #endif
 
+#ifndef AFS_NT40_ENV
+    /* save args for restart */
+    bozo_argc = argc;
+    bozo_argv = malloc((argc+1) * sizeof(char*));
+    if (!bozo_argv) {
+	fprintf(stderr, "%s: Failed to allocate argument list.\n", argv[0]);
+	exit(1);
+    }
+    bozo_argv[0] = (char*)AFSDIR_SERVER_BOSVR_FILEPATH; /* expected path */
+    bozo_argv[bozo_argc] = NULL; /* null terminate list */
+#endif	/* AFS_NT40_ENV */
+
     /* parse cmd line */
     for (code = 1; code < argc; code++) {
+#ifndef AFS_NT40_ENV
+	bozo_argv[code] = argv[code];
+#endif	/* AFS_NT40_ENV */
 	if (strcmp(argv[code], "-noauth") == 0) {
 	    /* set noauth flag */
 	    noAuth = 1;
diff --git a/src/bucoord/vol_sets.c b/src/bucoord/vol_sets.c
index 047cec8..a184511 100644
--- a/src/bucoord/vol_sets.c
+++ b/src/bucoord/vol_sets.c
@@ -447,13 +447,11 @@ bc_ParseVolumeSet(void)
 
     udbClientTextP ctPtr;
     FILE *stream;
-    struct bc_config *configPtr;
 
     extern struct bc_config *bc_globalConfig;
 
     ctPtr = &bc_globalConfig->configText[TB_VOLUMESET];
     stream = ctPtr->textStream;
-    configPtr = bc_globalConfig;
 
     /*
      * Open up the volume set configuration file, fail if it can't be done.
@@ -601,13 +599,11 @@ bc_SaveVolumeSet(void)
 
     udbClientTextP ctPtr;
     FILE *stream;
-    struct bc_config *configPtr;
 
     extern struct bc_config *bc_globalConfig;
 
     ctPtr = &bc_globalConfig->configText[TB_VOLUMESET];
     stream = ctPtr->textStream;
-    configPtr = bc_globalConfig;
 
     /* must be locked */
     if (ctPtr->lockHandle == 0)
diff --git a/src/budb/database.h b/src/budb/database.h
index 6a359a7..fdb3da5 100644
--- a/src/budb/database.h
+++ b/src/budb/database.h
@@ -12,6 +12,10 @@
 #include <lock.h>
 #include "budb.h"
 
+#if !defined(offsetof)
+#include <stddef.h>             /* for definition of offsetof() */
+#endif
+
 typedef afs_uint32 dbadr;
 
 struct hashTable {
@@ -289,7 +293,7 @@ struct memoryDB {		/* in core copies of database structures */
 extern struct memoryDB db;
 
 #define set_header_word(ut,field,value) \
-    dbwrite ((ut), ((char *)&(db.h.field) - (char *)&db.h), \
+    dbwrite ((ut), (offsetof(struct dbHeader, field)), \
 	     ((db.h.field = (value)), (char *)&(db.h.field)), \
 	     sizeof(afs_int32))
 
diff --git a/src/cf/linux-test4.m4 b/src/cf/linux-test4.m4
index f5e91b1..fc0149f 100644
--- a/src/cf/linux-test4.m4
+++ b/src/cf/linux-test4.m4
@@ -661,3 +661,97 @@ AC_DEFUN([LINUX_IOP_CREATE_TAKES_UMODE_T], [
 			[define if inode.i_op->create takes a umode_t argument],
 			[-Werror])
 ])
+
+
+AC_DEFUN([LINUX_EXPORT_OP_ENCODE_FH_TAKES_INODES], [
+  AC_CHECK_LINUX_BUILD([whether export operation encode_fh takes inode arguments],
+			[ac_cv_linux_export_op_encode_fh__takes_inodes],
+			[#include <linux/exportfs.h>],
+			[struct export_operations _exp_ops;
+			int _encode_fh(struct inode *i, __u32 *fh, int *len, struct inode *p)
+				{return 0;};
+			_exp_ops.encode_fh = _encode_fh;],
+			[EXPORT_OP_ENCODE_FH_TAKES_INODES],
+			[define if encode_fh export op takes inode arguments],
+			[-Werror])
+])
+
+
+AC_DEFUN([LINUX_KMAP_ATOMIC_TAKES_NO_KM_TYPE], [
+  AC_CHECK_LINUX_BUILD([whether kmap_atomic takes no km_type argument],
+			[ac_cv_linux_kma_atomic_takes_no_km_type],
+			[#include <linux/highmem.h>],
+			[struct page *p = NULL;
+			kmap_atomic(p);],
+			[KMAP_ATOMIC_TAKES_NO_KM_TYPE],
+			[define if kmap_atomic takes no km_type argument],
+			[-Werror])
+])
+
+
+AC_DEFUN([LINUX_DENTRY_OPEN_TAKES_PATH], [
+  AC_CHECK_LINUX_BUILD([whether dentry_open takes a path argument],
+			[ac_cv_linux_dentry_open_takes_path],
+			[#include <linux/fs.h>],
+			[struct path p;
+			dentry_open(&p, 0, NULL);],
+			[DENTRY_OPEN_TAKES_PATH],
+			[define if dentry_open takes a path argument],
+			[-Werror])
+])
+
+
+AC_DEFUN([LINUX_D_ALIAS_IS_HLIST], [
+  AC_CHECK_LINUX_BUILD([whether dentry->d_alias is an hlist],
+			[ac_cv_linux_d_alias_is_hlist],
+			[#include <linux/fs.h>],
+			[struct dentry *d = NULL;
+			struct hlist_node *hn = NULL;
+			d->d_alias = *hn;],
+			[D_ALIAS_IS_HLIST],
+			[define if dentry->d_alias is an hlist],
+			[])
+])
+
+
+AC_DEFUN([LINUX_IOP_I_CREATE_TAKES_BOOL], [
+  AC_CHECK_LINUX_BUILD([whether inode_operations.create takes a bool],
+			[ac_cv_linux_func_i_create_takes_bool],
+			[#include <linux/fs.h>
+			#include <linux/namei.h>],
+			[struct inode _inode = {};
+			struct dentry _dentry;
+			bool b = true;
+			(void)_inode.i_op->create(&_inode, &_dentry, 0, b);],
+		       [IOP_CREATE_TAKES_BOOL],
+		       [define if your iops.create takes a bool argument],
+		       [-Werror])
+])
+
+
+AC_DEFUN([LINUX_DOP_D_REVALIDATE_TAKES_UNSIGNED], [
+  AC_CHECK_LINUX_BUILD([whether dentry_operations.d_revalidate takes an unsigned int],
+			[ac_cv_linux_func_d_revalidate_takes_unsigned],
+			[#include <linux/fs.h>
+			#include <linux/namei.h>],
+			[struct dentry_operations dops;
+			int reval(struct dentry *d, unsigned int i) { return 0; };
+			dops.d_revalidate = reval;],
+		       [DOP_REVALIDATE_TAKES_UNSIGNED],
+		       [define if your dops.d_revalidate takes an unsigned int argument],
+		       [-Werror])
+])
+
+
+AC_DEFUN([LINUX_IOP_LOOKUP_TAKES_UNSIGNED], [
+  AC_CHECK_LINUX_BUILD([whether inode operation lookup takes an unsigned int],
+			[ac_cv_linux_func_lookup_takes_unsigned],
+			[#include <linux/fs.h>
+			#include <linux/namei.h>],
+			[struct inode_operations iops;
+			struct dentry *look(struct inode *i, struct dentry *d, unsigned int j) { return NULL; };
+			iops.lookup = look;],
+		       [IOP_LOOKUP_TAKES_UNSIGNED],
+		       [define if your iops.lookup takes an unsigned int argument],
+		       [-Werror])
+])
diff --git a/src/config/afs_sysnames.h b/src/config/afs_sysnames.h
index f3d8bdd..96dda28 100644
--- a/src/config/afs_sysnames.h
+++ b/src/config/afs_sysnames.h
@@ -202,7 +202,11 @@
 #define SYS_NAME_ID_i386_fbsd_80        2117
 #define SYS_NAME_ID_i386_fbsd_81        2118
 #define SYS_NAME_ID_i386_fbsd_82        2119
+#define SYS_NAME_ID_i386_fbsd_83        2121
+#define SYS_NAME_ID_i386_fbsd_84        2123
 #define SYS_NAME_ID_i386_fbsd_90        2120
+#define SYS_NAME_ID_i386_fbsd_91        2122
+#define SYS_NAME_ID_i386_fbsd_100      2130
 
 #define SYS_NAME_ID_ia64_linux2		2200
 #define SYS_NAME_ID_ia64_linux22	2201
@@ -294,7 +298,11 @@
 #define SYS_NAME_ID_amd64_fbsd_80       3011
 #define SYS_NAME_ID_amd64_fbsd_81       3012
 #define SYS_NAME_ID_amd64_fbsd_82       3013
+#define SYS_NAME_ID_amd64_fbsd_83       3014
+#define SYS_NAME_ID_amd64_fbsd_84       3015
 #define SYS_NAME_ID_amd64_fbsd_90       3020
+#define SYS_NAME_ID_amd64_fbsd_91       3022
+#define SYS_NAME_ID_amd64_fbsd_100     3030
 
 #define SYS_NAME_ID_amd64_w2k           3400
 
diff --git a/src/config/param.amd64_fbsd_100.h b/src/config/param.amd64_fbsd_100.h
new file mode 100644
index 0000000..6fba1b4
--- /dev/null
+++ b/src/config/param.amd64_fbsd_100.h
@@ -0,0 +1,215 @@
+#ifndef	AFS_PARAM_H
+#define	AFS_PARAM_H
+
+/* Machine / Operating system information */
+#define SYS_NAME	"amd64_fbsd_100"
+#define SYS_NAME_ID	SYS_NAME_ID_amd64_fbsd_100
+
+#define AFSLITTLE_ENDIAN    1
+#define AFS_HAVE_FFS        1	/* Use system's ffs. */
+#define AFS_HAVE_STATVFS    1	/* System doesn't support statvfs */
+#define AFS_VM_RDWR_ENV	    1	/* read/write implemented via VM */
+
+
+#ifndef UKERNEL
+/* This section for kernel libafs compiles only */
+
+#ifndef IGNORE_STDS_H
+#include <sys/param.h>
+#endif
+
+#define AFS_XBSD_ENV 1		/* {Free,Open,Net}BSD */
+#define AFS_X86_XBSD_ENV 1
+
+#define AFS_NAMEI_ENV     1	/* User space interface to file system */
+#define AFS_64BIT_ENV 1
+#define AFS_64BIT_CLIENT 1
+#define AFS_64BITPOINTER_ENV 1
+#define AFS_64BITUSERPOINTER_ENV	1
+#define AFS_64BIT_IOPS_ENV 1	/* Needed for NAMEI */
+#define AFS_FBSD_ENV 1
+#define AFS_FBSD50_ENV 1
+#define AFS_FBSD51_ENV 1
+#define AFS_FBSD52_ENV 1
+#define AFS_FBSD53_ENV 1
+#define AFS_FBSD60_ENV 1
+#define AFS_FBSD61_ENV 1
+#define AFS_FBSD62_ENV 1
+#define AFS_FBSD70_ENV 1
+#define AFS_FBSD71_ENV 1
+#define AFS_FBSD80_ENV 1
+#define AFS_FBSD81_ENV 1
+#define AFS_FBSD90_ENV 1
+#define AFS_FBSD91_ENV 1
+#define AFS_FBSD100_ENV 1
+#define AFS_X86_FBSD_ENV 1
+#define AFS_X86_FBSD50_ENV 1
+#define AFS_X86_FBSD60_ENV 1 /* added at 70--ie, some changes should port <-- */
+#define AFS_X86_FBSD62_ENV 1
+#define AFS_X86_FBSD70_ENV 1
+#define AFS_X86_FBSD71_ENV 1
+#define AFS_X86_FBSD80_ENV 1
+#define AFS_X86_FBSD81_ENV 1
+#define AFS_X86_FBSD90_ENV 1
+#define AFS_X86_FBSD91_ENV 1
+#define AFS_X86_FBSD100_ENV 1
+#define AFS_X86_ENV 1
+#undef  AFS_NONFSTRANS
+#define AFS_NONFSTRANS 1
+#define FTRUNC O_TRUNC
+
+#define IUPD 0x0010
+#define IACC 0x0020
+#define ICHG 0x0040
+#define IMOD 0x0080
+
+#define IN_LOCK(ip)     lockmgr(&ip->i_lock, LK_EXCLUSIVE, \
+                                NULL, curproc)
+#define IN_UNLOCK(ip)   lockmgr(&ip->i_lock, LK_RELEASE, \
+                                NULL, curproc)
+
+#include <afs/afs_sysnames.h>
+
+#define AFS_VFS_ENV	1
+#define AFS_VFSINCL_ENV 1
+#define AFS_GREEDY43_ENV	1
+#define AFS_ENV  	1
+
+#define AFS_SYSCALL	339
+#define AFS_MOUNT_AFS	"afs"
+
+#ifndef MOUNT_UFS
+#define MOUNT_UFS "ufs"
+#endif
+
+#ifndef	MOUNT_AFS
+#define	MOUNT_AFS AFS_MOUNT_AFS
+#endif
+
+#define RXK_LISTENER_ENV 1
+#define AFS_GCPAGS	        0	/* if nonzero, garbage collect PAGs */
+#define AFS_USE_GETTIMEOFDAY    1	/* use gettimeofday to implement rx clock */
+
+/* Extra kernel definitions (from kdefs file) */
+#ifdef _KERNEL
+#define AFS_GLOBAL_SUNLOCK        1
+#define	AFS_VFS34	1	/* What is VFS34??? */
+#define	AFS_SHORTGID	0	/* are group id's short? */
+#define	afsio_iov	uio_iov
+#define	afsio_iovcnt	uio_iovcnt
+#define	afsio_offset	uio_offset
+#define	afsio_seg	uio_segflg
+#define	afsio_resid	uio_resid
+#define	AFS_UIOSYS	UIO_SYSSPACE
+#define	AFS_UIOUSER	UIO_USERSPACE
+#define	AFS_CLBYTES	CLBYTES
+#define	osi_GetTime(x)	microtime(x)
+#define AFS_KALLOC(x)   osi_fbsd_alloc((x), 1)
+#undef	AFS_KALLOC_NOSLEEP
+#define	AFS_KALLOC_NOSLEEP(x) osi_fbsd_alloc((x), 0)
+#define AFS_KFREE(x,y)  osi_fbsd_free((x))
+#define	v_count		v_usecount
+#define v_vfsp		v_mount
+#define vfs_bsize	mnt_stat.f_bsize
+#define vfs_fsid	mnt_stat.f_fsid
+#define va_nodeid	va_fileid
+#define vfs_vnodecovered mnt_vnodecovered
+#define direct		dirent
+#define vnode_t		struct vnode
+
+#ifndef MUTEX_DEFAULT
+#define MUTEX_DEFAULT   0
+#endif /* MUTEX_DEFAULT */
+
+#ifndef SSYS
+#define SSYS            0x00002
+#endif /* SSYS */
+
+#define p_rcred         p_ucred
+
+#if	!defined(ASSEMBLER) && !defined(__LANGUAGE_ASSEMBLY__)
+enum vcexcl { NONEXCL, EXCL };
+
+#ifdef KERNEL
+#ifndef MIN
+#define MIN(A,B) ((A) < (B) ? (A) : (B))
+#endif
+#ifndef MAX
+#define MAX(A,B) ((A) > (B) ? (A) : (B))
+#endif
+#endif /* KERNEL */
+
+#endif /* ! ASSEMBLER & ! __LANGUAGE_ASSEMBLY__ */
+#endif /* _KERNEL */
+
+#else /* !defined(UKERNEL) */
+
+/* This section for user space compiles only */
+
+#define UKERNEL			1	/* user space kernel */
+#define AFS_ENV			1
+#define AFS_VFSINCL_ENV         1
+#define AFS_USR_FBSD50_ENV	1
+#define AFS_USR_FBSD51_ENV	1
+#define AFS_USR_FBSD52_ENV	1
+#define AFS_USR_FBSD53_ENV	1
+#define AFS_USR_FBSD60_ENV	1
+#define AFS_USR_FBSD61_ENV	1
+#define AFS_USR_FBSD70_ENV	1
+#define AFS_USR_FBSD71_ENV	1
+#define AFS_USR_FBSD80_ENV	1
+#define AFS_USR_FBSD81_ENV	1
+#define AFS_USR_FBSD90_ENV	1
+#define AFS_USR_FBSD91_ENV	1
+#define AFS_USR_FBSD100_ENV	1
+#define AFS_USR_FBSD_ENV	1
+#undef  AFS_NONFSTRANS
+#define AFS_NONFSTRANS 1
+
+#define AFS_MOUNT_AFS "afs"	/* The name of the filesystem type. */
+#define AFS_SYSCALL 339
+#define AFS_NAMEI_ENV         1	/* User space interface to file system */
+#define AFS_64BIT_ENV         1
+#define AFS_64BITPOINTER_ENV  1
+#define AFS_64BIT_IOPS_ENV    1	/* Needed for NAMEI */
+#define AFS_USERSPACE_IP_ADDR 1
+#define RXK_LISTENER_ENV      1
+#define AFS_GCPAGS	      0	/* if nonzero, garbage collect PAGs */
+
+#include <afs/afs_sysnames.h>
+
+#define	afsio_iov	uio_iov
+#define	afsio_iovcnt	uio_iovcnt
+#define	afsio_offset	uio_offset
+#define	afsio_seg	uio_segflg
+#define	afsio_fmode	uio_fmode
+#define	afsio_resid	uio_resid
+#define	AFS_UIOSYS	1
+#define	AFS_UIOUSER	UIO_USERSPACE
+#define	AFS_CLBYTES	MCLBYTES
+#define	AFS_MINCHANGE	2
+#define	VATTR_NULL	usr_vattr_null
+
+#define AFS_DIRENT
+#ifndef CMSERVERPREF
+#define CMSERVERPREF
+#endif
+
+#include <sys/param.h>
+#include <sys/types.h>
+#include <sys/mount.h>
+#include <sys/fcntl.h>
+#include <sys/uio.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <limits.h>
+
+#endif /* !defined(UKERNEL) */
+
+/* general user-space compiles */
+
+#if defined(UKERNEL) || !defined(KERNEL)
+#define STDLIB_HAS_MALLOC_PROTOS 1
+#endif
+
+#endif /* AFS_PARAM_H */
diff --git a/src/config/param.amd64_fbsd_83.h b/src/config/param.amd64_fbsd_83.h
new file mode 100644
index 0000000..f568173
--- /dev/null
+++ b/src/config/param.amd64_fbsd_83.h
@@ -0,0 +1,212 @@
+#ifndef	AFS_PARAM_H
+#define	AFS_PARAM_H
+
+/* Machine / Operating system information */
+#define SYS_NAME	"amd64_fbsd_83"
+#define SYS_NAME_ID	SYS_NAME_ID_amd64_fbsd_83
+
+#define AFSLITTLE_ENDIAN    1
+#define AFS_HAVE_FFS        1	/* Use system's ffs. */
+#define AFS_HAVE_STATVFS    1	/* System doesn't support statvfs */
+#define AFS_VM_RDWR_ENV	    1	/* read/write implemented via VM */
+
+
+#ifndef UKERNEL
+/* This section for kernel libafs compiles only */
+
+#ifndef IGNORE_STDS_H
+#include <sys/param.h>
+#endif
+
+#define AFS_XBSD_ENV 1		/* {Free,Open,Net}BSD */
+#define AFS_X86_XBSD_ENV 1
+
+#define AFS_NAMEI_ENV     1	/* User space interface to file system */
+#define AFS_64BIT_ENV 1
+#define AFS_64BIT_CLIENT 1
+#define AFS_64BITPOINTER_ENV 1
+#define AFS_64BITUSERPOINTER_ENV	1
+#define AFS_64BIT_IOPS_ENV 1	/* Needed for NAMEI */
+#define AFS_FBSD_ENV 1
+#define AFS_FBSD50_ENV 1
+#define AFS_FBSD51_ENV 1
+#define AFS_FBSD52_ENV 1
+#define AFS_FBSD53_ENV 1
+#define AFS_FBSD60_ENV 1
+#define AFS_FBSD61_ENV 1
+#define AFS_FBSD62_ENV 1
+#define AFS_FBSD70_ENV 1
+#define AFS_FBSD71_ENV 1
+#define AFS_FBSD80_ENV 1
+#define AFS_FBSD81_ENV 1
+#define AFS_FBSD82_ENV 1
+#define AFS_FBSD83_ENV 1
+#define AFS_X86_FBSD_ENV 1
+#define AFS_X86_FBSD50_ENV 1
+#define AFS_X86_FBSD60_ENV 1 /* added at 70--ie, some changes should port <-- */
+#define AFS_X86_FBSD62_ENV 1
+#define AFS_X86_FBSD70_ENV 1
+#define AFS_X86_FBSD71_ENV 1
+#define AFS_X86_FBSD80_ENV 1
+#define AFS_X86_FBSD81_ENV 1
+#define AFS_X86_FBSD82_ENV 1
+#define AFS_X86_FBSD83_ENV 1
+#define AFS_X86_ENV 1
+#undef  AFS_NONFSTRANS
+#define AFS_NONFSTRANS 1
+#define FTRUNC O_TRUNC
+
+#define IUPD 0x0010
+#define IACC 0x0020
+#define ICHG 0x0040
+#define IMOD 0x0080
+
+#define IN_LOCK(ip)     lockmgr(&ip->i_lock, LK_EXCLUSIVE, \
+                                NULL, curproc)
+#define IN_UNLOCK(ip)   lockmgr(&ip->i_lock, LK_RELEASE, \
+                                NULL, curproc)
+
+#include <afs/afs_sysnames.h>
+
+#define AFS_VFS_ENV	1
+#define AFS_VFSINCL_ENV 1
+#define AFS_GREEDY43_ENV	1
+#define AFS_ENV  	1
+
+#define AFS_SYSCALL	339
+#define AFS_MOUNT_AFS	"afs"
+
+#ifndef MOUNT_UFS
+#define MOUNT_UFS "ufs"
+#endif
+
+#ifndef	MOUNT_AFS
+#define	MOUNT_AFS AFS_MOUNT_AFS
+#endif
+
+#define RXK_LISTENER_ENV 1
+#define AFS_GCPAGS	        0	/* if nonzero, garbage collect PAGs */
+#define AFS_USE_GETTIMEOFDAY    1	/* use gettimeofday to implement rx clock */
+
+/* Extra kernel definitions (from kdefs file) */
+#ifdef _KERNEL
+#define AFS_GLOBAL_SUNLOCK        1
+#define	AFS_VFS34	1	/* What is VFS34??? */
+#define	AFS_SHORTGID	0	/* are group id's short? */
+#define	afsio_iov	uio_iov
+#define	afsio_iovcnt	uio_iovcnt
+#define	afsio_offset	uio_offset
+#define	afsio_seg	uio_segflg
+#define	afsio_resid	uio_resid
+#define	AFS_UIOSYS	UIO_SYSSPACE
+#define	AFS_UIOUSER	UIO_USERSPACE
+#define	AFS_CLBYTES	CLBYTES
+#define	osi_GetTime(x)	microtime(x)
+#define AFS_KALLOC(x)   osi_fbsd_alloc((x), 1)
+#undef	AFS_KALLOC_NOSLEEP
+#define	AFS_KALLOC_NOSLEEP(x) osi_fbsd_alloc((x), 0)
+#define AFS_KFREE(x,y)  osi_fbsd_free((x))
+#define	v_count		v_usecount
+#define v_vfsp		v_mount
+#define vfs_bsize	mnt_stat.f_bsize
+#define vfs_fsid	mnt_stat.f_fsid
+#define va_nodeid	va_fileid
+#define vfs_vnodecovered mnt_vnodecovered
+#define direct		dirent
+#define vnode_t		struct vnode
+
+#ifndef MUTEX_DEFAULT
+#define MUTEX_DEFAULT   0
+#endif /* MUTEX_DEFAULT */
+
+#ifndef SSYS
+#define SSYS            0x00002
+#endif /* SSYS */
+
+#define p_rcred         p_ucred
+
+#if	!defined(ASSEMBLER) && !defined(__LANGUAGE_ASSEMBLY__)
+enum vcexcl { NONEXCL, EXCL };
+
+#ifdef KERNEL
+#ifndef MIN
+#define MIN(A,B) ((A) < (B) ? (A) : (B))
+#endif
+#ifndef MAX
+#define MAX(A,B) ((A) > (B) ? (A) : (B))
+#endif
+#endif /* KERNEL */
+
+#endif /* ! ASSEMBLER & ! __LANGUAGE_ASSEMBLY__ */
+#endif /* _KERNEL */
+
+#else /* !defined(UKERNEL) */
+
+/* This section for user space compiles only */
+
+#define UKERNEL			1	/* user space kernel */
+#define AFS_ENV			1
+#define AFS_VFSINCL_ENV         1
+#define AFS_USR_FBSD50_ENV	1
+#define AFS_USR_FBSD51_ENV	1
+#define AFS_USR_FBSD52_ENV	1
+#define AFS_USR_FBSD53_ENV	1
+#define AFS_USR_FBSD60_ENV	1
+#define AFS_USR_FBSD61_ENV	1
+#define AFS_USR_FBSD70_ENV	1
+#define AFS_USR_FBSD71_ENV	1
+#define AFS_USR_FBSD80_ENV	1
+#define AFS_USR_FBSD81_ENV	1
+#define AFS_USR_FBSD82_ENV	1
+#define AFS_USR_FBSD83_ENV	1
+#define AFS_USR_FBSD_ENV	1
+#undef  AFS_NONFSTRANS
+#define AFS_NONFSTRANS 1
+
+#define AFS_MOUNT_AFS "afs"	/* The name of the filesystem type. */
+#define AFS_SYSCALL 339
+#define AFS_NAMEI_ENV         1	/* User space interface to file system */
+#define AFS_64BIT_ENV         1
+#define AFS_64BITPOINTER_ENV  1
+#define AFS_64BIT_IOPS_ENV    1	/* Needed for NAMEI */
+#define AFS_USERSPACE_IP_ADDR 1
+#define RXK_LISTENER_ENV      1
+#define AFS_GCPAGS	      0	/* if nonzero, garbage collect PAGs */
+
+#include <afs/afs_sysnames.h>
+
+#define	afsio_iov	uio_iov
+#define	afsio_iovcnt	uio_iovcnt
+#define	afsio_offset	uio_offset
+#define	afsio_seg	uio_segflg
+#define	afsio_fmode	uio_fmode
+#define	afsio_resid	uio_resid
+#define	AFS_UIOSYS	1
+#define	AFS_UIOUSER	UIO_USERSPACE
+#define	AFS_CLBYTES	MCLBYTES
+#define	AFS_MINCHANGE	2
+#define	VATTR_NULL	usr_vattr_null
+
+#define AFS_DIRENT
+#ifndef CMSERVERPREF
+#define CMSERVERPREF
+#endif
+
+#include <sys/param.h>
+#include <sys/types.h>
+#include <sys/mount.h>
+#include <sys/fcntl.h>
+#include <sys/uio.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <limits.h>
+
+#endif /* !defined(UKERNEL) */
+
+/* general user-space compiles */
+
+#if defined(UKERNEL) || !defined(KERNEL)
+#define STDLIB_HAS_MALLOC_PROTOS 1
+#endif
+
+#endif /* AFS_PARAM_H */
diff --git a/src/config/param.amd64_fbsd_84.h b/src/config/param.amd64_fbsd_84.h
new file mode 100644
index 0000000..4a99dbe
--- /dev/null
+++ b/src/config/param.amd64_fbsd_84.h
@@ -0,0 +1,215 @@
+#ifndef	AFS_PARAM_H
+#define	AFS_PARAM_H
+
+/* Machine / Operating system information */
+#define SYS_NAME	"amd64_fbsd_84"
+#define SYS_NAME_ID	SYS_NAME_ID_amd64_fbsd_84
+
+#define AFSLITTLE_ENDIAN    1
+#define AFS_HAVE_FFS        1	/* Use system's ffs. */
+#define AFS_HAVE_STATVFS    1	/* System doesn't support statvfs */
+#define AFS_VM_RDWR_ENV	    1	/* read/write implemented via VM */
+
+
+#ifndef UKERNEL
+/* This section for kernel libafs compiles only */
+
+#ifndef IGNORE_STDS_H
+#include <sys/param.h>
+#endif
+
+#define AFS_XBSD_ENV 1		/* {Free,Open,Net}BSD */
+#define AFS_X86_XBSD_ENV 1
+
+#define AFS_NAMEI_ENV     1	/* User space interface to file system */
+#define AFS_64BIT_ENV 1
+#define AFS_64BIT_CLIENT 1
+#define AFS_64BITPOINTER_ENV 1
+#define AFS_64BITUSERPOINTER_ENV	1
+#define AFS_64BIT_IOPS_ENV 1	/* Needed for NAMEI */
+#define AFS_FBSD_ENV 1
+#define AFS_FBSD50_ENV 1
+#define AFS_FBSD51_ENV 1
+#define AFS_FBSD52_ENV 1
+#define AFS_FBSD53_ENV 1
+#define AFS_FBSD60_ENV 1
+#define AFS_FBSD61_ENV 1
+#define AFS_FBSD62_ENV 1
+#define AFS_FBSD70_ENV 1
+#define AFS_FBSD71_ENV 1
+#define AFS_FBSD80_ENV 1
+#define AFS_FBSD81_ENV 1
+#define AFS_FBSD82_ENV 1
+#define AFS_FBSD83_ENV 1
+#define AFS_FBSD84_ENV 1
+#define AFS_X86_FBSD_ENV 1
+#define AFS_X86_FBSD50_ENV 1
+#define AFS_X86_FBSD60_ENV 1 /* added at 70--ie, some changes should port <-- */
+#define AFS_X86_FBSD62_ENV 1
+#define AFS_X86_FBSD70_ENV 1
+#define AFS_X86_FBSD71_ENV 1
+#define AFS_X86_FBSD80_ENV 1
+#define AFS_X86_FBSD81_ENV 1
+#define AFS_X86_FBSD82_ENV 1
+#define AFS_X86_FBSD83_ENV 1
+#define AFS_X86_FBSD84_ENV 1
+#define AFS_X86_ENV 1
+#undef  AFS_NONFSTRANS
+#define AFS_NONFSTRANS 1
+#define FTRUNC O_TRUNC
+
+#define IUPD 0x0010
+#define IACC 0x0020
+#define ICHG 0x0040
+#define IMOD 0x0080
+
+#define IN_LOCK(ip)     lockmgr(&ip->i_lock, LK_EXCLUSIVE, \
+                                NULL, curproc)
+#define IN_UNLOCK(ip)   lockmgr(&ip->i_lock, LK_RELEASE, \
+                                NULL, curproc)
+
+#include <afs/afs_sysnames.h>
+
+#define AFS_VFS_ENV	1
+#define AFS_VFSINCL_ENV 1
+#define AFS_GREEDY43_ENV	1
+#define AFS_ENV  	1
+
+#define AFS_SYSCALL	339
+#define AFS_MOUNT_AFS	"afs"
+
+#ifndef MOUNT_UFS
+#define MOUNT_UFS "ufs"
+#endif
+
+#ifndef	MOUNT_AFS
+#define	MOUNT_AFS AFS_MOUNT_AFS
+#endif
+
+#define RXK_LISTENER_ENV 1
+#define AFS_GCPAGS	        0	/* if nonzero, garbage collect PAGs */
+#define AFS_USE_GETTIMEOFDAY    1	/* use gettimeofday to implement rx clock */
+
+/* Extra kernel definitions (from kdefs file) */
+#ifdef _KERNEL
+#define AFS_GLOBAL_SUNLOCK        1
+#define	AFS_VFS34	1	/* What is VFS34??? */
+#define	AFS_SHORTGID	0	/* are group id's short? */
+#define	afsio_iov	uio_iov
+#define	afsio_iovcnt	uio_iovcnt
+#define	afsio_offset	uio_offset
+#define	afsio_seg	uio_segflg
+#define	afsio_resid	uio_resid
+#define	AFS_UIOSYS	UIO_SYSSPACE
+#define	AFS_UIOUSER	UIO_USERSPACE
+#define	AFS_CLBYTES	CLBYTES
+#define	osi_GetTime(x)	microtime(x)
+#define AFS_KALLOC(x)   osi_fbsd_alloc((x), 1)
+#undef	AFS_KALLOC_NOSLEEP
+#define	AFS_KALLOC_NOSLEEP(x) osi_fbsd_alloc((x), 0)
+#define AFS_KFREE(x,y)  osi_fbsd_free((x))
+#define	v_count		v_usecount
+#define v_vfsp		v_mount
+#define vfs_bsize	mnt_stat.f_bsize
+#define vfs_fsid	mnt_stat.f_fsid
+#define va_nodeid	va_fileid
+#define vfs_vnodecovered mnt_vnodecovered
+#define direct		dirent
+#define vnode_t		struct vnode
+
+#ifndef MUTEX_DEFAULT
+#define MUTEX_DEFAULT   0
+#endif /* MUTEX_DEFAULT */
+
+#ifndef SSYS
+#define SSYS            0x00002
+#endif /* SSYS */
+
+#define p_rcred         p_ucred
+
+#if	!defined(ASSEMBLER) && !defined(__LANGUAGE_ASSEMBLY__)
+enum vcexcl { NONEXCL, EXCL };
+
+#ifdef KERNEL
+#ifndef MIN
+#define MIN(A,B) ((A) < (B) ? (A) : (B))
+#endif
+#ifndef MAX
+#define MAX(A,B) ((A) > (B) ? (A) : (B))
+#endif
+#endif /* KERNEL */
+
+#endif /* ! ASSEMBLER & ! __LANGUAGE_ASSEMBLY__ */
+#endif /* _KERNEL */
+
+#else /* !defined(UKERNEL) */
+
+/* This section for user space compiles only */
+
+#define UKERNEL			1	/* user space kernel */
+#define AFS_ENV			1
+#define AFS_VFSINCL_ENV         1
+#define AFS_USR_FBSD50_ENV	1
+#define AFS_USR_FBSD51_ENV	1
+#define AFS_USR_FBSD52_ENV	1
+#define AFS_USR_FBSD53_ENV	1
+#define AFS_USR_FBSD60_ENV	1
+#define AFS_USR_FBSD61_ENV	1
+#define AFS_USR_FBSD70_ENV	1
+#define AFS_USR_FBSD71_ENV	1
+#define AFS_USR_FBSD80_ENV	1
+#define AFS_USR_FBSD81_ENV	1
+#define AFS_USR_FBSD82_ENV	1
+#define AFS_USR_FBSD83_ENV	1
+#define AFS_USR_FBSD84_ENV	1
+#define AFS_USR_FBSD_ENV	1
+#undef  AFS_NONFSTRANS
+#define AFS_NONFSTRANS 1
+
+#define AFS_MOUNT_AFS "afs"	/* The name of the filesystem type. */
+#define AFS_SYSCALL 339
+#define AFS_NAMEI_ENV         1	/* User space interface to file system */
+#define AFS_64BIT_ENV         1
+#define AFS_64BITPOINTER_ENV  1
+#define AFS_64BIT_IOPS_ENV    1	/* Needed for NAMEI */
+#define AFS_USERSPACE_IP_ADDR 1
+#define RXK_LISTENER_ENV      1
+#define AFS_GCPAGS	      0	/* if nonzero, garbage collect PAGs */
+
+#include <afs/afs_sysnames.h>
+
+#define	afsio_iov	uio_iov
+#define	afsio_iovcnt	uio_iovcnt
+#define	afsio_offset	uio_offset
+#define	afsio_seg	uio_segflg
+#define	afsio_fmode	uio_fmode
+#define	afsio_resid	uio_resid
+#define	AFS_UIOSYS	1
+#define	AFS_UIOUSER	UIO_USERSPACE
+#define	AFS_CLBYTES	MCLBYTES
+#define	AFS_MINCHANGE	2
+#define	VATTR_NULL	usr_vattr_null
+
+#define AFS_DIRENT
+#ifndef CMSERVERPREF
+#define CMSERVERPREF
+#endif
+
+#include <sys/param.h>
+#include <sys/types.h>
+#include <sys/mount.h>
+#include <sys/fcntl.h>
+#include <sys/uio.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <limits.h>
+
+#endif /* !defined(UKERNEL) */
+
+/* general user-space compiles */
+
+#if defined(UKERNEL) || !defined(KERNEL)
+#define STDLIB_HAS_MALLOC_PROTOS 1
+#endif
+
+#endif /* AFS_PARAM_H */
diff --git a/src/config/param.amd64_fbsd_91.h b/src/config/param.amd64_fbsd_91.h
new file mode 100644
index 0000000..3f329b4
--- /dev/null
+++ b/src/config/param.amd64_fbsd_91.h
@@ -0,0 +1,212 @@
+#ifndef	AFS_PARAM_H
+#define	AFS_PARAM_H
+
+/* Machine / Operating system information */
+#define SYS_NAME	"amd64_fbsd_91"
+#define SYS_NAME_ID	SYS_NAME_ID_amd64_fbsd_91
+
+#define AFSLITTLE_ENDIAN    1
+#define AFS_HAVE_FFS        1	/* Use system's ffs. */
+#define AFS_HAVE_STATVFS    1	/* System doesn't support statvfs */
+#define AFS_VM_RDWR_ENV	    1	/* read/write implemented via VM */
+
+
+#ifndef UKERNEL
+/* This section for kernel libafs compiles only */
+
+#ifndef IGNORE_STDS_H
+#include <sys/param.h>
+#endif
+
+#define AFS_XBSD_ENV 1		/* {Free,Open,Net}BSD */
+#define AFS_X86_XBSD_ENV 1
+
+#define AFS_NAMEI_ENV     1	/* User space interface to file system */
+#define AFS_64BIT_ENV 1
+#define AFS_64BIT_CLIENT 1
+#define AFS_64BITPOINTER_ENV 1
+#define AFS_64BITUSERPOINTER_ENV	1
+#define AFS_64BIT_IOPS_ENV 1	/* Needed for NAMEI */
+#define AFS_FBSD_ENV 1
+#define AFS_FBSD50_ENV 1
+#define AFS_FBSD51_ENV 1
+#define AFS_FBSD52_ENV 1
+#define AFS_FBSD53_ENV 1
+#define AFS_FBSD60_ENV 1
+#define AFS_FBSD61_ENV 1
+#define AFS_FBSD62_ENV 1
+#define AFS_FBSD70_ENV 1
+#define AFS_FBSD71_ENV 1
+#define AFS_FBSD80_ENV 1
+#define AFS_FBSD81_ENV 1
+#define AFS_FBSD90_ENV 1
+#define AFS_FBSD91_ENV 1
+#define AFS_X86_FBSD_ENV 1
+#define AFS_X86_FBSD50_ENV 1
+#define AFS_X86_FBSD60_ENV 1 /* added at 70--ie, some changes should port <-- */
+#define AFS_X86_FBSD62_ENV 1
+#define AFS_X86_FBSD70_ENV 1
+#define AFS_X86_FBSD71_ENV 1
+#define AFS_X86_FBSD80_ENV 1
+#define AFS_X86_FBSD81_ENV 1
+#define AFS_X86_FBSD90_ENV 1
+#define AFS_X86_FBSD91_ENV 1
+#define AFS_X86_ENV 1
+#undef  AFS_NONFSTRANS
+#define AFS_NONFSTRANS 1
+#define FTRUNC O_TRUNC
+
+#define IUPD 0x0010
+#define IACC 0x0020
+#define ICHG 0x0040
+#define IMOD 0x0080
+
+#define IN_LOCK(ip)     lockmgr(&ip->i_lock, LK_EXCLUSIVE, \
+                                NULL, curproc)
+#define IN_UNLOCK(ip)   lockmgr(&ip->i_lock, LK_RELEASE, \
+                                NULL, curproc)
+
+#include <afs/afs_sysnames.h>
+
+#define AFS_VFS_ENV	1
+#define AFS_VFSINCL_ENV 1
+#define AFS_GREEDY43_ENV	1
+#define AFS_ENV  	1
+
+#define AFS_SYSCALL	339
+#define AFS_MOUNT_AFS	"afs"
+
+#ifndef MOUNT_UFS
+#define MOUNT_UFS "ufs"
+#endif
+
+#ifndef	MOUNT_AFS
+#define	MOUNT_AFS AFS_MOUNT_AFS
+#endif
+
+#define RXK_LISTENER_ENV 1
+#define AFS_GCPAGS	        0	/* if nonzero, garbage collect PAGs */
+#define AFS_USE_GETTIMEOFDAY    1	/* use gettimeofday to implement rx clock */
+
+/* Extra kernel definitions (from kdefs file) */
+#ifdef _KERNEL
+#define AFS_GLOBAL_SUNLOCK        1
+#define	AFS_VFS34	1	/* What is VFS34??? */
+#define	AFS_SHORTGID	0	/* are group id's short? */
+#define	afsio_iov	uio_iov
+#define	afsio_iovcnt	uio_iovcnt
+#define	afsio_offset	uio_offset
+#define	afsio_seg	uio_segflg
+#define	afsio_resid	uio_resid
+#define	AFS_UIOSYS	UIO_SYSSPACE
+#define	AFS_UIOUSER	UIO_USERSPACE
+#define	AFS_CLBYTES	CLBYTES
+#define	osi_GetTime(x)	microtime(x)
+#define AFS_KALLOC(x)   osi_fbsd_alloc((x), 1)
+#undef	AFS_KALLOC_NOSLEEP
+#define	AFS_KALLOC_NOSLEEP(x) osi_fbsd_alloc((x), 0)
+#define AFS_KFREE(x,y)  osi_fbsd_free((x))
+#define	v_count		v_usecount
+#define v_vfsp		v_mount
+#define vfs_bsize	mnt_stat.f_bsize
+#define vfs_fsid	mnt_stat.f_fsid
+#define va_nodeid	va_fileid
+#define vfs_vnodecovered mnt_vnodecovered
+#define direct		dirent
+#define vnode_t		struct vnode
+
+#ifndef MUTEX_DEFAULT
+#define MUTEX_DEFAULT   0
+#endif /* MUTEX_DEFAULT */
+
+#ifndef SSYS
+#define SSYS            0x00002
+#endif /* SSYS */
+
+#define p_rcred         p_ucred
+
+#if	!defined(ASSEMBLER) && !defined(__LANGUAGE_ASSEMBLY__)
+enum vcexcl { NONEXCL, EXCL };
+
+#ifdef KERNEL
+#ifndef MIN
+#define MIN(A,B) ((A) < (B) ? (A) : (B))
+#endif
+#ifndef MAX
+#define MAX(A,B) ((A) > (B) ? (A) : (B))
+#endif
+#endif /* KERNEL */
+
+#endif /* ! ASSEMBLER & ! __LANGUAGE_ASSEMBLY__ */
+#endif /* _KERNEL */
+
+#else /* !defined(UKERNEL) */
+
+/* This section for user space compiles only */
+
+#define UKERNEL			1	/* user space kernel */
+#define AFS_ENV			1
+#define AFS_VFSINCL_ENV         1
+#define AFS_USR_FBSD50_ENV	1
+#define AFS_USR_FBSD51_ENV	1
+#define AFS_USR_FBSD52_ENV	1
+#define AFS_USR_FBSD53_ENV	1
+#define AFS_USR_FBSD60_ENV	1
+#define AFS_USR_FBSD61_ENV	1
+#define AFS_USR_FBSD70_ENV	1
+#define AFS_USR_FBSD71_ENV	1
+#define AFS_USR_FBSD80_ENV	1
+#define AFS_USR_FBSD81_ENV	1
+#define AFS_USR_FBSD90_ENV	1
+#define AFS_USR_FBSD91_ENV	1
+#define AFS_USR_FBSD_ENV	1
+#undef  AFS_NONFSTRANS
+#define AFS_NONFSTRANS 1
+
+#define AFS_MOUNT_AFS "afs"	/* The name of the filesystem type. */
+#define AFS_SYSCALL 339
+#define AFS_NAMEI_ENV         1	/* User space interface to file system */
+#define AFS_64BIT_ENV         1
+#define AFS_64BITPOINTER_ENV  1
+#define AFS_64BIT_IOPS_ENV    1	/* Needed for NAMEI */
+#define AFS_USERSPACE_IP_ADDR 1
+#define RXK_LISTENER_ENV      1
+#define AFS_GCPAGS	      0	/* if nonzero, garbage collect PAGs */
+
+#include <afs/afs_sysnames.h>
+
+#define	afsio_iov	uio_iov
+#define	afsio_iovcnt	uio_iovcnt
+#define	afsio_offset	uio_offset
+#define	afsio_seg	uio_segflg
+#define	afsio_fmode	uio_fmode
+#define	afsio_resid	uio_resid
+#define	AFS_UIOSYS	1
+#define	AFS_UIOUSER	UIO_USERSPACE
+#define	AFS_CLBYTES	MCLBYTES
+#define	AFS_MINCHANGE	2
+#define	VATTR_NULL	usr_vattr_null
+
+#define AFS_DIRENT
+#ifndef CMSERVERPREF
+#define CMSERVERPREF
+#endif
+
+#include <sys/param.h>
+#include <sys/types.h>
+#include <sys/mount.h>
+#include <sys/fcntl.h>
+#include <sys/uio.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <limits.h>
+
+#endif /* !defined(UKERNEL) */
+
+/* general user-space compiles */
+
+#if defined(UKERNEL) || !defined(KERNEL)
+#define STDLIB_HAS_MALLOC_PROTOS 1
+#endif
+
+#endif /* AFS_PARAM_H */
diff --git a/src/config/param.i386_fbsd_100.h b/src/config/param.i386_fbsd_100.h
new file mode 100644
index 0000000..3e33b57
--- /dev/null
+++ b/src/config/param.i386_fbsd_100.h
@@ -0,0 +1,213 @@
+#ifndef	AFS_PARAM_H
+#define	AFS_PARAM_H
+
+/* Machine / Operating system information */
+#define SYS_NAME	"i386_fbsd_100"
+#define SYS_NAME_ID	SYS_NAME_ID_i386_fbsd_100
+
+#define AFSLITTLE_ENDIAN    1
+#define AFS_HAVE_FFS        1	/* Use system's ffs. */
+#define AFS_HAVE_STATVFS    1	/* System doesn't support statvfs */
+#define AFS_VM_RDWR_ENV	    1	/* read/write implemented via VM */
+#define AFS_FAKEOPEN_ENV    1   /* call afs_FakeOpen as if !AFS_VM_RDWR */
+
+
+#ifndef UKERNEL
+/* This section for kernel libafs compiles only */
+
+#ifndef IGNORE_STDS_H
+#include <sys/param.h>
+#endif
+
+#define AFS_XBSD_ENV 1		/* {Free,Open,Net}BSD */
+#define AFS_X86_XBSD_ENV 1
+
+#define AFS_NAMEI_ENV     1	/* User space interface to file system */
+#define AFS_64BIT_ENV 1
+#define AFS_64BIT_CLIENT 1
+#define AFS_64BIT_IOPS_ENV 1	/* Needed for NAMEI */
+#define AFS_FBSD_ENV 1
+#define AFS_FBSD50_ENV 1
+#define AFS_FBSD51_ENV 1
+#define AFS_FBSD52_ENV 1
+#define AFS_FBSD53_ENV 1
+#define AFS_FBSD60_ENV 1
+#define AFS_FBSD61_ENV 1
+#define AFS_FBSD62_ENV 1
+#define AFS_FBSD70_ENV 1
+#define AFS_FBSD71_ENV 1
+#define AFS_FBSD80_ENV 1
+#define AFS_FBSD81_ENV 1
+#define AFS_FBSD90_ENV 1
+#define AFS_FBSD91_ENV 1
+#define AFS_FBSD100_ENV 1
+#define AFS_X86_FBSD_ENV 1
+#define AFS_X86_FBSD50_ENV 1
+#define AFS_X86_FBSD60_ENV 1 /* added at 70--ie, some changes should port <-- */
+#define AFS_X86_FBSD62_ENV 1
+#define AFS_X86_FBSD70_ENV 1
+#define AFS_X86_FBSD71_ENV 1
+#define AFS_X86_FBSD80_ENV 1
+#define AFS_X86_FBSD81_ENV 1
+#define AFS_X86_FBSD90_ENV 1
+#define AFS_X86_FBSD91_ENV 1
+#define AFS_X86_FBSD100_ENV 1
+#define AFS_X86_ENV 1
+#undef  AFS_NONFSTRANS
+#define AFS_NONFSTRANS 1
+#define FTRUNC O_TRUNC
+
+#define IUPD 0x0010
+#define IACC 0x0020
+#define ICHG 0x0040
+#define IMOD 0x0080
+
+#define IN_LOCK(ip)     lockmgr(&ip->i_lock, LK_EXCLUSIVE, \
+                                NULL, curproc)
+#define IN_UNLOCK(ip)   lockmgr(&ip->i_lock, LK_RELEASE, \
+                                NULL, curproc)
+
+#include <afs/afs_sysnames.h>
+
+#define AFS_VFS_ENV	1
+#define AFS_VFSINCL_ENV 1
+#define AFS_GREEDY43_ENV	1
+#define AFS_ENV  	1
+
+#define AFS_SYSCALL	339
+#define AFS_MOUNT_AFS	"afs"
+
+#ifndef MOUNT_UFS
+#define MOUNT_UFS "ufs"
+#endif
+
+#ifndef	MOUNT_AFS
+#define	MOUNT_AFS AFS_MOUNT_AFS
+#endif
+
+#define RXK_LISTENER_ENV 1
+#define AFS_GCPAGS	        0	/* if nonzero, garbage collect PAGs */
+#define AFS_USE_GETTIMEOFDAY    1	/* use gettimeofday to implement rx clock */
+
+/* Extra kernel definitions (from kdefs file) */
+#ifdef _KERNEL
+#define AFS_GLOBAL_SUNLOCK        1
+#define	AFS_VFS34	1	/* What is VFS34??? */
+#define	AFS_SHORTGID	0	/* are group id's short? */
+#define	afsio_iov	uio_iov
+#define	afsio_iovcnt	uio_iovcnt
+#define	afsio_offset	uio_offset
+#define	afsio_seg	uio_segflg
+#define	afsio_resid	uio_resid
+#define	AFS_UIOSYS	UIO_SYSSPACE
+#define	AFS_UIOUSER	UIO_USERSPACE
+#define	AFS_CLBYTES	CLBYTES
+#define	osi_GetTime(x)	microtime(x)
+#define AFS_KALLOC(x)   osi_fbsd_alloc((x), 1)
+#undef	AFS_KALLOC_NOSLEEP
+#define	AFS_KALLOC_NOSLEEP(x) osi_fbsd_alloc((x), 0)
+#define AFS_KFREE(x,y)  osi_fbsd_free((x))
+#define	v_count		v_usecount
+#define v_vfsp		v_mount
+#define vfs_bsize	mnt_stat.f_bsize
+#define vfs_fsid	mnt_stat.f_fsid
+#define va_nodeid	va_fileid
+#define vfs_vnodecovered mnt_vnodecovered
+#define direct		dirent
+#define vnode_t		struct vnode
+
+#ifndef MUTEX_DEFAULT
+#define MUTEX_DEFAULT   0
+#endif /* MUTEX_DEFAULT */
+
+#ifndef SSYS
+#define SSYS            0x00002
+#endif /* SSYS */
+
+#define p_rcred         p_ucred
+
+#if	!defined(ASSEMBLER) && !defined(__LANGUAGE_ASSEMBLY__)
+enum vcexcl { NONEXCL, EXCL };
+
+#ifdef KERNEL
+#ifndef MIN
+#define MIN(A,B) ((A) < (B) ? (A) : (B))
+#endif
+#ifndef MAX
+#define MAX(A,B) ((A) > (B) ? (A) : (B))
+#endif
+#endif /* KERNEL */
+
+#endif /* ! ASSEMBLER & ! __LANGUAGE_ASSEMBLY__ */
+#endif /* _KERNEL */
+
+#else /* !defined(UKERNEL) */
+
+/* This section for user space compiles only */
+
+#define UKERNEL			1	/* user space kernel */
+#define AFS_ENV			1
+#define AFS_VFSINCL_ENV         1
+#define AFS_USR_FBSD50_ENV	1
+#define AFS_USR_FBSD51_ENV	1
+#define AFS_USR_FBSD52_ENV	1
+#define AFS_USR_FBSD53_ENV	1
+#define AFS_USR_FBSD60_ENV	1
+#define AFS_USR_FBSD61_ENV	1
+#define AFS_USR_FBSD70_ENV	1
+#define AFS_USR_FBSD71_ENV	1
+#define AFS_USR_FBSD80_ENV	1
+#define AFS_USR_FBSD81_ENV	1
+#define AFS_USR_FBSD90_ENV	1
+#define AFS_USR_FBSD91_ENV	1
+#define AFS_USR_FBSD100_ENV	1
+#define AFS_USR_FBSD_ENV	1
+#undef  AFS_NONFSTRANS
+#define AFS_NONFSTRANS 1
+
+#define AFS_MOUNT_AFS "afs"	/* The name of the filesystem type. */
+#define AFS_SYSCALL 339
+#define AFS_NAMEI_ENV         1	/* User space interface to file system */
+#define AFS_64BIT_ENV         1
+#define AFS_64BIT_IOPS_ENV    1	/* Needed for NAMEI */
+#define AFS_USERSPACE_IP_ADDR 1
+#define RXK_LISTENER_ENV      1
+#define AFS_GCPAGS	      0	/* if nonzero, garbage collect PAGs */
+
+#include <afs/afs_sysnames.h>
+
+#define	afsio_iov	uio_iov
+#define	afsio_iovcnt	uio_iovcnt
+#define	afsio_offset	uio_offset
+#define	afsio_seg	uio_segflg
+#define	afsio_fmode	uio_fmode
+#define	afsio_resid	uio_resid
+#define	AFS_UIOSYS	1
+#define	AFS_UIOUSER	UIO_USERSPACE
+#define	AFS_CLBYTES	MCLBYTES
+#define	AFS_MINCHANGE	2
+#define	VATTR_NULL	usr_vattr_null
+
+#define AFS_DIRENT
+#ifndef CMSERVERPREF
+#define CMSERVERPREF
+#endif
+
+#include <sys/param.h>
+#include <sys/types.h>
+#include <sys/mount.h>
+#include <sys/fcntl.h>
+#include <sys/uio.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <limits.h>
+
+#endif /* !defined(UKERNEL) */
+
+/* general user-space compiles */
+
+#if defined(UKERNEL) || !defined(KERNEL)
+#define STDLIB_HAS_MALLOC_PROTOS 1
+#endif
+
+#endif /* AFS_PARAM_H */
diff --git a/src/config/param.i386_fbsd_83.h b/src/config/param.i386_fbsd_83.h
new file mode 100644
index 0000000..0078f32
--- /dev/null
+++ b/src/config/param.i386_fbsd_83.h
@@ -0,0 +1,210 @@
+#ifndef	AFS_PARAM_H
+#define	AFS_PARAM_H
+
+/* Machine / Operating system information */
+#define SYS_NAME	"i386_fbsd_83"
+#define SYS_NAME_ID	SYS_NAME_ID_i386_fbsd_83
+
+#define AFSLITTLE_ENDIAN    1
+#define AFS_HAVE_FFS        1	/* Use system's ffs. */
+#define AFS_HAVE_STATVFS    1	/* System doesn't support statvfs */
+#define AFS_VM_RDWR_ENV	    1	/* read/write implemented via VM */
+#define AFS_FAKEOPEN_ENV    1   /* call afs_FakeOpen as if !AFS_VM_RDWR */
+
+
+#ifndef UKERNEL
+/* This section for kernel libafs compiles only */
+
+#ifndef IGNORE_STDS_H
+#include <sys/param.h>
+#endif
+
+#define AFS_XBSD_ENV 1		/* {Free,Open,Net}BSD */
+#define AFS_X86_XBSD_ENV 1
+
+#define AFS_NAMEI_ENV     1	/* User space interface to file system */
+#define AFS_64BIT_ENV 1
+#define AFS_64BIT_CLIENT 1
+#define AFS_64BIT_IOPS_ENV 1	/* Needed for NAMEI */
+#define AFS_FBSD_ENV 1
+#define AFS_FBSD50_ENV 1
+#define AFS_FBSD51_ENV 1
+#define AFS_FBSD52_ENV 1
+#define AFS_FBSD53_ENV 1
+#define AFS_FBSD60_ENV 1
+#define AFS_FBSD61_ENV 1
+#define AFS_FBSD62_ENV 1
+#define AFS_FBSD70_ENV 1
+#define AFS_FBSD71_ENV 1
+#define AFS_FBSD80_ENV 1
+#define AFS_FBSD81_ENV 1
+#define AFS_FBSD82_ENV 1
+#define AFS_FBSD83_ENV 1
+#define AFS_X86_FBSD_ENV 1
+#define AFS_X86_FBSD50_ENV 1
+#define AFS_X86_FBSD60_ENV 1 /* added at 70--ie, some changes should port <-- */
+#define AFS_X86_FBSD62_ENV 1
+#define AFS_X86_FBSD70_ENV 1
+#define AFS_X86_FBSD71_ENV 1
+#define AFS_X86_FBSD80_ENV 1
+#define AFS_X86_FBSD81_ENV 1
+#define AFS_X86_FBSD82_ENV 1
+#define AFS_X86_FBSD83_ENV 1
+#define AFS_X86_ENV 1
+#undef  AFS_NONFSTRANS
+#define AFS_NONFSTRANS 1
+#define FTRUNC O_TRUNC
+
+#define IUPD 0x0010
+#define IACC 0x0020
+#define ICHG 0x0040
+#define IMOD 0x0080
+
+#define IN_LOCK(ip)     lockmgr(&ip->i_lock, LK_EXCLUSIVE, \
+                                NULL, curproc)
+#define IN_UNLOCK(ip)   lockmgr(&ip->i_lock, LK_RELEASE, \
+                                NULL, curproc)
+
+#include <afs/afs_sysnames.h>
+
+#define AFS_VFS_ENV	1
+#define AFS_VFSINCL_ENV 1
+#define AFS_GREEDY43_ENV	1
+#define AFS_ENV  	1
+
+#define AFS_SYSCALL	339
+#define AFS_MOUNT_AFS	"afs"
+
+#ifndef MOUNT_UFS
+#define MOUNT_UFS "ufs"
+#endif
+
+#ifndef	MOUNT_AFS
+#define	MOUNT_AFS AFS_MOUNT_AFS
+#endif
+
+#define RXK_LISTENER_ENV 1
+#define AFS_GCPAGS	        0	/* if nonzero, garbage collect PAGs */
+#define AFS_USE_GETTIMEOFDAY    1	/* use gettimeofday to implement rx clock */
+
+/* Extra kernel definitions (from kdefs file) */
+#ifdef _KERNEL
+#define AFS_GLOBAL_SUNLOCK        1
+#define	AFS_VFS34	1	/* What is VFS34??? */
+#define	AFS_SHORTGID	0	/* are group id's short? */
+#define	afsio_iov	uio_iov
+#define	afsio_iovcnt	uio_iovcnt
+#define	afsio_offset	uio_offset
+#define	afsio_seg	uio_segflg
+#define	afsio_resid	uio_resid
+#define	AFS_UIOSYS	UIO_SYSSPACE
+#define	AFS_UIOUSER	UIO_USERSPACE
+#define	AFS_CLBYTES	CLBYTES
+#define	osi_GetTime(x)	microtime(x)
+#define AFS_KALLOC(x)   osi_fbsd_alloc((x), 1)
+#undef	AFS_KALLOC_NOSLEEP
+#define	AFS_KALLOC_NOSLEEP(x) osi_fbsd_alloc((x), 0)
+#define AFS_KFREE(x,y)  osi_fbsd_free((x))
+#define	v_count		v_usecount
+#define v_vfsp		v_mount
+#define vfs_bsize	mnt_stat.f_bsize
+#define vfs_fsid	mnt_stat.f_fsid
+#define va_nodeid	va_fileid
+#define vfs_vnodecovered mnt_vnodecovered
+#define direct		dirent
+#define vnode_t		struct vnode
+
+#ifndef MUTEX_DEFAULT
+#define MUTEX_DEFAULT   0
+#endif /* MUTEX_DEFAULT */
+
+#ifndef SSYS
+#define SSYS            0x00002
+#endif /* SSYS */
+
+#define p_rcred         p_ucred
+
+#if	!defined(ASSEMBLER) && !defined(__LANGUAGE_ASSEMBLY__)
+enum vcexcl { NONEXCL, EXCL };
+
+#ifdef KERNEL
+#ifndef MIN
+#define MIN(A,B) ((A) < (B) ? (A) : (B))
+#endif
+#ifndef MAX
+#define MAX(A,B) ((A) > (B) ? (A) : (B))
+#endif
+#endif /* KERNEL */
+
+#endif /* ! ASSEMBLER & ! __LANGUAGE_ASSEMBLY__ */
+#endif /* _KERNEL */
+
+#else /* !defined(UKERNEL) */
+
+/* This section for user space compiles only */
+
+#define UKERNEL			1	/* user space kernel */
+#define AFS_ENV			1
+#define AFS_VFSINCL_ENV         1
+#define AFS_USR_FBSD50_ENV	1
+#define AFS_USR_FBSD51_ENV	1
+#define AFS_USR_FBSD52_ENV	1
+#define AFS_USR_FBSD53_ENV	1
+#define AFS_USR_FBSD60_ENV	1
+#define AFS_USR_FBSD61_ENV	1
+#define AFS_USR_FBSD70_ENV	1
+#define AFS_USR_FBSD71_ENV	1
+#define AFS_USR_FBSD80_ENV	1
+#define AFS_USR_FBSD81_ENV	1
+#define AFS_USR_FBSD82_ENV	1
+#define AFS_USR_FBSD83_ENV	1
+#define AFS_USR_FBSD_ENV	1
+#undef  AFS_NONFSTRANS
+#define AFS_NONFSTRANS 1
+
+#define AFS_MOUNT_AFS "afs"	/* The name of the filesystem type. */
+#define AFS_SYSCALL 339
+#define AFS_NAMEI_ENV         1	/* User space interface to file system */
+#define AFS_64BIT_ENV         1
+#define AFS_64BIT_IOPS_ENV    1	/* Needed for NAMEI */
+#define AFS_USERSPACE_IP_ADDR 1
+#define RXK_LISTENER_ENV      1
+#define AFS_GCPAGS	      0	/* if nonzero, garbage collect PAGs */
+
+#include <afs/afs_sysnames.h>
+
+#define	afsio_iov	uio_iov
+#define	afsio_iovcnt	uio_iovcnt
+#define	afsio_offset	uio_offset
+#define	afsio_seg	uio_segflg
+#define	afsio_fmode	uio_fmode
+#define	afsio_resid	uio_resid
+#define	AFS_UIOSYS	1
+#define	AFS_UIOUSER	UIO_USERSPACE
+#define	AFS_CLBYTES	MCLBYTES
+#define	AFS_MINCHANGE	2
+#define	VATTR_NULL	usr_vattr_null
+
+#define AFS_DIRENT
+#ifndef CMSERVERPREF
+#define CMSERVERPREF
+#endif
+
+#include <sys/param.h>
+#include <sys/types.h>
+#include <sys/mount.h>
+#include <sys/fcntl.h>
+#include <sys/uio.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <limits.h>
+
+#endif /* !defined(UKERNEL) */
+
+/* general user-space compiles */
+
+#if defined(UKERNEL) || !defined(KERNEL)
+#define STDLIB_HAS_MALLOC_PROTOS 1
+#endif
+
+#endif /* AFS_PARAM_H */
diff --git a/src/config/param.i386_fbsd_84.h b/src/config/param.i386_fbsd_84.h
new file mode 100644
index 0000000..014c72d
--- /dev/null
+++ b/src/config/param.i386_fbsd_84.h
@@ -0,0 +1,213 @@
+#ifndef	AFS_PARAM_H
+#define	AFS_PARAM_H
+
+/* Machine / Operating system information */
+#define SYS_NAME	"i386_fbsd_84"
+#define SYS_NAME_ID	SYS_NAME_ID_i386_fbsd_84
+
+#define AFSLITTLE_ENDIAN    1
+#define AFS_HAVE_FFS        1	/* Use system's ffs. */
+#define AFS_HAVE_STATVFS    1	/* System doesn't support statvfs */
+#define AFS_VM_RDWR_ENV	    1	/* read/write implemented via VM */
+#define AFS_FAKEOPEN_ENV    1   /* call afs_FakeOpen as if !AFS_VM_RDWR */
+
+
+#ifndef UKERNEL
+/* This section for kernel libafs compiles only */
+
+#ifndef IGNORE_STDS_H
+#include <sys/param.h>
+#endif
+
+#define AFS_XBSD_ENV 1		/* {Free,Open,Net}BSD */
+#define AFS_X86_XBSD_ENV 1
+
+#define AFS_NAMEI_ENV     1	/* User space interface to file system */
+#define AFS_64BIT_ENV 1
+#define AFS_64BIT_CLIENT 1
+#define AFS_64BIT_IOPS_ENV 1	/* Needed for NAMEI */
+#define AFS_FBSD_ENV 1
+#define AFS_FBSD50_ENV 1
+#define AFS_FBSD51_ENV 1
+#define AFS_FBSD52_ENV 1
+#define AFS_FBSD53_ENV 1
+#define AFS_FBSD60_ENV 1
+#define AFS_FBSD61_ENV 1
+#define AFS_FBSD62_ENV 1
+#define AFS_FBSD70_ENV 1
+#define AFS_FBSD71_ENV 1
+#define AFS_FBSD80_ENV 1
+#define AFS_FBSD81_ENV 1
+#define AFS_FBSD82_ENV 1
+#define AFS_FBSD83_ENV 1
+#define AFS_FBSD84_ENV 1
+#define AFS_X86_FBSD_ENV 1
+#define AFS_X86_FBSD50_ENV 1
+#define AFS_X86_FBSD60_ENV 1 /* added at 70--ie, some changes should port <-- */
+#define AFS_X86_FBSD62_ENV 1
+#define AFS_X86_FBSD70_ENV 1
+#define AFS_X86_FBSD71_ENV 1
+#define AFS_X86_FBSD80_ENV 1
+#define AFS_X86_FBSD81_ENV 1
+#define AFS_X86_FBSD82_ENV 1
+#define AFS_X86_FBSD83_ENV 1
+#define AFS_X86_FBSD84_ENV 1
+#define AFS_X86_ENV 1
+#undef  AFS_NONFSTRANS
+#define AFS_NONFSTRANS 1
+#define FTRUNC O_TRUNC
+
+#define IUPD 0x0010
+#define IACC 0x0020
+#define ICHG 0x0040
+#define IMOD 0x0080
+
+#define IN_LOCK(ip)     lockmgr(&ip->i_lock, LK_EXCLUSIVE, \
+                                NULL, curproc)
+#define IN_UNLOCK(ip)   lockmgr(&ip->i_lock, LK_RELEASE, \
+                                NULL, curproc)
+
+#include <afs/afs_sysnames.h>
+
+#define AFS_VFS_ENV	1
+#define AFS_VFSINCL_ENV 1
+#define AFS_GREEDY43_ENV	1
+#define AFS_ENV  	1
+
+#define AFS_SYSCALL	339
+#define AFS_MOUNT_AFS	"afs"
+
+#ifndef MOUNT_UFS
+#define MOUNT_UFS "ufs"
+#endif
+
+#ifndef	MOUNT_AFS
+#define	MOUNT_AFS AFS_MOUNT_AFS
+#endif
+
+#define RXK_LISTENER_ENV 1
+#define AFS_GCPAGS	        0	/* if nonzero, garbage collect PAGs */
+#define AFS_USE_GETTIMEOFDAY    1	/* use gettimeofday to implement rx clock */
+
+/* Extra kernel definitions (from kdefs file) */
+#ifdef _KERNEL
+#define AFS_GLOBAL_SUNLOCK        1
+#define	AFS_VFS34	1	/* What is VFS34??? */
+#define	AFS_SHORTGID	0	/* are group id's short? */
+#define	afsio_iov	uio_iov
+#define	afsio_iovcnt	uio_iovcnt
+#define	afsio_offset	uio_offset
+#define	afsio_seg	uio_segflg
+#define	afsio_resid	uio_resid
+#define	AFS_UIOSYS	UIO_SYSSPACE
+#define	AFS_UIOUSER	UIO_USERSPACE
+#define	AFS_CLBYTES	CLBYTES
+#define	osi_GetTime(x)	microtime(x)
+#define AFS_KALLOC(x)   osi_fbsd_alloc((x), 1)
+#undef	AFS_KALLOC_NOSLEEP
+#define	AFS_KALLOC_NOSLEEP(x) osi_fbsd_alloc((x), 0)
+#define AFS_KFREE(x,y)  osi_fbsd_free((x))
+#define	v_count		v_usecount
+#define v_vfsp		v_mount
+#define vfs_bsize	mnt_stat.f_bsize
+#define vfs_fsid	mnt_stat.f_fsid
+#define va_nodeid	va_fileid
+#define vfs_vnodecovered mnt_vnodecovered
+#define direct		dirent
+#define vnode_t		struct vnode
+
+#ifndef MUTEX_DEFAULT
+#define MUTEX_DEFAULT   0
+#endif /* MUTEX_DEFAULT */
+
+#ifndef SSYS
+#define SSYS            0x00002
+#endif /* SSYS */
+
+#define p_rcred         p_ucred
+
+#if	!defined(ASSEMBLER) && !defined(__LANGUAGE_ASSEMBLY__)
+enum vcexcl { NONEXCL, EXCL };
+
+#ifdef KERNEL
+#ifndef MIN
+#define MIN(A,B) ((A) < (B) ? (A) : (B))
+#endif
+#ifndef MAX
+#define MAX(A,B) ((A) > (B) ? (A) : (B))
+#endif
+#endif /* KERNEL */
+
+#endif /* ! ASSEMBLER & ! __LANGUAGE_ASSEMBLY__ */
+#endif /* _KERNEL */
+
+#else /* !defined(UKERNEL) */
+
+/* This section for user space compiles only */
+
+#define UKERNEL			1	/* user space kernel */
+#define AFS_ENV			1
+#define AFS_VFSINCL_ENV         1
+#define AFS_USR_FBSD50_ENV	1
+#define AFS_USR_FBSD51_ENV	1
+#define AFS_USR_FBSD52_ENV	1
+#define AFS_USR_FBSD53_ENV	1
+#define AFS_USR_FBSD60_ENV	1
+#define AFS_USR_FBSD61_ENV	1
+#define AFS_USR_FBSD70_ENV	1
+#define AFS_USR_FBSD71_ENV	1
+#define AFS_USR_FBSD80_ENV	1
+#define AFS_USR_FBSD81_ENV	1
+#define AFS_USR_FBSD82_ENV	1
+#define AFS_USR_FBSD83_ENV	1
+#define AFS_USR_FBSD84_ENV	1
+#define AFS_USR_FBSD_ENV	1
+#undef  AFS_NONFSTRANS
+#define AFS_NONFSTRANS 1
+
+#define AFS_MOUNT_AFS "afs"	/* The name of the filesystem type. */
+#define AFS_SYSCALL 339
+#define AFS_NAMEI_ENV         1	/* User space interface to file system */
+#define AFS_64BIT_ENV         1
+#define AFS_64BIT_IOPS_ENV    1	/* Needed for NAMEI */
+#define AFS_USERSPACE_IP_ADDR 1
+#define RXK_LISTENER_ENV      1
+#define AFS_GCPAGS	      0	/* if nonzero, garbage collect PAGs */
+
+#include <afs/afs_sysnames.h>
+
+#define	afsio_iov	uio_iov
+#define	afsio_iovcnt	uio_iovcnt
+#define	afsio_offset	uio_offset
+#define	afsio_seg	uio_segflg
+#define	afsio_fmode	uio_fmode
+#define	afsio_resid	uio_resid
+#define	AFS_UIOSYS	1
+#define	AFS_UIOUSER	UIO_USERSPACE
+#define	AFS_CLBYTES	MCLBYTES
+#define	AFS_MINCHANGE	2
+#define	VATTR_NULL	usr_vattr_null
+
+#define AFS_DIRENT
+#ifndef CMSERVERPREF
+#define CMSERVERPREF
+#endif
+
+#include <sys/param.h>
+#include <sys/types.h>
+#include <sys/mount.h>
+#include <sys/fcntl.h>
+#include <sys/uio.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <limits.h>
+
+#endif /* !defined(UKERNEL) */
+
+/* general user-space compiles */
+
+#if defined(UKERNEL) || !defined(KERNEL)
+#define STDLIB_HAS_MALLOC_PROTOS 1
+#endif
+
+#endif /* AFS_PARAM_H */
diff --git a/src/config/param.i386_fbsd_91.h b/src/config/param.i386_fbsd_91.h
new file mode 100644
index 0000000..739f8a1
--- /dev/null
+++ b/src/config/param.i386_fbsd_91.h
@@ -0,0 +1,210 @@
+#ifndef	AFS_PARAM_H
+#define	AFS_PARAM_H
+
+/* Machine / Operating system information */
+#define SYS_NAME	"i386_fbsd_91"
+#define SYS_NAME_ID	SYS_NAME_ID_i386_fbsd_91
+
+#define AFSLITTLE_ENDIAN    1
+#define AFS_HAVE_FFS        1	/* Use system's ffs. */
+#define AFS_HAVE_STATVFS    1	/* System doesn't support statvfs */
+#define AFS_VM_RDWR_ENV	    1	/* read/write implemented via VM */
+#define AFS_FAKEOPEN_ENV    1   /* call afs_FakeOpen as if !AFS_VM_RDWR */
+
+
+#ifndef UKERNEL
+/* This section for kernel libafs compiles only */
+
+#ifndef IGNORE_STDS_H
+#include <sys/param.h>
+#endif
+
+#define AFS_XBSD_ENV 1		/* {Free,Open,Net}BSD */
+#define AFS_X86_XBSD_ENV 1
+
+#define AFS_NAMEI_ENV     1	/* User space interface to file system */
+#define AFS_64BIT_ENV 1
+#define AFS_64BIT_CLIENT 1
+#define AFS_64BIT_IOPS_ENV 1	/* Needed for NAMEI */
+#define AFS_FBSD_ENV 1
+#define AFS_FBSD50_ENV 1
+#define AFS_FBSD51_ENV 1
+#define AFS_FBSD52_ENV 1
+#define AFS_FBSD53_ENV 1
+#define AFS_FBSD60_ENV 1
+#define AFS_FBSD61_ENV 1
+#define AFS_FBSD62_ENV 1
+#define AFS_FBSD70_ENV 1
+#define AFS_FBSD71_ENV 1
+#define AFS_FBSD80_ENV 1
+#define AFS_FBSD81_ENV 1
+#define AFS_FBSD90_ENV 1
+#define AFS_FBSD91_ENV 1
+#define AFS_X86_FBSD_ENV 1
+#define AFS_X86_FBSD50_ENV 1
+#define AFS_X86_FBSD60_ENV 1 /* added at 70--ie, some changes should port <-- */
+#define AFS_X86_FBSD62_ENV 1
+#define AFS_X86_FBSD70_ENV 1
+#define AFS_X86_FBSD71_ENV 1
+#define AFS_X86_FBSD80_ENV 1
+#define AFS_X86_FBSD81_ENV 1
+#define AFS_X86_FBSD90_ENV 1
+#define AFS_X86_FBSD91_ENV 1
+#define AFS_X86_ENV 1
+#undef  AFS_NONFSTRANS
+#define AFS_NONFSTRANS 1
+#define FTRUNC O_TRUNC
+
+#define IUPD 0x0010
+#define IACC 0x0020
+#define ICHG 0x0040
+#define IMOD 0x0080
+
+#define IN_LOCK(ip)     lockmgr(&ip->i_lock, LK_EXCLUSIVE, \
+                                NULL, curproc)
+#define IN_UNLOCK(ip)   lockmgr(&ip->i_lock, LK_RELEASE, \
+                                NULL, curproc)
+
+#include <afs/afs_sysnames.h>
+
+#define AFS_VFS_ENV	1
+#define AFS_VFSINCL_ENV 1
+#define AFS_GREEDY43_ENV	1
+#define AFS_ENV  	1
+
+#define AFS_SYSCALL	339
+#define AFS_MOUNT_AFS	"afs"
+
+#ifndef MOUNT_UFS
+#define MOUNT_UFS "ufs"
+#endif
+
+#ifndef	MOUNT_AFS
+#define	MOUNT_AFS AFS_MOUNT_AFS
+#endif
+
+#define RXK_LISTENER_ENV 1
+#define AFS_GCPAGS	        0	/* if nonzero, garbage collect PAGs */
+#define AFS_USE_GETTIMEOFDAY    1	/* use gettimeofday to implement rx clock */
+
+/* Extra kernel definitions (from kdefs file) */
+#ifdef _KERNEL
+#define AFS_GLOBAL_SUNLOCK        1
+#define	AFS_VFS34	1	/* What is VFS34??? */
+#define	AFS_SHORTGID	0	/* are group id's short? */
+#define	afsio_iov	uio_iov
+#define	afsio_iovcnt	uio_iovcnt
+#define	afsio_offset	uio_offset
+#define	afsio_seg	uio_segflg
+#define	afsio_resid	uio_resid
+#define	AFS_UIOSYS	UIO_SYSSPACE
+#define	AFS_UIOUSER	UIO_USERSPACE
+#define	AFS_CLBYTES	CLBYTES
+#define	osi_GetTime(x)	microtime(x)
+#define AFS_KALLOC(x)   osi_fbsd_alloc((x), 1)
+#undef	AFS_KALLOC_NOSLEEP
+#define	AFS_KALLOC_NOSLEEP(x) osi_fbsd_alloc((x), 0)
+#define AFS_KFREE(x,y)  osi_fbsd_free((x))
+#define	v_count		v_usecount
+#define v_vfsp		v_mount
+#define vfs_bsize	mnt_stat.f_bsize
+#define vfs_fsid	mnt_stat.f_fsid
+#define va_nodeid	va_fileid
+#define vfs_vnodecovered mnt_vnodecovered
+#define direct		dirent
+#define vnode_t		struct vnode
+
+#ifndef MUTEX_DEFAULT
+#define MUTEX_DEFAULT   0
+#endif /* MUTEX_DEFAULT */
+
+#ifndef SSYS
+#define SSYS            0x00002
+#endif /* SSYS */
+
+#define p_rcred         p_ucred
+
+#if	!defined(ASSEMBLER) && !defined(__LANGUAGE_ASSEMBLY__)
+enum vcexcl { NONEXCL, EXCL };
+
+#ifdef KERNEL
+#ifndef MIN
+#define MIN(A,B) ((A) < (B) ? (A) : (B))
+#endif
+#ifndef MAX
+#define MAX(A,B) ((A) > (B) ? (A) : (B))
+#endif
+#endif /* KERNEL */
+
+#endif /* ! ASSEMBLER & ! __LANGUAGE_ASSEMBLY__ */
+#endif /* _KERNEL */
+
+#else /* !defined(UKERNEL) */
+
+/* This section for user space compiles only */
+
+#define UKERNEL			1	/* user space kernel */
+#define AFS_ENV			1
+#define AFS_VFSINCL_ENV         1
+#define AFS_USR_FBSD50_ENV	1
+#define AFS_USR_FBSD51_ENV	1
+#define AFS_USR_FBSD52_ENV	1
+#define AFS_USR_FBSD53_ENV	1
+#define AFS_USR_FBSD60_ENV	1
+#define AFS_USR_FBSD61_ENV	1
+#define AFS_USR_FBSD70_ENV	1
+#define AFS_USR_FBSD71_ENV	1
+#define AFS_USR_FBSD80_ENV	1
+#define AFS_USR_FBSD81_ENV	1
+#define AFS_USR_FBSD90_ENV	1
+#define AFS_USR_FBSD91_ENV	1
+#define AFS_USR_FBSD_ENV	1
+#undef  AFS_NONFSTRANS
+#define AFS_NONFSTRANS 1
+
+#define AFS_MOUNT_AFS "afs"	/* The name of the filesystem type. */
+#define AFS_SYSCALL 339
+#define AFS_NAMEI_ENV         1	/* User space interface to file system */
+#define AFS_64BIT_ENV         1
+#define AFS_64BIT_IOPS_ENV    1	/* Needed for NAMEI */
+#define AFS_USERSPACE_IP_ADDR 1
+#define RXK_LISTENER_ENV      1
+#define AFS_GCPAGS	      0	/* if nonzero, garbage collect PAGs */
+
+#include <afs/afs_sysnames.h>
+
+#define	afsio_iov	uio_iov
+#define	afsio_iovcnt	uio_iovcnt
+#define	afsio_offset	uio_offset
+#define	afsio_seg	uio_segflg
+#define	afsio_fmode	uio_fmode
+#define	afsio_resid	uio_resid
+#define	AFS_UIOSYS	1
+#define	AFS_UIOUSER	UIO_USERSPACE
+#define	AFS_CLBYTES	MCLBYTES
+#define	AFS_MINCHANGE	2
+#define	VATTR_NULL	usr_vattr_null
+
+#define AFS_DIRENT
+#ifndef CMSERVERPREF
+#define CMSERVERPREF
+#endif
+
+#include <sys/param.h>
+#include <sys/types.h>
+#include <sys/mount.h>
+#include <sys/fcntl.h>
+#include <sys/uio.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <limits.h>
+
+#endif /* !defined(UKERNEL) */
+
+/* general user-space compiles */
+
+#if defined(UKERNEL) || !defined(KERNEL)
+#define STDLIB_HAS_MALLOC_PROTOS 1
+#endif
+
+#endif /* AFS_PARAM_H */
diff --git a/src/config/param.linux26.h b/src/config/param.linux26.h
index 8f6382b..3e69ee3 100644
--- a/src/config/param.linux26.h
+++ b/src/config/param.linux26.h
@@ -64,6 +64,7 @@
 #define AFS_USR_LINUX26_ENV	1
 
 #define AFS_ENV			1
+#define AFS_64BIT_CLIENT	1
 #undef  AFS_NONFSTRANS
 #define AFS_NONFSTRANS 		1
 #define AFS_MOUNT_AFS 		"afs"	/* The name of the filesystem type. */
diff --git a/src/des/key_sched.c b/src/des/key_sched.c
index d856914..c6654f3 100644
--- a/src/des/key_sched.c
+++ b/src/des/key_sched.c
@@ -55,17 +55,13 @@ des_key_sched(des_cblock k, des_key_schedule schedule)
 {
     /* better pass 8 bytes, length not checked here */
 
-    int i, j, n;	/* i = r10, j = r9, n = r8 */
+    int i, j;
     unsigned int temp;	/*  r7 */
     char *p_char;	/* r6 */
     key k_char;
     i = 8;
-    n = 0;
     p_char = k_char;
 
-#ifdef lint
-    n = n;			/* fool it in case of VAXASM */
-#endif
 #ifdef DEBUG
     if (des_debug)
 	fprintf(stderr, "\n\ninput key, left to right = ");
diff --git a/src/kauth/authclient.c b/src/kauth/authclient.c
index 2831a12..0d57771 100644
--- a/src/kauth/authclient.c
+++ b/src/kauth/authclient.c
@@ -352,12 +352,10 @@ CheckTicketAnswer(ka_BBS * oanswer, afs_int32 challenge,
 		  afs_int32 * pwexpires)
 {
     struct ka_ticketAnswer *answer;
-    afs_uint32 cksum;
     unsigned char tempc;
 
     answer = (struct ka_ticketAnswer *)oanswer->SeqBody;
 
-    cksum = ntohl(answer->cksum);
     if (challenge != ntohl(answer->challenge))
 	return KABADPROTOCOL;
     memcpy(&token->sessionKey, &answer->sessionKey,
diff --git a/src/kauth/kadatabase.c b/src/kauth/kadatabase.c
index b204225..0a9fe9c 100644
--- a/src/kauth/kadatabase.c
+++ b/src/kauth/kadatabase.c
@@ -26,11 +26,15 @@
 #include "kautils.h"
 #include "kaserver.h"
 
+#if !defined(offsetof)
+#include <stddef.h>             /* for definition of offsetof() */
+#endif
+
 extern Date cheaderReadTime;	/* time cheader last read in */
 
-#define set_header_word(tt,field,value) kawrite ((tt), ((char *)&(cheader.field) - (char *)&cheader), ((cheader.field = (value)), (char *)&(cheader.field)), sizeof(afs_int32))
+#define set_header_word(tt,field,value) kawrite ((tt), (offsetof(struct kaheader, field)), ((cheader.field = (value)), (char *)&(cheader.field)), sizeof(afs_int32))
 
-#define inc_header_word(tt,field) kawrite ((tt), ((char *)&(cheader.field) - (char *)&cheader), ((cheader.field = (htonl(ntohl(cheader.field)+1))), (char *)&(cheader.field)), sizeof(afs_int32))
+#define inc_header_word(tt,field) kawrite ((tt), (offsetof(struct kaheader, field)), ((cheader.field = (htonl(ntohl(cheader.field)+1))), (char *)&(cheader.field)), sizeof(afs_int32))
 
 static int index_OK(afs_int32);
 
@@ -411,7 +415,11 @@ ka_NewKey(struct ubik_trans *tt, afs_int32 tentryaddr,
     Date now = time(0);
     afs_int32 newkeyver;	/* new key version number */
     afs_int32 newtotalkeyentries = 0, oldtotalkeyentries = 0, keyentries;
-    int foundcurrentkey = 0, addednewkey = 0, modified;
+    int addednewkey = 0, modified;
+#ifdef AUTH_DBM_LOG
+    int foundcurrentkey = 0;
+#endif
+
 
     es_Report("Newkey for %s.%s\n", tentry->userID.name,
 	      tentry->userID.instance);
@@ -460,8 +468,8 @@ ka_NewKey(struct ubik_trans *tt, afs_int32 tentryaddr,
 			    ("Warning: Entry %s.%s contains more than one valid key: fixing\n",
 			     tentry->userID.name, tentry->userID.instance));
 		}
-#endif
 		foundcurrentkey = 1;
+#endif
 	    }
 
 	    /* If we find an oldkey of the same version or
diff --git a/src/kauth/kkids.c b/src/kauth/kkids.c
index d004028..1d75527 100644
--- a/src/kauth/kkids.c
+++ b/src/kauth/kkids.c
@@ -51,11 +51,8 @@ static FILE *childin, *childout;	/* file pointers on pipe to kpwvalid */
 static int
 simplify_name(char *orig_name, char *true_name)
 {
-    int thru_symlink;
     struct stat statbuff;
 
-    thru_symlink = 0;
-
 #ifdef AFS_NT40_ENV
     if (stat(orig_name, &statbuff) < 0) {
 	*true_name = '\0';
@@ -80,7 +77,6 @@ simplify_name(char *orig_name, char *true_name)
 	 * the contents of the link for the file name.
 	 */
 	if ((statbuff.st_mode & S_IFMT) == S_IFLNK) {
-	    thru_symlink = 1;
 	    link_chars_read = readlink(orig_name, true_name, 1024);
 	    if (link_chars_read <= 0) {
 		*true_name = '\0';
diff --git a/src/kauth/kpasswd.c b/src/kauth/kpasswd.c
index c40640a..d81cbef 100644
--- a/src/kauth/kpasswd.c
+++ b/src/kauth/kpasswd.c
@@ -218,7 +218,6 @@ CommandProc(struct cmd_syndesc *as, void *arock)
     struct passwd pwent;
     struct passwd *pw = &pwent;
 
-    int insist;			/* insist on good password quality */
     int lexplicit = 0;		/* servers specified explicitly */
     int local;			/* explicit cell is same a local cell */
     int foundPassword = 0;	/*Not yet, anyway */
@@ -410,7 +409,6 @@ CommandProc(struct cmd_syndesc *as, void *arock)
     give_to_child(passwd);
 
     /* Get new password if it wasn't provided. */
-    insist = 0;
     if (!foundNewPassword) {
 	if (Pipe)
 	    getpipepass(npasswd, sizeof(npasswd));
diff --git a/src/libadmin/test/pts.c b/src/libadmin/test/pts.c
index d4381b4..7d7a202 100644
--- a/src/libadmin/test/pts.c
+++ b/src/libadmin/test/pts.c
@@ -421,7 +421,6 @@ DoPtsUserModify(struct cmd_syndesc *as, void *arock)
     afs_status_t st = 0;
     const char *user = as->parms[USER].items->data;
     pts_UserUpdateEntry_t entry;
-    int have_quota = 0;
     int have_list_status_perm = 0;
     int have_list_groups_owned_perm = 0;
     int have_list_membership_perm = 0;
@@ -432,7 +431,6 @@ DoPtsUserModify(struct cmd_syndesc *as, void *arock)
 	entry.groupCreationQuota =
 	    GetIntFromString(as->parms[GROUPQUOTA].items->data, "bad quota");
 	entry.flag = PTS_USER_UPDATE_GROUP_CREATE_QUOTA;
-	have_quota = 1;
     }
 
     if (as->parms[LISTSTATUS].items) {
diff --git a/src/libadmin/vos/vsprocs.c b/src/libadmin/vos/vsprocs.c
index f313f41..f314e01 100644
--- a/src/libadmin/vos/vsprocs.c
+++ b/src/libadmin/vos/vsprocs.c
@@ -398,8 +398,7 @@ UV_MoveVolume(afs_cell_handle_p cellHandle, afs_uint32 afromvol,
     struct destServer destination;
 
     struct nvldbentry entry;
-    int islocked, pntg;
-    afs_int32 error;
+    int islocked;
     int same;
     afs_int32 store_flags;
 
@@ -414,9 +413,7 @@ UV_MoveVolume(afs_cell_handle_p cellHandle, afs_uint32 afromvol,
     fromtid = 0;
     totid = 0;
     clonetid = 0;
-    error = 0;
     volid = 0;
-    pntg = 0;
     backupId = 0;
     newVol = 0;
 
@@ -464,7 +461,6 @@ UV_MoveVolume(afs_cell_handle_p cellHandle, afs_uint32 afromvol,
 	 */
 	fromconn = UV_Bind(cellHandle, afromserver, AFSCONF_VOLUMEPORT);
 	fromtid = 0;
-	pntg = 1;
 
 	tst =
 	    AFSVolTransCreate(fromconn, afromvol, afrompart, ITOffline,
@@ -519,7 +515,6 @@ UV_MoveVolume(afs_cell_handle_p cellHandle, afs_uint32 afromvol,
 	}
 
 	fromtid = 0;
-	error = 0;
 	goto fail_UV_MoveVolume;
     }
 
@@ -538,7 +533,6 @@ UV_MoveVolume(afs_cell_handle_p cellHandle, afs_uint32 afromvol,
 	}
     }
 
-    pntg = 1;
     toconn = UV_Bind(cellHandle, atoserver, AFSCONF_VOLUMEPORT);	/* get connections to the servers */
     fromconn = UV_Bind(cellHandle, afromserver, AFSCONF_VOLUMEPORT);
     fromtid = totid = 0;	/* initialize to uncreated */
@@ -2099,11 +2093,9 @@ UV_DumpVolume(afs_cell_handle_p cellHandle, afs_uint32 afromvol,
     afs_int32 rcode;
 
     struct nvldbentry entry;
-    afs_int32 error;
     int islocked;
 
     islocked = 0;
-    error = 0;
     rxError = 0;
     fromcall = (struct rx_call *)0;
     fromconn = (struct rx_connection *)0;
@@ -2300,7 +2292,6 @@ UV_RestoreVolume(afs_cell_handle_p cellHandle, afs_int32 toserver,
     afs_int32 temptid;
     int success;
     struct nvldbentry entry;
-    afs_int32 error;
     int islocked;
     struct restoreCookie cookie;
     int reuseID;
@@ -2311,7 +2302,6 @@ UV_RestoreVolume(afs_cell_handle_p cellHandle, afs_int32 toserver,
     memset(&cookie, 0, sizeof(cookie));
     islocked = 0;
     success = 0;
-    error = 0;
     reuseID = 1;
     tocall = (struct rx_call *)0;
     toconn = (struct rx_connection *)0;
@@ -3519,7 +3509,6 @@ CheckVldb(afs_cell_handle_p cellHandle, struct nvldbentry *entry,
     int islocked = 0;
     int pass = 0;
     afs_int32 modentry = 0;
-    afs_int32 delentry = 0;
 
     if (modified) {
 	*modified = 0;
@@ -3583,7 +3572,6 @@ CheckVldb(afs_cell_handle_p cellHandle, struct nvldbentry *entry,
 	    if (tst) {
 		goto fail_CheckVldb;
 	    }
-	    delentry = 1;
 	} else {
 	    /* Replace old entry with our new one */
 	    if (!VLDB_ReplaceEntry
@@ -3626,7 +3614,6 @@ UV_SyncServer(afs_cell_handle_p cellHandle, struct rx_connection *server,
 {
     int rc = 0;
     afs_status_t tst = 0;
-    afs_int32 code, vcode;
     int noError;
     afs_int32 nentries, tentries = 0;
     struct VldbListByAttributes attributes;
@@ -3637,8 +3624,6 @@ UV_SyncServer(afs_cell_handle_p cellHandle, struct rx_connection *server,
     afs_int32 si, nsi;
     afs_int32 modified = 0;
 
-    code = 0;
-    vcode = 0;
     noError = 1;
     arrayEntries.nbulkentries_val = 0;
 
@@ -3701,14 +3686,13 @@ UV_RenameVolume(afs_cell_handle_p cellHandle, struct nvldbentry *entry,
     int rc = 0;
     afs_status_t tst = 0;
     afs_status_t etst = 0;
-    afs_int32 rcode, error;
+    afs_int32 rcode;
     int i, index;
     char nameBuffer[256];
     afs_int32 tid;
     struct rx_connection *aconn;
     int islocked;
 
-    error = 0;
     aconn = (struct rx_connection *)0;
     tid = 0;
     islocked = 0;
@@ -4065,12 +4049,10 @@ int
 UV_VolumeZap(afs_cell_handle_p cellHandle, struct rx_connection *server,
 	     unsigned int partition, afs_uint32 volumeId, afs_status_p st)
 {
-    afs_int32 rcode, ttid, error, code;
+    afs_int32 rcode, ttid;
     int rc = 0;
     afs_status_t tst = 0;
 
-    code = 0;
-    error = 0;
     ttid = 0;
 
     tst = AFSVolTransCreate(server, volumeId, partition, ITOffline, &ttid);
diff --git a/src/packaging/MacOS/buildpkg.sh.in b/src/packaging/MacOS/buildpkg.sh.in
index 59bdfb1..9190d8b 100644
--- a/src/packaging/MacOS/buildpkg.sh.in
+++ b/src/packaging/MacOS/buildpkg.sh.in
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!/bin/bash
 # Portions Copyright (c) 2003, 2006 Apple Computer, Inc.  All rights reserved.
 
 if [ -z "$1" ]; then
@@ -45,27 +45,19 @@ PKGROOT=$CURDIR/pkgroot
 PKGRES=$CURDIR/pkgres
 DPKGROOT=$CURDIR/dpkgroot
 DPKGRES=$CURDIR/dpkgres
-if [ $majorvers -ge 7 ]; then
-    SEP=:
-    package=/Developer/Applications/Utilities/PackageMaker.app/Contents/MacOS/PackageMaker
-    if [ ! -x $package ]; then
-       echo "PackageMaker does not exist. Please run this script on a MacOS X system"
-      echo "with the DeveloperTools package installed"
-      exit 1
-    fi
+PACKAGEMAKER=""
+if [ -e "/Developer/usr/bin/packagemaker" ]; then
+    PACKAGEMAKER="/Developer/usr/bin/packagemaker"
 else
-    SEP=.
-    package=/usr/bin/package
-    if [ ! -f $package ]; then
-       echo "$package does not exist. Please run this script on a MacOS X system"
-      echo "with the BSD subsystem installed"
-      exit 1
-    fi
-    if grep -q 'set resDir = ""' $package ; then
-       echo $package is buggy.
-       echo remove the line \''set resDir = ""'\' from $package and try again
-       exit 1
-    fi
+    while IFS= read -d $'\0' -r file ; do
+        if [ -e "$file/Contents/MacOS/PackageMaker" ]; then
+            PACKAGEMAKER="$file/Contents/MacOS/PackageMaker"
+        fi
+    done < <(mdfind -0 "(kMDItemCFBundleIdentifier == 'com.apple.PackageMaker')")
+fi
+if [ -z "$PACKAGEMAKER" ]; then
+    echo "packagemaker not found"
+    exit 1
 fi
 
 if [ $firstpass = yes ]; then
@@ -107,6 +99,8 @@ if [ $firstpass = yes ]; then
        exit 1
     fi
 
+    SEP=:
+
     rm -rf $PKGROOT
     mkdir $PKGROOT
 
@@ -223,9 +217,9 @@ if [ $secondpass = yes ]; then
 	cp background.jpg $DPKGRES/background.jpg
 	chown -R root${SEP}wheel $DPKGRES
 	rm -rf $CURDIR/OpenAFS-debug-extension.pkg
-	echo $package -build -p $CURDIR/OpenAFS-debug-extension.pkg -f $DPKGROOT -r $DPKGRES \
+	echo $PACKAGEMAKER -build -p $CURDIR/OpenAFS-debug-extension.pkg -f $DPKGROOT -r $DPKGRES \
 	    -i OpenAFS-debug.Info.plist -d OpenAFS-debug.Description.plist
-	$package -build -p $CURDIR/OpenAFS-debug-extension.pkg -f $DPKGROOT -r $DPKGRES \
+	"$PACKAGEMAKER" -build -p $CURDIR/OpenAFS-debug-extension.pkg -f $DPKGROOT -r $DPKGRES \
 	    -i OpenAFS-debug.Info.plist -d OpenAFS-debug.Description.plist
     fi
 
@@ -255,13 +249,13 @@ if [ $secondpass = yes ]; then
     chown -R root${SEP}wheel $PKGRES
     rm -rf $CURDIR/OpenAFS.pkg
     if [ $majorvers -ge 7 ]; then
-	echo $package -build -p $CURDIR/OpenAFS.pkg -f $PKGROOT -r $PKGRES \
+	echo $PACKAGEMAKER -build -p $CURDIR/OpenAFS.pkg -f $PKGROOT -r $PKGRES \
 	    -i OpenAFS.Info.plist -d OpenAFS.Description.plist
-	$package -build -p $CURDIR/OpenAFS.pkg -f $PKGROOT -r $PKGRES \
+	"$PACKAGEMAKER" -build -p $CURDIR/OpenAFS.pkg -f $PKGROOT -r $PKGRES \
 	    -i OpenAFS.Info.plist -d OpenAFS.Description.plist
     else
-	echo $package $PKGROOT $RESSRC/OpenAFS.info -r $PKGRES
-	(cd $CURDIR && $package $PKGROOT $RESSRC/OpenAFS.info -r $PKGRES)
+	echo $PACKAGEMAKER $PKGROOT $RESSRC/OpenAFS.info -r $PKGRES
+	(cd $CURDIR && "$PACKAGEMAKER" $PKGROOT $RESSRC/OpenAFS.info -r $PKGRES)
 	#old versions of package didn't handle this properly
 	if [ ! -r $CURDIR/OpenAFS.pkg/Contents ]; then
 		mkdir -p $CURDIR/OpenAFS.pkg/Contents/Resources
diff --git a/src/packaging/RedHat/openafs-client.service b/src/packaging/RedHat/openafs-client.service
index bc95057..936762e 100644
--- a/src/packaging/RedHat/openafs-client.service
+++ b/src/packaging/RedHat/openafs-client.service
@@ -15,4 +15,4 @@ ExecStop=/sbin/rmmod openafs
 KillMode=none
 
 [Install]
-WantedBy=multi-user.target
+WantedBy=multi-user.target remote-fs.target
diff --git a/src/packaging/RedHat/openafs.spec.in b/src/packaging/RedHat/openafs.spec.in
index b38d3a6..fc099db 100644
--- a/src/packaging/RedHat/openafs.spec.in
+++ b/src/packaging/RedHat/openafs.spec.in
@@ -1055,43 +1055,22 @@ install -p -m 644 src/packaging/RedHat/openafs-cacheinfo $uve/cacheinfo
 install -d -m 755 $RPM_BUILD_ROOT%{_prefix}/src
 cp -a libafs_tree $RPM_BUILD_ROOT%{_prefix}/src/%{name}-%{dkms_version}
 
-%if 0%{?fedora}
-
-cat > $RPM_BUILD_ROOT%{_prefix}/src/%{name}-%{dkms_version}/dkms.conf <<EOF
-
-PACKAGE_VERSION="%{dkms_version}"
-
-# Items below here should not have to change with each driver version
-PACKAGE_NAME="%{name}"
-MAKE[0]="KMODNAME=openafs.ko; DSTKMOD=\\".\\"; [ \\"\\\`echo \\"\${kernelver_array[0]}\${kernelver[0]}\\" | sed -e 's/^\\([0-9]*\\.[0-9]*\\)\\..*/\\1/'\\\`\\" = \\"2.4\\" ] && KMODNAME=\\"libafs-*\\" && DSTKMOD=openafs.o; ./configure --with-linux-kernel-headers=\${kernel_source_dir} --with-linux-kernel-packaging; make; mv src/libafs/MODLOAD-*/\\\\\\\$KMODNAME \\\\\\\$DSTKMOD"
-CLEAN="make -C src/libafs clean"
-
-BUILT_MODULE_NAME[0]="\$PACKAGE_NAME"
-DEST_MODULE_LOCATION[0]="/kernel/3rdparty/\$PACKAGE_NAME/"
-STRIP[0]=no
-AUTOINSTALL=yes
-
-EOF
-
-%else
-cat > $RPM_BUILD_ROOT%{_prefix}/src/%{name}-%{dkms_version}/dkms.conf <<EOF
+cat > $RPM_BUILD_ROOT%{_prefix}/src/%{name}-%{dkms_version}/dkms.conf <<"EOF"
 
 PACKAGE_VERSION="%{dkms_version}"
 
 # Items below here should not have to change with each driver version
 PACKAGE_NAME="%{name}"
-MAKE[0]="KMODNAME=openafs.ko; DSTKMOD=\\".\\"; [ \\"\\\`echo \\"\${kernelver_array[0]}\${kernelver[0]}\\" | sed -e 's/^\\([0-9]*\\.[0-9]*\\)\\..*/\\1/'\\\`\\" = \\"2.4\\" ] && KMODNAME=\\"libafs-*\\" && DSTKMOD=openafs.o; ./configure --with-linux-kernel-headers=\${kernel_source_dir} --with-linux-kernel-packaging; make; mv src/libafs/MODLOAD-*/\\\$KMODNAME \\\$DSTKMOD"
+MAKE[0]='./configure --with-linux-kernel-headers=${kernel_source_dir} --with-linux-kernel-packaging && make && case "${kernelver_array[0]}${kernelver[0]}" in 2.4.*) mv src/libafs/MODLOAD-*/libafs-* openafs.o ;; *) mv src/libafs/MODLOAD-*/openafs.ko . ;; esac'
 CLEAN="make -C src/libafs clean"
 
-BUILT_MODULE_NAME[0]="\$PACKAGE_NAME"
-DEST_MODULE_LOCATION[0]="/kernel/3rdparty/\$PACKAGE_NAME/"
+BUILT_MODULE_NAME[0]="$PACKAGE_NAME"
+DEST_MODULE_LOCATION[0]="/kernel/3rdparty/$PACKAGE_NAME/"
 STRIP[0]=no
 AUTOINSTALL=yes
 
 EOF
 
-%endif
-
 #
 # install kernel-source
 #
diff --git a/src/platform/DARWIN/AFSPreference/AFSBackgrounder/AFSBackgrounderDelegate.h b/src/platform/DARWIN/AFSPreference/AFSBackgrounder/AFSBackgrounderDelegate.h
index c4799c6..371ac82 100644
--- a/src/platform/DARWIN/AFSPreference/AFSBackgrounder/AFSBackgrounderDelegate.h
+++ b/src/platform/DARWIN/AFSPreference/AFSBackgrounder/AFSBackgrounderDelegate.h
@@ -65,7 +65,6 @@
 - (NSImage*)getImageFromBundle:(NSString*)fileName fileExt:(NSString*)ext;
 - (NSImage*)imageToRender;
 - (void)menuNeedsUpdate:(NSMenu *)menu;
-- (void)repairHelperTool;
 - (void) afsVolumeMountChange:(NSNotification *)notification;
 - (void) updateLinkModeStatusWithpreferenceStatus:(BOOL)status;
 -(NSStatusItem*)statusItem;
diff --git a/src/platform/DARWIN/AFSPreference/AFSBackgrounder/AFSBackgrounderDelegate.m b/src/platform/DARWIN/AFSPreference/AFSBackgrounder/AFSBackgrounderDelegate.m
index 94bef26..d2d81fa 100644
--- a/src/platform/DARWIN/AFSPreference/AFSBackgrounder/AFSBackgrounderDelegate.m
+++ b/src/platform/DARWIN/AFSPreference/AFSBackgrounder/AFSBackgrounderDelegate.m
@@ -335,22 +335,26 @@
 - (void)startStopAfs:(id)sender
 {
 	@try {
-		BOOL currentAfsState = NO;
+	    BOOL currentAfsState = NO;
+	    OSErr status = [[AuthUtil shared] autorize];
+	    if(status == noErr){
 		currentAfsState = [afsMngr checkAfsStatus];
 		// make the parameter to call the root helper app
 		if(currentAfsState){
-			//shutdown afs
-			NSLog(@"Shutting down afs");
-			[afsMngr shutdown];
+		    //shutdown afs
+		    NSLog(@"Shutting down afs");
+		    [afsMngr shutdown];
 		} else {
-			//Start afs
-			NSLog(@"Starting up afs");
-			[afsMngr startup];
+		    //Start afs
+		    NSLog(@"Starting up afs");
+		    [afsMngr startup];
 		}
+	    }
 	}@catch (NSException * e) {
 		NSLog(@"error %@", [e reason]);
 	}@finally {
 		[self updateAfsStatus:nil];
+		[[AuthUtil shared] deautorize];
 		//Send notification to preferencepane
 		[[NSDistributedNotificationCenter defaultCenter] postNotificationName:kAfsCommanderID object:kMenuExtraEventOccured];
 	}
@@ -525,53 +529,6 @@
 	else return NSOffState;
 }
 
-// -------------------------------------------------------------------------------
-//  repairHelperTool:
-// -------------------------------------------------------------------------------
-- (void) repairHelperTool
-{
-	struct stat st;
-    int fdTool;
-	int status = 0; 
-	NSString *afshlpPath = [[NSBundle mainBundle] pathForResource:@"afshlp" ofType:nil];
-	
-	
-    
-    // Open tool exclusively, so nobody can change it while we bless it.
-    fdTool = open([afshlpPath UTF8String], O_NONBLOCK | O_RDONLY | O_EXLOCK, 0);
-    
-    if(fdTool == -1)
-    {
-        NSLog(@"Exclusive open while repairing tool failed: %d.", errno);
-        exit(-1);
-    }
-    
-    if(fstat(fdTool, &st))
-    {
-        NSLog(@"fstat failed.");
-        exit(-1);
-    }
-    
-    if(st.st_uid != 0)
-    {
-		status = [[AuthUtil shared] autorize];
-		if(status == noErr){
-			fchown(fdTool, 0, st.st_gid);
-			
-			// Disable group and world writability and make setuid root.
-			fchmod(fdTool, (st.st_mode & (~(S_IWGRP | S_IWOTH)))/* | S_ISUID*/);
-			const char *args[] = {"root", [afshlpPath UTF8String],0L};
-			[[AuthUtil shared] execUnixCommand:"/usr/sbin/chown" 
-										  args:args
-										output:nil];
-			[[AuthUtil shared] deautorize];
-		}
-    } else  NSLog(@"st_uid = 0");
-    close(fdTool);
-    NSLog(@"Self-repair done.");
-	
-}
-
 #pragma mark accessor
 // -------------------------------------------------------------------------------
 //  statusItem
diff --git a/src/platform/DARWIN/AFSPreference/AFSBackgrounder/AFSMenuExtra.h b/src/platform/DARWIN/AFSPreference/AFSBackgrounder/AFSMenuExtra.h
index 1c41e24..54487b3 100644
--- a/src/platform/DARWIN/AFSPreference/AFSBackgrounder/AFSMenuExtra.h
+++ b/src/platform/DARWIN/AFSPreference/AFSBackgrounder/AFSMenuExtra.h
@@ -52,6 +52,5 @@
 - (NSImage*)getImageFromBundle:(NSString*)fileName fileExt:(NSString*)ext;
 - (NSImage*)imageToRender;
 - (void)updateMenu;
-- (void)repairHelperTool;
 - (void) afsVolumeMountChange:(NSNotification *)notification;
 @end
diff --git a/src/platform/DARWIN/AFSPreference/AFSBackgrounder/AFSMenuExtra.m b/src/platform/DARWIN/AFSPreference/AFSBackgrounder/AFSMenuExtra.m
index 0073a31..3816862 100644
--- a/src/platform/DARWIN/AFSPreference/AFSBackgrounder/AFSMenuExtra.m
+++ b/src/platform/DARWIN/AFSPreference/AFSBackgrounder/AFSMenuExtra.m
@@ -177,62 +177,6 @@
 }
 
 // -------------------------------------------------------------------------------
-//  -(void) readPreferenceFile
-// -------------------------------------------------------------------------------
-- (void)startStopAfs:(id)sender
-{
-	if(!afsSysPath) return;
-	
-	OSStatus status = noErr;
-	NSString *afsdPath = [TaskUtil searchExecutablePath:@"afsd"];
-	NSString *rootHelperApp = nil;
-	BOOL currentAfsState = NO;
-	
-	@try {
-		if(afsdPath == nil) return;
-		AFSPropertyManager *afsMngr = [[AFSPropertyManager alloc] initWithAfsPath:afsSysPath];
-		currentAfsState = [afsMngr checkAfsStatus];
-		[afsMngr release];
-		
-		rootHelperApp = [[self bundle] pathForResource:@"afshlp" ofType:@""];
-
-		//Check helper app
-		[self repairHelperTool];
-		
-		// make the parameter to call the root helper app
-		status = [[AuthUtil shared] autorize];
-		if(status == noErr){
-			if(currentAfsState){
-				//shutdown afs
-				NSMutableString *afsKextPath = [[NSMutableString alloc] initWithCapacity:256];
-				[afsKextPath setString:afsSysPath];
-				[afsKextPath appendString:@"/etc/afs.kext"];
-				
-				const char *stopAfsArgs[] = {"stop_afs", [afsKextPath  UTF8String], [afsdPath UTF8String], 0L};
-				[[AuthUtil shared] execUnixCommand:[rootHelperApp UTF8String] 
-											  args:stopAfsArgs
-											output:nil];
-			} else {
-				const char *startAfsArgs[] = {[[[self bundle] pathForResource:@"start_afs" ofType:@"sh"]  UTF8String], [afsSysPath UTF8String], [afsdPath UTF8String], 0L};
-				[[AuthUtil shared] execUnixCommand:[rootHelperApp UTF8String] 
-											  args:startAfsArgs
-											output:nil];
-			}
-		}
-	}
-	@catch (NSException * e) {
-		NSLog([e reason]);
-	}
-	@finally {
-		[[AuthUtil shared] deautorize];
-		[self updateAfsStatus:nil];
-		//Send notification to preferencepane
-		[[NSDistributedNotificationCenter defaultCenter] postNotificationName:afsCommanderID object:kMenuExtraEventOccured];
-	}
-	
-}
-
-// -------------------------------------------------------------------------------
 //  -(void) getToken
 // -------------------------------------------------------------------------------
 - (void)getToken:(id)sender
@@ -368,53 +312,4 @@
 	if(useAklogPrefValue) return [useAklogPrefValue intValue] == NSOnState; 
 	else return NSOffState;
 }
-
-// -------------------------------------------------------------------------------
-//  repairHelperTool:
-// -------------------------------------------------------------------------------
-- (void) repairHelperTool
-{
-	struct stat st;
-    int fdTool;
-	int status = 0; 
-	NSString *afshlpPath = [[self bundle] pathForResource:@"afshlp" ofType:nil];
-	
-	
-    
-    // Open tool exclusively, so nobody can change it while we bless it.
-    fdTool = open([afshlpPath UTF8String], O_NONBLOCK | O_RDONLY | O_EXLOCK, 0);
-    
-    if(fdTool == -1)
-    {
-        NSLog(@"Exclusive open while repairing tool failed: %d.", errno);
-        exit(-1);
-    }
-    
-    if(fstat(fdTool, &st))
-    {
-        NSLog(@"fstat failed.");
-        exit(-1);
-    }
-    
-    if(st.st_uid != 0)
-    {
-		status = [[AuthUtil shared] autorize];
-		if(status == noErr){
-			fchown(fdTool, 0, st.st_gid);
-			
-			// Disable group and world writability and make setuid root.
-			fchmod(fdTool, (st.st_mode & (~(S_IWGRP | S_IWOTH)))/* | S_ISUID*/);
-			const char *args[] = {"root", [afshlpPath UTF8String],0L};
-			[[AuthUtil shared] execUnixCommand:"/usr/sbin/chown" 
-										  args:args
-										output:nil];
-			[[AuthUtil shared] deautorize];
-		}
-    } else  NSLog(@"st_uid = 0");
-    
-	
-    
-    close(fdTool);
-    NSLog(@"Self-repair done.");
-	
-}@end
+@end
diff --git a/src/platform/DARWIN/AFSPreference/AFSBackgrounder/AFSMenuExtraView.h b/src/platform/DARWIN/AFSPreference/AFSBackgrounder/AFSMenuExtraView.h
index 915dc2f..6d1ce18 100644
--- a/src/platform/DARWIN/AFSPreference/AFSBackgrounder/AFSMenuExtraView.h
+++ b/src/platform/DARWIN/AFSPreference/AFSBackgrounder/AFSMenuExtraView.h
@@ -9,7 +9,7 @@
 #import <Cocoa/Cocoa.h>
 #import "AFSBackgrounderDelegate.h"
 
-@interface AFSMenuExtraView : NSView {
+@interface AFSMenuExtraView : NSView <NSMenuDelegate> {
 	AFSBackgrounderDelegate 	*backgrounderDelegator;
 	NSStatusItem 	*statusItem;
 	NSMenu	*statusItemMenu;
diff --git a/src/platform/DARWIN/AFSPreference/AFSCommanderPref.h b/src/platform/DARWIN/AFSPreference/AFSCommanderPref.h
index a9f1cad..7666255 100644
--- a/src/platform/DARWIN/AFSPreference/AFSCommanderPref.h
+++ b/src/platform/DARWIN/AFSPreference/AFSCommanderPref.h
@@ -7,6 +7,7 @@
 //
 
 #import <PreferencePanes/PreferencePanes.h>
+#import <SecurityInterface/SFAuthorizationView.h>
 #import "AFSPropertyManager.h"
 #import "global.h"
 #import "ViewUtility.h"
@@ -20,12 +21,13 @@ int CoreMenuExtraRemoveMenuExtra(void *menuExtra, int whoCares);
 
 
 
-@interface AFSCommanderPref : NSPreferencePane 
+@interface AFSCommanderPref : NSPreferencePane <NSTableViewDataSource, NSTableViewDelegate>
 {
 	//for check system version
 	int prefStartUp;
 	// Main View
 	BOOL startAFSAtLogin;
+    IBOutlet SFAuthorizationView *authView;
 	IBOutlet NSView *afsCommanderView;
 	IBOutlet NSSearchField *textSearchField;
 	IBOutlet NSTextField *afsDefaultCellLabel;
@@ -104,6 +106,7 @@ int CoreMenuExtraRemoveMenuExtra(void *menuExtra, int whoCares);
 	NSLock *tokensLock;
 }
 
+- (BOOL)isUnlocked;
 - (void) mainViewDidLoad;
 - (void) willUnselect;
 - (void) didSelect;
@@ -144,11 +147,8 @@ int CoreMenuExtraRemoveMenuExtra(void *menuExtra, int whoCares);
 - (void) modifyCell:(DBCellElement*) cellElement;
 - (void) modifyCellByIDX:(int) idx;
 - (void) showMessage:(NSString*) message;
-- (void) tableViewCellmanageButtonState:(int) rowSelected;
-- (void) tableViewLinkmanageButtonState:(NSIndexSet *) rowsSelectedIndex;
 - (void) setAfsStatus;
 - (void) refreshTokens:(NSTimer*)theTimer;
-- (void) repairHelperTool;
 - (void) writePreferenceFile;
 - (void) readPreferenceFile;
 - (void) refreshGui:(NSNotification *)notification;
@@ -157,8 +157,13 @@ int CoreMenuExtraRemoveMenuExtra(void *menuExtra, int whoCares);
 - (void)tabView:(NSTabView *)tabView willSelectTabViewItem: (NSTabViewItem *)tabViewItem;
 @end
 
+@interface AFSCommanderPref (TableDelegate)
+- (void) tableViewCellmanageButtonState:(int) rowSelected;
+- (void) tableViewLinkmanageButtonState:(NSIndexSet *) rowsSelectedIndex;
+@end;
+
 @interface AFSCommanderPref (NSTableDataSource)
 - (id) getTableTokensListValue:(int) colId row:(int)row;
 - (id) getTableCelListValue:(int) colId row:(int)row;
 - (id) getTableLinkValue:(int) colId row:(int)row;
-@end;
\ No newline at end of file
+@end;
diff --git a/src/platform/DARWIN/AFSPreference/AFSCommanderPref.m b/src/platform/DARWIN/AFSPreference/AFSCommanderPref.m
index dcc7344..dd6d9bf 100644
--- a/src/platform/DARWIN/AFSPreference/AFSCommanderPref.m
+++ b/src/platform/DARWIN/AFSPreference/AFSCommanderPref.m
@@ -58,7 +58,7 @@
 {
     if ( ( self = [super initWithBundle:bundle] ) != nil ) {
         //appID = kAfsCommanderID;
-		prefStartUp = 1;
+	prefStartUp = 1;
     }
     return self;
 }
@@ -67,16 +67,16 @@
 //  mainView:
 // -------------------------------------------------------------------------------
 - (NSView *) mainView {
-	if (prefStartUp == 1){
-		SInt32 osxMJVers = 0;
-		SInt32 osxMnVers = 0;
-		if (Gestalt(gestaltSystemVersionMajor, &osxMJVers) == noErr && Gestalt(gestaltSystemVersionMinor, &osxMnVers) == noErr) {
-			if (osxMJVers == 10 && osxMnVers>= 5) {
-				[afsCommanderView  setFrameSize:NSMakeSize(668, [afsCommanderView frame].size.height)];
+    if (prefStartUp == 1){
+	SInt32 osxMJVers = 0;
+	SInt32 osxMnVers = 0;
+	if (Gestalt(gestaltSystemVersionMajor, &osxMJVers) == noErr && Gestalt(gestaltSystemVersionMinor, &osxMnVers) == noErr) {
+	    if (osxMJVers == 10 && osxMnVers>= 5) {
+		[afsCommanderView  setFrameSize:NSMakeSize(668, [afsCommanderView frame].size.height)];
                 prefStartUp = 0;
-			}
-		}
+	    }
 	}
+    }
 	
     return afsCommanderView;
 }
@@ -86,12 +86,17 @@
 // -------------------------------------------------------------------------------
 - (void) mainViewDidLoad
 {
-	//CellServDB Table
-	[((NSTableView*)cellList) setDelegate:self];
-	[((NSTableView*)cellList) setTarget:self];
-	[((NSTableView*)cellList) setDoubleAction:@selector(tableDoubleAction:)];
-	
-	
+    //CellServDB Table
+    [cellList setDelegate:self];
+    [cellList setTarget:self];
+    [cellList setDoubleAction:@selector(tableDoubleAction:)];
+
+    // Setup security.
+    AuthorizationItem items = {kAuthorizationRightExecute, 0, NULL, 0};
+    AuthorizationRights rights = {1, &items};
+    [authView setAuthorizationRights:&rights];
+    authView.delegate = self;
+    [authView updateStatus:nil];
 }
 
 // -------------------------------------------------------------------------------
@@ -99,102 +104,102 @@
 // -------------------------------------------------------------------------------
 - (void) didSelect
 {
-	//try to install the launchd file for backgrounder
-	//Remove launchd ctrl file
-	@try {
-		[PListManager installBackgrounderLaunchdFile:YES 
-										resourcePath:[[self bundle] resourcePath]];
-	}
-	@catch (NSException * e) {
-		NSDictionary *excecptDic = [e userInfo];
-		NSNumber *keyNum = [excecptDic objectForKey:@"agent_folder_error"];
-		if(keyNum && [keyNum boolValue]) {
-			// the dir HOME_LAUNCHD_AGENT_FOLDER (PListManager.h) must be created
-			NSBeginAlertSheet([[NSString stringWithString:kDoYouWantCreateTheDirectory] stringByAppendingString:HOME_LAUNCHD_AGENT_FOLDER],
-							  @"Create", @"Cancel", nil,										
-							  [[self mainView] window],	self, @selector(credentialAtLoginTimeEventCreationLaunchAgentDir:returnCode:contextInfo:), NULL, 
-							  nil, @"", nil);
-		}
-	}
-	@finally {
-		
+    //try to install the launchd file for backgrounder
+    //Remove launchd ctrl file
+    @try {
+	[PListManager installBackgrounderLaunchdFile:YES
+		      resourcePath:[[self bundle] resourcePath]];
+    }
+    @catch (NSException * e) {
+	NSDictionary *excecptDic = [e userInfo];
+	NSNumber *keyNum = [excecptDic objectForKey:@"agent_folder_error"];
+	if(keyNum && [keyNum boolValue]) {
+	    // the dir HOME_LAUNCHD_AGENT_FOLDER (PListManager.h) must be created
+	    NSBeginAlertSheet([[NSString stringWithString:kDoYouWantCreateTheDirectory] stringByAppendingString:HOME_LAUNCHD_AGENT_FOLDER],
+			      @"Create", @"Cancel", nil,
+			      [[self mainView] window],	self, @selector(credentialAtLoginTimeEventCreationLaunchAgentDir:returnCode:contextInfo:), NULL,
+			      nil, @"", nil);
 	}
+    }
+    @finally {
 	
-	
-	// Set Developer info
-	[textFieldDevInfoLabel setStringValue:kDevelopInfo];
-	// creating the lock
-	tokensLock = [[NSLock alloc] init];
-	
-	//Initialization cellservdb and token list
-	filteredCellDB = nil;
-	tokenList = nil;
-	
-	[self readPreferenceFile];
-			
-	// alloc the afs property mananger
-	afsProperty = [[AFSPropertyManager alloc] init];
-	
-	// register preference pane to detect menuextra killed by user
-	[[NSDistributedNotificationCenter defaultCenter] addObserver:self
-														selector:@selector(refreshTokensNotify:)
-															name:kAfsCommanderID
-														  object:kMExtraTokenOperation];
-	 
-	[[NSDistributedNotificationCenter defaultCenter] addObserver:self 
-														selector:@selector(refreshGui:) 
-															name:kAfsCommanderID 
-														  object:kMenuExtraEventOccured];
-	
-	//Register for mount/unmount afs volume
-	[[[NSWorkspace sharedWorkspace] notificationCenter] addObserver:self 
-														   selector:@selector(afsVolumeMountChange:) 
-															   name:NSWorkspaceDidMountNotification object:nil];
-	
-	[[[NSWorkspace sharedWorkspace] notificationCenter] addObserver:self 
-														   selector:@selector(afsVolumeMountChange:) 
-															   name:NSWorkspaceDidUnmountNotification object:nil];
-	
-	// set self as table data source
-	[cellList setDataSource:self];
-	[tokensTable setDataSource:self];
-	//[tableViewLink setDataSource:self];
-	//check the afs state
-	[self setAfsStatus];
-	
-	// let show the configuration after prefpane is open
-	[self refreshConfiguration:nil];
-	
-	// refresh the token list
-	//[self refreshTokens:nil];
-	
-	//refresh table to reflect the NSSearchField contained text
-	[self searchCellTextEvent:nil];
+    }
+
+
+    // Set Developer info
+    [textFieldDevInfoLabel setStringValue:kDevelopInfo];
+    // creating the lock
+    tokensLock = [[NSLock alloc] init];
+
+    //Initialization cellservdb and token list
+    filteredCellDB = nil;
+    tokenList = nil;
+
+    [self readPreferenceFile];
+
+    // alloc the afs property mananger
+    afsProperty = [[AFSPropertyManager alloc] init];
+
+    // register preference pane to detect menuextra killed by user
+    [[NSDistributedNotificationCenter defaultCenter] addObserver:self
+						     selector:@selector(refreshTokensNotify:)
+						     name:kAfsCommanderID
+						     object:kMExtraTokenOperation];
+
+    [[NSDistributedNotificationCenter defaultCenter] addObserver:self
+						     selector:@selector(refreshGui:)
+						     name:kAfsCommanderID
+						     object:kMenuExtraEventOccured];
+
+    //Register for mount/unmount afs volume
+    [[[NSWorkspace sharedWorkspace] notificationCenter] addObserver:self
+							selector:@selector(afsVolumeMountChange:)
+							name:NSWorkspaceDidMountNotification object:nil];
+
+    [[[NSWorkspace sharedWorkspace] notificationCenter] addObserver:self
+							selector:@selector(afsVolumeMountChange:)
+							name:NSWorkspaceDidUnmountNotification object:nil];
+
+    // set self as table data source
+    [cellList setDataSource:self];
+    [tokensTable setDataSource:self];
+    //[tableViewLink setDataSource:self];
+    //check the afs state
+    [self setAfsStatus];
+
+    // let show the configuration after prefpane is open
+    [self refreshConfiguration:nil];
+
+    // refresh the token list
+    //[self refreshTokens:nil];
+
+    //refresh table to reflect the NSSearchField contained text
+    [self searchCellTextEvent:nil];
 }
 
 // -------------------------------------------------------------------------------
 //  credentialAtLoginTimeEventCreationLaunchAgentDir:
 // -------------------------------------------------------------------------------
 - (void) credentialAtLoginTimeEventCreationLaunchAgentDir:(NSWindow*)alert returnCode:(int)returnCode contextInfo:(void *)contextInfo {
-	[alert close];
-	switch (returnCode) {
-		case  1:
-			if([[NSFileManager defaultManager] createDirectoryAtPath:[HOME_LAUNCHD_AGENT_FOLDER stringByExpandingTildeInPath] 
-										 withIntermediateDirectories:NO
-														  attributes:nil
-															   error:nil]) {
-				
-				//Create the file
-				[PListManager installBackgrounderLaunchdFile:YES
-												resourcePath:[[self bundle] resourcePath]];
-				[self showMessage:kDirectoryCreated];
-			} else {
-				[self showMessage:kErrorCreatingDirectory];
-			}
-			break;
-		case 0:
-			break;
+    [alert close];
+    switch (returnCode) {
+    case  1:
+	if([[NSFileManager defaultManager] createDirectoryAtPath:[HOME_LAUNCHD_AGENT_FOLDER stringByExpandingTildeInPath]
+					   withIntermediateDirectories:NO
+					   attributes:nil
+					   error:nil]) {
+
+	    //Create the file
+	    [PListManager installBackgrounderLaunchdFile:YES
+			  resourcePath:[[self bundle] resourcePath]];
+	    [self showMessage:kDirectoryCreated];
+	} else {
+	    [self showMessage:kErrorCreatingDirectory];
 	}
+	break;
+    case 0:
+	break;
+    }
 }
 
 
@@ -203,36 +208,36 @@
 // -------------------------------------------------------------------------------
 - (void)willUnselect
 {
-	// remove self as datasource
-	[((NSTableView*)cellList) setDataSource:nil];
-	[((NSTableView*)tokensTable) setDataSource:nil];
-
-	//release the afs property manager
-	if(afsProperty) [afsProperty release];
-	//release tokens list
-	if(tokenList) [tokenList release];	
-	//Remove the cell temp array
-	if(filteredCellDB) [filteredCellDB release];
-	
-	[self writePreferenceFile];
-	
-	// unregister preference pane to detect menuextra killed by user
-	[[NSDistributedNotificationCenter defaultCenter] removeObserver:self
-															   name:kAfsCommanderID
-															 object:kMExtraClosedNotification];
-	[[NSDistributedNotificationCenter defaultCenter] removeObserver:self
-															   name:kAfsCommanderID
-															 object:kMExtraTokenOperation];
-	[[NSDistributedNotificationCenter defaultCenter] removeObserver:self
-															   name:kAfsCommanderID
-															 object:kMenuExtraEventOccured];
-	[[[NSWorkspace sharedWorkspace] notificationCenter] removeObserver:self 
-																  name:NSWorkspaceDidMountNotification object:nil];
-	[[[NSWorkspace sharedWorkspace] notificationCenter] removeObserver:self 
-																  name:NSWorkspaceDidUnmountNotification object:nil];
-	
-	[self stopTimer];
-	[tokensLock release];
+    // remove self as datasource
+    [cellList setDataSource:nil];
+    [tokensTable setDataSource:nil];
+
+    //release the afs property manager
+    if(afsProperty) [afsProperty release];
+    //release tokens list
+    if(tokenList) [tokenList release];
+    //Remove the cell temp array
+    if(filteredCellDB) [filteredCellDB release];
+
+    [self writePreferenceFile];
+
+    // unregister preference pane to detect menuextra killed by user
+    [[NSDistributedNotificationCenter defaultCenter] removeObserver:self
+						     name:kAfsCommanderID
+						     object:kMExtraClosedNotification];
+    [[NSDistributedNotificationCenter defaultCenter] removeObserver:self
+						     name:kAfsCommanderID
+						     object:kMExtraTokenOperation];
+    [[NSDistributedNotificationCenter defaultCenter] removeObserver:self
+						     name:kAfsCommanderID
+						     object:kMenuExtraEventOccured];
+    [[[NSWorkspace sharedWorkspace] notificationCenter] removeObserver:self
+							name:NSWorkspaceDidMountNotification object:nil];
+    [[[NSWorkspace sharedWorkspace] notificationCenter] removeObserver:self
+							name:NSWorkspaceDidUnmountNotification object:nil];
+
+    [self stopTimer];
+    [tokensLock release];
 }
 
 
@@ -240,23 +245,23 @@
 //  startTimer:
 // -------------------------------------------------------------------------------
 - (void)startTimer{
-	//start the time for check tokens validity
-	if(timerForCheckTokensList) return;
-	timerForCheckTokensList = [NSTimer scheduledTimerWithTimeInterval:TOKENS_REFRESH_TIME_IN_SEC 
-															   target:self 
-															 selector:@selector(refreshTokens:) 
-															 userInfo:nil 
-															  repeats:YES];
-	[timerForCheckTokensList fire];	
+    //start the time for check tokens validity
+    if(timerForCheckTokensList) return;
+    timerForCheckTokensList = [NSTimer scheduledTimerWithTimeInterval:TOKENS_REFRESH_TIME_IN_SEC
+				       target:self
+				       selector:@selector(refreshTokens:)
+				       userInfo:nil
+				       repeats:YES];
+    [timerForCheckTokensList fire];
 }
 
 // -------------------------------------------------------------------------------
 //  stopTimer:
 // -------------------------------------------------------------------------------
 - (void)stopTimer{
-	if(!timerForCheckTokensList) return;
-	[timerForCheckTokensList invalidate];	
-	timerForCheckTokensList = nil;
+    if(!timerForCheckTokensList) return;
+    [timerForCheckTokensList invalidate];
+    timerForCheckTokensList = nil;
 }
 
 
@@ -265,73 +270,72 @@
 // -------------------------------------------------------------------------------
 - (void) readPreferenceFile
 {
-	// read the preference for aklog use
-	NSNumber *useAklogPrefValue = (NSNumber*)CFPreferencesCopyValue((CFStringRef)PREFERENCE_USE_AKLOG, (CFStringRef)kAfsCommanderID,  
-																	kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
-	NSNumber *aklogTokenAtLogin = (NSNumber*)CFPreferencesCopyValue((CFStringRef)PREFERENCE_AKLOG_TOKEN_AT_LOGIN, (CFStringRef)kAfsCommanderID,  
-																	kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
-	[useAklogCheck setState:[useAklogPrefValue intValue]];
-	[aklogCredentialAtLoginTime setEnabled:useAklogPrefValue && [useAklogPrefValue boolValue]];
-	[aklogCredentialAtLoginTime setState:aklogTokenAtLogin && [aklogTokenAtLogin boolValue]];
-
-	//check krb5 at login time
-	[installKRB5AuthAtLoginButton setState:[PListManager checkKrb5AtLoginTimeLaunchdEnable]];
-
-	//check for AFS enable at startup
-	NSNumber *afsEnableStartupTime = (NSNumber*)CFPreferencesCopyValue((CFStringRef)PREFERENCE_START_AFS_AT_STARTUP,
-																	   (CFStringRef)kAfsCommanderID,  kCFPreferencesAnyUser, kCFPreferencesAnyHost);
-	if(afsEnableStartupTime)
-		startAFSAtLogin = [afsEnableStartupTime boolValue];
-	else 
-		startAFSAtLogin = false;
-	//set the check button state
-	[checkButtonAfsAtBootTime setState:startAFSAtLogin];
-	
-	NSNumber *showStatusMenu =  (NSNumber*)CFPreferencesCopyValue((CFStringRef)PREFERENCE_SHOW_STATUS_MENU,  (CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
-	[(NSButton*)afsMenucheckBox setState: [showStatusMenu boolValue]];
-	
-	//backgrounder state
-	[backgrounderActivationCheck setState:[PListManager launchdJobState:BACKGROUNDER_P_FILE]];
-	
-	//link enabled status
-	NSNumber *linkEnabledStatus =  (NSNumber*)CFPreferencesCopyValue((CFStringRef)PREFERENCE_USE_LINK,  (CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
-	[checkEnableLink setState:[linkEnabledStatus boolValue]];
-	
-	//check the user preference for manage the renew
-	NSNumber *checkRenew =  (NSNumber*)CFPreferencesCopyValue((CFStringRef)PREFERENCE_KRB5_CHECK_ENABLE,  (CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
-	if(checkRenew)[nsButtonEnableDisableKrb5RenewCheck setState:[checkRenew intValue]];
-
-	NSNumber *renewTime = (NSNumber*)CFPreferencesCopyValue((CFStringRef)PREFERENCE_KRB5_RENEW_TIME,  (CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
-	if(!renewTime) renewTime = [NSNumber numberWithInt:PREFERENCE_KRB5_RENEW_TIME_DEFAULT_VALUE];
-
-		//update gui
-	NSCalendar *gregorian = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];
-	NSDateComponents *weekdayComponents = [gregorian components:(NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit) 
-													   fromDate:[NSDate dateWithTimeIntervalSince1970:[renewTime intValue]]];
-	[nsTextFieldKrb5RenewTimeD setIntValue:[weekdayComponents day]-1];
-	[nsTextFieldKrb5RenewTimeH setIntValue:[weekdayComponents hour]-1];
-	[nsTextFieldKrb5RenewTimeM setIntValue:[weekdayComponents minute]];
-	[nsTextFieldKrb5RenewTimeS setIntValue:[weekdayComponents second]];
-	[nsStepperKrb5RenewTimeD setIntValue:[weekdayComponents day]-1];
-	[nsStepperKrb5RenewTimeH setIntValue:[weekdayComponents hour]-1];
-	[nsStepperKrb5RenewTimeM setIntValue:[weekdayComponents minute]];
-	[nsStepperKrb5RenewTimeS setIntValue:[weekdayComponents second]];
-
-	NSNumber *renewCheckTimeInterval = (NSNumber*)CFPreferencesCopyValue((CFStringRef)PREFERENCE_KRB5_RENEW_CHECK_TIME_INTERVALL,  (CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
-	if(renewCheckTimeInterval && [renewCheckTimeInterval intValue])[nsTextFieldKrb5RenewCheckIntervall setIntValue:[renewCheckTimeInterval intValue]];
-	else [nsTextFieldKrb5RenewCheckIntervall setIntValue:PREFERENCE_KRB5_RENEW_CHECK_TIME_INTERVALL_DEFAULT_VALUE];
-
-	NSNumber *expireTimeForRenew = (NSNumber*)CFPreferencesCopyValue((CFStringRef)PREFERENCE_KRB5_SEC_TO_EXPIRE_TIME_FOR_RENEW,  (CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
-	if(expireTimeForRenew && [expireTimeForRenew intValue])[nsTextFieldKrb5SecToExpireDateForRenew setIntValue:[expireTimeForRenew intValue]];
-	else [nsTextFieldKrb5SecToExpireDateForRenew setIntValue:PREFERENCE_KRB5_SEC_TO_EXPIRE_TIME_FOR_RENEW_DEFAULT_VALUE];
-
-	//link configuration
-	NSData *prefData = (NSData*)CFPreferencesCopyValue((CFStringRef)PREFERENCE_LINK_CONFIGURATION,  (CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
-	linkConfiguration = (NSMutableDictionary*)[NSPropertyListSerialization propertyListFromData:prefData
-																			   mutabilityOption:NSPropertyListMutableContainers
-																						 format:nil
-																			   errorDescription:nil];
-	
+    // read the preference for aklog use
+    NSNumber *useAklogPrefValue = (NSNumber*)CFPreferencesCopyValue((CFStringRef)PREFERENCE_USE_AKLOG, (CFStringRef)kAfsCommanderID,
+								    kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
+    NSNumber *aklogTokenAtLogin = (NSNumber*)CFPreferencesCopyValue((CFStringRef)PREFERENCE_AKLOG_TOKEN_AT_LOGIN, (CFStringRef)kAfsCommanderID,
+								    kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
+    [useAklogCheck setState:[useAklogPrefValue intValue]];
+    [aklogCredentialAtLoginTime setEnabled:useAklogPrefValue && [useAklogPrefValue boolValue]];
+    [aklogCredentialAtLoginTime setState:aklogTokenAtLogin && [aklogTokenAtLogin boolValue]];
+
+    //check krb5 at login time
+    [installKRB5AuthAtLoginButton setState:[PListManager checkKrb5AtLoginTimeLaunchdEnable]];
+
+    //check for AFS enable at startup
+    NSNumber *afsEnableStartupTime = (NSNumber*)CFPreferencesCopyValue((CFStringRef)PREFERENCE_START_AFS_AT_STARTUP,
+								       (CFStringRef)kAfsCommanderID,  kCFPreferencesAnyUser, kCFPreferencesAnyHost);
+    if(afsEnableStartupTime)
+	startAFSAtLogin = [afsEnableStartupTime boolValue];
+    else
+	startAFSAtLogin = false;
+    //set the check button state
+    [checkButtonAfsAtBootTime setState:startAFSAtLogin];
+
+    NSNumber *showStatusMenu =  (NSNumber*)CFPreferencesCopyValue((CFStringRef)PREFERENCE_SHOW_STATUS_MENU,  (CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
+    [(NSButton*)afsMenucheckBox setState: [showStatusMenu boolValue]];
+
+    //backgrounder state
+    [backgrounderActivationCheck setState:[PListManager launchdJobState:BACKGROUNDER_P_FILE]];
+
+    //link enabled status
+    NSNumber *linkEnabledStatus =  (NSNumber*)CFPreferencesCopyValue((CFStringRef)PREFERENCE_USE_LINK,  (CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
+    [checkEnableLink setState:[linkEnabledStatus boolValue]];
+
+    //check the user preference for manage the renew
+    NSNumber *checkRenew =  (NSNumber*)CFPreferencesCopyValue((CFStringRef)PREFERENCE_KRB5_CHECK_ENABLE,  (CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
+    if(checkRenew)[nsButtonEnableDisableKrb5RenewCheck setState:[checkRenew intValue]];
+
+    NSNumber *renewTime = (NSNumber*)CFPreferencesCopyValue((CFStringRef)PREFERENCE_KRB5_RENEW_TIME,  (CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
+    if(!renewTime) renewTime = [NSNumber numberWithInt:PREFERENCE_KRB5_RENEW_TIME_DEFAULT_VALUE];
+
+    //update gui
+    NSCalendar *gregorian = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];
+    NSDateComponents *weekdayComponents = [gregorian components:(NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit)
+						     fromDate:[NSDate dateWithTimeIntervalSince1970:[renewTime intValue]]];
+    [nsTextFieldKrb5RenewTimeD setIntValue:[weekdayComponents day]-1];
+    [nsTextFieldKrb5RenewTimeH setIntValue:[weekdayComponents hour]-1];
+    [nsTextFieldKrb5RenewTimeM setIntValue:[weekdayComponents minute]];
+    [nsTextFieldKrb5RenewTimeS setIntValue:[weekdayComponents second]];
+    [nsStepperKrb5RenewTimeD setIntValue:[weekdayComponents day]-1];
+    [nsStepperKrb5RenewTimeH setIntValue:[weekdayComponents hour]-1];
+    [nsStepperKrb5RenewTimeM setIntValue:[weekdayComponents minute]];
+    [nsStepperKrb5RenewTimeS setIntValue:[weekdayComponents second]];
+
+    NSNumber *renewCheckTimeInterval = (NSNumber*)CFPreferencesCopyValue((CFStringRef)PREFERENCE_KRB5_RENEW_CHECK_TIME_INTERVALL,  (CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
+    if(renewCheckTimeInterval && [renewCheckTimeInterval intValue])[nsTextFieldKrb5RenewCheckIntervall setIntValue:[renewCheckTimeInterval intValue]];
+    else [nsTextFieldKrb5RenewCheckIntervall setIntValue:PREFERENCE_KRB5_RENEW_CHECK_TIME_INTERVALL_DEFAULT_VALUE];
+
+    NSNumber *expireTimeForRenew = (NSNumber*)CFPreferencesCopyValue((CFStringRef)PREFERENCE_KRB5_SEC_TO_EXPIRE_TIME_FOR_RENEW,  (CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
+    if(expireTimeForRenew && [expireTimeForRenew intValue])[nsTextFieldKrb5SecToExpireDateForRenew setIntValue:[expireTimeForRenew intValue]];
+    else [nsTextFieldKrb5SecToExpireDateForRenew setIntValue:PREFERENCE_KRB5_SEC_TO_EXPIRE_TIME_FOR_RENEW_DEFAULT_VALUE];
+
+    //link configuration
+    NSData *prefData = (NSData*)CFPreferencesCopyValue((CFStringRef)PREFERENCE_LINK_CONFIGURATION,  (CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
+    linkConfiguration = (NSMutableDictionary*)[NSPropertyListSerialization propertyListFromData:prefData
+									   mutabilityOption:NSPropertyListMutableContainers
+									   format:nil
+									   errorDescription:nil];
 }
 
 // -------------------------------------------------------------------------------
@@ -339,56 +343,56 @@
 // -------------------------------------------------------------------------------
 - (void) writePreferenceFile
 {
-	//Set the preference for afs path
-	//Set the preference for aklog use
-	CFPreferencesSetValue((CFStringRef)PREFERENCE_USE_AKLOG, 
-						  (CFNumberRef)[NSNumber numberWithInt:[useAklogCheck state]], 
-						  (CFStringRef)kAfsCommanderID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
-
-	//set AFS enable state at startup
-	CFPreferencesSetValue((CFStringRef)PREFERENCE_START_AFS_AT_STARTUP, 
-						  (CFNumberRef)[NSNumber numberWithBool:startAFSAtLogin], 
-						  (CFStringRef)kAfsCommanderID, kCFPreferencesAnyUser, kCFPreferencesAnyHost);
-	
-	//set aklog at login
-	CFPreferencesSetValue((CFStringRef)PREFERENCE_AKLOG_TOKEN_AT_LOGIN, 
-						  (CFNumberRef)[NSNumber numberWithBool:[aklogCredentialAtLoginTime state]], 
-						  (CFStringRef)kAfsCommanderID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
-	
-	//set aklog at login
-	CFPreferencesSetValue((CFStringRef)PREFERENCE_SHOW_STATUS_MENU, 
-						  (CFNumberRef)[NSNumber numberWithBool:[(NSButton*)afsMenucheckBox state]],
-						  (CFStringRef)kAfsCommanderID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
-	
-	//preference for link
-	CFPreferencesSetValue((CFStringRef)PREFERENCE_USE_LINK,
-						  (CFNumberRef)[NSNumber numberWithBool:[checkEnableLink state]], 
-						  (CFStringRef)kAfsCommanderID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
-	
-		//preference for renew time
-	NSLog(@"%d %d %d %d", [nsTextFieldKrb5RenewTimeD intValue],[nsTextFieldKrb5RenewTimeH intValue],[nsTextFieldKrb5RenewTimeM intValue],[nsTextFieldKrb5RenewTimeS intValue]);
-	NSInteger totalSeconds =	([nsTextFieldKrb5RenewTimeD intValue]*24*60*60)+
-								([nsTextFieldKrb5RenewTimeH intValue]*60*60)+
-								([nsTextFieldKrb5RenewTimeM intValue]*60)+
-								[nsTextFieldKrb5RenewTimeS intValue];
-
-	CFPreferencesSetValue((CFStringRef)PREFERENCE_KRB5_RENEW_TIME,
-						  (CFNumberRef)[NSNumber numberWithInt:totalSeconds],
-						  (CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
-
-		//expire time for renew
-	CFPreferencesSetValue((CFStringRef)PREFERENCE_KRB5_SEC_TO_EXPIRE_TIME_FOR_RENEW,
-						  (CFNumberRef)[NSNumber numberWithInt:[nsTextFieldKrb5SecToExpireDateForRenew intValue]],
-						  (CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
-
-		//sec to expiretime for renew job
-	CFPreferencesSetValue((CFStringRef)PREFERENCE_KRB5_RENEW_CHECK_TIME_INTERVALL,
-						  (CFNumberRef)[NSNumber numberWithInt:[nsTextFieldKrb5RenewCheckIntervall intValue]],
-						  (CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
-
-	CFPreferencesSynchronize((CFStringRef)kAfsCommanderID,  kCFPreferencesAnyUser, kCFPreferencesAnyHost);
-	CFPreferencesSynchronize((CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
-	[[NSDistributedNotificationCenter defaultCenter] postNotificationName:kAFSMenuExtraID object:kPrefChangeNotification];
+    //Set the preference for afs path
+    //Set the preference for aklog use
+    CFPreferencesSetValue((CFStringRef)PREFERENCE_USE_AKLOG,
+			  (CFNumberRef)[NSNumber numberWithInt:[useAklogCheck state]],
+			  (CFStringRef)kAfsCommanderID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
+
+    //set AFS enable state at startup
+    CFPreferencesSetValue((CFStringRef)PREFERENCE_START_AFS_AT_STARTUP,
+			  (CFNumberRef)[NSNumber numberWithBool:startAFSAtLogin],
+			  (CFStringRef)kAfsCommanderID, kCFPreferencesAnyUser, kCFPreferencesAnyHost);
+
+    //set aklog at login
+    CFPreferencesSetValue((CFStringRef)PREFERENCE_AKLOG_TOKEN_AT_LOGIN,
+			  (CFNumberRef)[NSNumber numberWithBool:[aklogCredentialAtLoginTime state]],
+			  (CFStringRef)kAfsCommanderID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
+
+    //set aklog at login
+    CFPreferencesSetValue((CFStringRef)PREFERENCE_SHOW_STATUS_MENU,
+			  (CFNumberRef)[NSNumber numberWithBool:[(NSButton*)afsMenucheckBox state]],
+			  (CFStringRef)kAfsCommanderID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
+
+    //preference for link
+    CFPreferencesSetValue((CFStringRef)PREFERENCE_USE_LINK,
+			  (CFNumberRef)[NSNumber numberWithBool:[checkEnableLink state]],
+			  (CFStringRef)kAfsCommanderID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
+
+    //preference for renew time
+    //NSLog(@"%d %d %d %d", [nsTextFieldKrb5RenewTimeD intValue],[nsTextFieldKrb5RenewTimeH intValue],[nsTextFieldKrb5RenewTimeM intValue],[nsTextFieldKrb5RenewTimeS intValue]);
+    NSInteger totalSeconds =	([nsTextFieldKrb5RenewTimeD intValue]*24*60*60)+
+	([nsTextFieldKrb5RenewTimeH intValue]*60*60)+
+	([nsTextFieldKrb5RenewTimeM intValue]*60)+
+	[nsTextFieldKrb5RenewTimeS intValue];
+
+    CFPreferencesSetValue((CFStringRef)PREFERENCE_KRB5_RENEW_TIME,
+			  (CFNumberRef)[NSNumber numberWithInt:totalSeconds],
+			  (CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
+
+    //expire time for renew
+    CFPreferencesSetValue((CFStringRef)PREFERENCE_KRB5_SEC_TO_EXPIRE_TIME_FOR_RENEW,
+			  (CFNumberRef)[NSNumber numberWithInt:[nsTextFieldKrb5SecToExpireDateForRenew intValue]],
+			  (CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
+
+    //sec to expiretime for renew job
+    CFPreferencesSetValue((CFStringRef)PREFERENCE_KRB5_RENEW_CHECK_TIME_INTERVALL,
+			  (CFNumberRef)[NSNumber numberWithInt:[nsTextFieldKrb5RenewCheckIntervall intValue]],
+			  (CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
+
+    CFPreferencesSynchronize((CFStringRef)kAfsCommanderID,  kCFPreferencesAnyUser, kCFPreferencesAnyHost);
+    CFPreferencesSynchronize((CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
+    [[NSDistributedNotificationCenter defaultCenter] postNotificationName:kAFSMenuExtraID object:kPrefChangeNotification];
 }
 
 // -------------------------------------------------------------------------------
@@ -396,29 +400,25 @@
 // -------------------------------------------------------------------------------
 - (IBAction) saveConfiguration:(id) sender
 {
-	@try{
-		
-		//[afsProperty setCellName:[cellNameTextEdit stringValue]];
-		[afsProperty setCellName:[afsProperty getDefaultCellName]];
-		
-		//save configurations
-		[afsProperty saveConfigurationFiles:YES];
-		
-		
-		//Reload all configuration
-		[self refreshConfiguration:nil];
-		
-		//refresh table to reflect the NSSearchField contained text
-		[self searchCellTextEvent:nil];
+    @try{
+	[afsProperty setCellName:[afsProperty getDefaultCellName]];
+
+	//save configurations
+	[afsProperty saveConfigurationFiles:YES];
 		
-		//Show dialog for notifity al saving process ar gone ell
-		[self showMessage:kConfigurationSaved];
-	}@catch(NSException *e){
-		[self showMessage:[e reason]];
-	} @finally {
-		[((NSTableView*)cellList) reloadData];
-	}
+	//Reload all configuration
+	[self refreshConfiguration:nil];
+
+	//refresh table to reflect the NSSearchField contained text
+	[self searchCellTextEvent:nil];
 	
+	//Show dialog for notifity al saving process ar gone ell
+	[self showMessage:kConfigurationSaved];
+    }@catch(NSException *e){
+	[self showMessage:[e reason]];
+    } @finally {
+	[cellList reloadData];
+    }
 }
 
 // -------------------------------------------------------------------------------
@@ -426,16 +426,16 @@
 // -------------------------------------------------------------------------------
 - (IBAction) saveCacheManagerParam:(id) sender
 {
-	@try{
-		//Update the value form view to afs property manager class
-		[self updateCacheParamFromView];
-		[afsProperty saveCacheConfigurationFiles:YES];
-		[self showMessage:kSavedCacheConfiguration];
-	}@catch(NSException *e){
-		[self showMessage:[e reason]];
-	} @finally {
-		[((NSTableView*)cellList) reloadData];
-	}
+    @try{
+	//Update the value form view to afs property manager class
+	[self updateCacheParamFromView];
+	[afsProperty saveCacheConfigurationFiles:YES];
+	[self showMessage:kSavedCacheConfiguration];
+    }@catch(NSException *e){
+	[self showMessage:[e reason]];
+    } @finally {
+	[cellList reloadData];
+    }
 }
 
 // -------------------------------------------------------------------------------
@@ -443,31 +443,31 @@
 // -------------------------------------------------------------------------------
 - (IBAction) refreshConfiguration:(id) sender
 {
-	NSString *afsBasePath = PREFERENCE_AFS_SYS_PAT_STATIC;
-	@try{
-		// set the afs path
-		[afsProperty setPath:afsBasePath];
-		
-		// load configuration
-		[afsProperty loadConfiguration];
-		
-		//set the afs version label
-		[afsVersionLabel setStringValue:[afsProperty getAfsVersion]];
-		
-		//set the current default cell
-		[afsDefaultCellLabel setStringValue:[afsProperty getDefaultCellName]];
-		
-		// Update cache view
-		[self fillCacheParamView];
-		
-		//Filter the cellServDb and allocate filtered array
-		[self filterCellServDB:nil];
-		
-	}@catch(NSException *e){
-		[self showMessage:[e reason]];
-	} @finally {
-		[((NSTableView*)cellList) reloadData];
-	}
+    NSString *afsBasePath = PREFERENCE_AFS_SYS_PAT_STATIC;
+    @try{
+	// set the afs path
+	[afsProperty setPath:afsBasePath];
+
+	// load configuration
+	[afsProperty loadConfiguration];
+
+	//set the afs version label
+	[afsVersionLabel setStringValue:[afsProperty getAfsVersion]];
+
+	//set the current default cell
+	[afsDefaultCellLabel setStringValue:[afsProperty getDefaultCellName]];
+
+	// Update cache view
+	[self fillCacheParamView];
+
+	//Filter the cellServDb and allocate filtered array
+	[self filterCellServDB:nil];
+
+    }@catch(NSException *e){
+	[self showMessage:[e reason]];
+    } @finally {
+	[cellList reloadData];
+    }
 }
 
 // -------------------------------------------------------------------------------
@@ -475,19 +475,19 @@
 // -------------------------------------------------------------------------------
 -(void) fillCacheParamView
 {
-	[dynRoot setState:[afsProperty dynRoot]?NSOnState:NSOffState];
-	[afsDB setState:[afsProperty afsDB]?NSOnState:NSOffState];
-	[statCacheEntry setIntValue:[afsProperty statCacheEntry]];
-	[dCacheDim setIntValue:[afsProperty dCacheDim]];
-	[cacheDimension setIntValue:[afsProperty cacheDimension]];
-	[daemonNumber setIntValue:[afsProperty daemonNumber]];
-	[afsRootMountPoint setStringValue:[afsProperty afsRootMountPoint]];
-	[nVolEntry setIntValue:[afsProperty nVolEntry]];
-	
-	//new version property
-	//[verbose setEnabled:[afsProperty useAfsdConfConfigFile]];
-	[verbose setState:[afsProperty verbose]?NSOnState:NSOffState];
-	
+    [dynRoot setState:[afsProperty dynRoot]?NSOnState:NSOffState];
+    [afsDB setState:[afsProperty afsDB]?NSOnState:NSOffState];
+    [statCacheEntry setIntValue:[afsProperty statCacheEntry]];
+    [dCacheDim setIntValue:[afsProperty dCacheDim]];
+    [cacheDimension setIntValue:[afsProperty cacheDimension]];
+    [daemonNumber setIntValue:[afsProperty daemonNumber]];
+    [afsRootMountPoint setStringValue:[afsProperty afsRootMountPoint]];
+    [nVolEntry setIntValue:[afsProperty nVolEntry]];
+
+    //new version property
+    //[verbose setEnabled:[afsProperty useAfsdConfConfigFile]];
+    [verbose setState:[afsProperty verbose]?NSOnState:NSOffState];
+
 }
 
 // -------------------------------------------------------------------------------
@@ -495,22 +495,21 @@
 // -------------------------------------------------------------------------------
 -(void) updateCacheParamFromView
 {
-	NSString *tmpAfsPath = [afsRootMountPoint stringValue];
-	if(!tmpAfsPath || ([tmpAfsPath length] == 0) || ([tmpAfsPath characterAtIndex:0] != '/')) 
-		@throw [NSException exceptionWithName:@"updateCacheParamFromView" 
-									   reason:kBadAfsRootMountPoint
-									 userInfo:nil];
+    NSString *tmpAfsPath = [afsRootMountPoint stringValue];
+    if(!tmpAfsPath || ([tmpAfsPath length] == 0) || ([tmpAfsPath characterAtIndex:0] != '/'))
+	@throw [NSException exceptionWithName:@"updateCacheParamFromView"
+			    reason:kBadAfsRootMountPoint
+			    userInfo:nil];
 
-	
-	[afsProperty setDynRoot:[dynRoot state]==NSOnState];
-	[afsProperty setAfsDB:[afsDB state]==NSOnState];
-	[afsProperty setStatCacheEntry:[statCacheEntry intValue]];
-	[afsProperty setDCacheDim:[dCacheDim intValue]]; 
-	[afsProperty setCacheDimension:[cacheDimension intValue]]; 
-	[afsProperty setDaemonNumber:[daemonNumber intValue]];
-	[afsProperty setAfsRootMountPoint:tmpAfsPath];
-	[afsProperty setNVolEntry:[nVolEntry intValue]];
-	[afsProperty setVerbose:[verbose state]==NSOnState];
+    [afsProperty setDynRoot:[dynRoot state]==NSOnState];
+    [afsProperty setAfsDB:[afsDB state]==NSOnState];
+    [afsProperty setStatCacheEntry:[statCacheEntry intValue]];
+    [afsProperty setDCacheDim:[dCacheDim intValue]];
+    [afsProperty setCacheDimension:[cacheDimension intValue]];
+    [afsProperty setDaemonNumber:[daemonNumber intValue]];
+    [afsProperty setAfsRootMountPoint:tmpAfsPath];
+    [afsProperty setNVolEntry:[nVolEntry intValue]];
+    [afsProperty setVerbose:[verbose state]==NSOnState];
 }
 
 
@@ -519,8 +518,8 @@
 // -------------------------------------------------------------------------------
 - (IBAction) showCellIP:(id) sender
 {
-	int rowSelected = [((NSTableView *) cellList) selectedRow];
-	[self modifyCellByIDX:rowSelected];
+    int rowSelected = [((NSTableView *) cellList) selectedRow];
+    [self modifyCellByIDX:rowSelected];
 }
 
 // -------------------------------------------------------------------------------
@@ -528,7 +527,7 @@
 // -------------------------------------------------------------------------------
 -(void) modifyCellByIDX:(int) idx
 {
-	[self modifyCell:[self getCellByIDX:idx]];
+    [self modifyCell:[self getCellByIDX:idx]];
 }
 
 // -------------------------------------------------------------------------------
@@ -536,13 +535,13 @@
 // -------------------------------------------------------------------------------
 -(void) modifyCell:(DBCellElement*) cellElement
 {
-	[NSBundle loadNibNamed:@"IpPanel" owner:self];
-	[((IpConfiguratorCommander*) ipConfControllerCommander) setWorkCell:cellElement];
-	[NSApp beginSheet: ipConfigurationSheet
+    [NSBundle loadNibNamed:@"IpPanel" owner:self];
+    [((IpConfiguratorCommander*) ipConfControllerCommander) setWorkCell:cellElement];
+    [NSApp beginSheet: ipConfigurationSheet
 	   modalForWindow: [[self mainView] window]
-		modalDelegate: self
+	   modalDelegate: self
 	   didEndSelector: @selector(didEndSheet:returnCode:contextInfo:)
-		  contextInfo: nil];
+	   contextInfo: nil];
 }
 
 // -------------------------------------------------------------------------------
@@ -550,132 +549,78 @@
 // -------------------------------------------------------------------------------
 - (IBAction) addRemoveCell:(id) sender
 {
-	switch([((NSControl*) sender) tag]){
-		case ADD_CELL_CONTROL_TAG:
-		{
-			DBCellElement *newCell = [[DBCellElement alloc] init];
-			if(!newCell) break;
-			
-			[newCell setCellName:kNewCellName];
-			[newCell setCellComment:kNewCellComment];
-			//cellArray = ;
-			[[afsProperty getCellList] addObject:newCell];
-			[newCell release];
-			
-			//Modify new cell
-			[self modifyCell:newCell];
-		}
-		break;
-			
-		case REMOVE_CELL_CONTROL_TAG:
-		{
-			int index = 0;
-			NSIndexSet *selectedIndex = [(NSTableView*)cellList selectedRowIndexes];
-			if( [selectedIndex count] > 0) {
-				index = [selectedIndex firstIndex]; 
-				do {
-					DBCellElement *cellElement =  (DBCellElement*)[filteredCellDB objectAtIndex:index];
-					[[afsProperty getCellList] removeObject:cellElement];
-				} while ((index = [selectedIndex indexGreaterThanIndex:index]) != NSNotFound);
-			}
-		}
-		break;
-	}
-	//Filter the cellServDb and allocate filtered array
-	[self searchCellTextEvent:nil];
-	[(NSTableView*)cellList deselectAll:nil];
-	[(NSTableView*)cellList reloadData];
-}
-
-// -------------------------------------------------------------------------------
-//  repairHelperTool:
-// -------------------------------------------------------------------------------
-- (void) repairHelperTool
-{
-	struct stat st;
-    int fdTool;
-	int status = 0;
-	NSLog(@"repairHelperTool"); 
-	NSString *afshlpPath = [[self bundle] pathForResource:@"afshlp" ofType:nil];
+    switch([((NSControl*) sender) tag]){
+    case ADD_CELL_CONTROL_TAG:
+    {
+	DBCellElement *newCell = [[DBCellElement alloc] init];
+	if(!newCell) break;
 	
+	[newCell setCellName:kNewCellName];
+	[newCell setCellComment:kNewCellComment];
+	//cellArray = ;
+	[[afsProperty getCellList] addObject:newCell];
+	[newCell release];
 	
-    
-    // Open tool exclusively, so nobody can change it while we bless it.
-    fdTool = open([afshlpPath UTF8String], O_NONBLOCK | O_RDONLY | O_EXLOCK, 0);
-    
-    if(fdTool == -1)
-    {
-        NSLog(@"Exclusive open while repairing tool failed: %d.", errno);
-        exit(-1);
+	//Modify new cell
+	[self modifyCell:newCell];
     }
+    break;
     
-    if(fstat(fdTool, &st))
+    case REMOVE_CELL_CONTROL_TAG:
     {
-        NSLog(@"fstat failed.");
-        exit(-1);
+	int index = 0;
+	NSIndexSet *selectedIndex = [(NSTableView*)cellList selectedRowIndexes];
+	if( [selectedIndex count] > 0) {
+	    index = [selectedIndex firstIndex];
+	    do {
+		DBCellElement *cellElement =  (DBCellElement*)[filteredCellDB objectAtIndex:index];
+		[[afsProperty getCellList] removeObject:cellElement];
+	    } while ((index = [selectedIndex indexGreaterThanIndex:index]) != NSNotFound);
+	}
     }
-    
-    if(st.st_uid != 0)
-    {
-		status = [[AuthUtil shared] autorize];
-		if(status == noErr){
-			fchown(fdTool, 0, st.st_gid);
-			
-			// Disable group and world writability and make setuid root.
-			fchmod(fdTool, (st.st_mode & (~(S_IWGRP | S_IWOTH)))/* | S_ISUID*/);
-			const char *args[] = {"root", [afshlpPath UTF8String],0L};
-			[[AuthUtil shared] execUnixCommand:"/usr/sbin/chown" 
-										  args:args
-										output:nil];
-			[[AuthUtil shared] deautorize];
-		}
-    } else  NSLog(@"st_uid = 0");
-    
-	
-    
-    close(fdTool);
-    
-    NSLog(@"Self-repair done.");
-	
+    break;
+    }
+    //Filter the cellServDb and allocate filtered array
+    [self searchCellTextEvent:nil];
+    [cellList deselectAll:nil];
+    [cellList reloadData];
 }
 
-
 // -------------------------------------------------------------------------------
 //  startStopAfs:
 // -------------------------------------------------------------------------------
 - (IBAction) startStopAfs:(id) sender
 {
-	BOOL currentAfsState = NO;
-	@try {
-		currentAfsState = [afsProperty checkAfsStatus];
-		// make the parameter to call the root helper app
-		if(currentAfsState){
-			//shutdown afs
-			NSLog(@"Shutting down afs");
-			[afsProperty shutdown];
-		} else {
-			//Start afs
-			NSLog(@"Starting up afs");
-			[afsProperty startup];
-		}
-		[self refreshGui:nil];
-	}
-	@catch (NSException * e) {
-		[self showMessage:[e reason]];
-	}
-	@finally {
-		[[AuthUtil shared] deautorize];
+    BOOL currentAfsState = NO;
+    @try {
+	currentAfsState = [afsProperty checkAfsStatus];
+	// make the parameter to call the root helper app
+	if(currentAfsState){
+	    //shutdown afs
+	    NSLog(@"Shutting down afs");
+	    [afsProperty shutdown];
+	} else {
+	    //Start afs
+	    NSLog(@"Starting up afs");
+	    [afsProperty startup];
 	}
+	[self refreshGui:nil];
+    }
+    @catch (NSException * e) {
+	[self showMessage:[e reason]];
+    }
+    @finally {
+    }
 }
 
 // -------------------------------------------------------------------------------
 //  info:
 // -------------------------------------------------------------------------------
 - (void) refreshGui:(NSNotification *)notification{
-	BOOL afsIsUp = [afsProperty checkAfsStatus];
-	[self setAfsStatus];
-	[tokensButton setEnabled:afsIsUp];
-	[unlogButton setEnabled:afsIsUp];
+    BOOL afsIsUp = [afsProperty checkAfsStatus];
+    [self setAfsStatus];
+    [tokensButton setEnabled:afsIsUp];
+    [unlogButton setEnabled:afsIsUp];
 
 }
 
@@ -683,18 +628,19 @@
 //  -(void) refreshTokensNotify:(NSNotification*)notification
 // -------------------------------------------------------------------------------
 -(void) refreshTokensNotify:(NSNotification*)notification {
-	[self refreshTokens:nil];
+    [self refreshTokens:nil];
 }
 
 // -------------------------------------------------------------------------------
 //  afsVolumeMountChange: Track the afs volume state change
 // -------------------------------------------------------------------------------
+// XXX should use mountdir not /afs
 - (void) afsVolumeMountChange:(NSNotification *)notification{
-	// Cehck if is mounted or unmounted afs
-	if([[[notification userInfo] objectForKey:@"NSDevicePath"] isEqualToString:@"/afs"]){
-		[self setAfsStatus];
-		[self refreshTokens:nil];
-	}
+    // Check if is mounted or unmounted afs
+    if([[[notification userInfo] objectForKey:@"NSDevicePath"] isEqualToString:@"/afs"]){
+	[self setAfsStatus];
+	[self refreshTokens:nil];
+    }
 }
 
 // -------------------------------------------------------------------------------
@@ -702,13 +648,13 @@
 // -------------------------------------------------------------------------------
 - (IBAction) info:(id) sender
 {
-	[((InfoController*) infoController) showHtmlResource:[[self bundle] pathForResource:@"license" ofType:@"rtf"]];
+    [infoController showHtmlResource:[[self bundle] pathForResource:@"license" ofType:@"rtf"]];
 
-	[NSApp beginSheet: infoSheet
+    [NSApp beginSheet: infoSheet
 	   modalForWindow: [[self mainView] window]
-		modalDelegate: self
+	   modalDelegate: self
 	   didEndSelector:  @selector(didEndInfoSheet:returnCode:contextInfo:)
-		  contextInfo: nil];
+	   contextInfo: nil];
 }
 
 // -------------------------------------------------------------------------------
@@ -716,7 +662,7 @@
 // -------------------------------------------------------------------------------
 - (IBAction) tableDoubleAction:(id) sender
 {
-	[self showCellIP:nil];
+    [self showCellIP:nil];
 }
 
 // -------------------------------------------------------------------------------
@@ -724,24 +670,24 @@
 // -------------------------------------------------------------------------------
 - (IBAction) getNewToken:(id) sender
 {
-	BOOL useAklog = [useAklogCheck state] == NSOnState;
-	if(useAklog){
-		//[AFSPropertyManager aklog];
-		[afsProperty getTokens:false 
-						   usr:nil 
-						   pwd:nil];
-		[self refreshTokens:nil];
-		//Inform afs menuextra to updata afs status
-		[[NSDistributedNotificationCenter defaultCenter] postNotificationName:kAFSMenuExtraID object:kMExtraAFSStateChange];
+    BOOL useAklog = [useAklogCheck state] == NSOnState;
+    if(useAklog){
+	//[AFSPropertyManager aklog];
+	[afsProperty getTokens:false
+		     usr:nil
+		     pwd:nil];
+	[self refreshTokens:nil];
+	//Inform afs menuextra to updata afs status
+	[[NSDistributedNotificationCenter defaultCenter] postNotificationName:kAFSMenuExtraID object:kMExtraAFSStateChange];
 
-	} else {
-		[NSBundle loadNibNamed:@"CredentialPanel" owner:self];
-		[NSApp beginSheet: credentialSheet
-		   modalForWindow: [[self mainView] window]
-			modalDelegate: self
-		   didEndSelector: @selector(didEndCredentialSheet:returnCode:contextInfo:)
-			  contextInfo: nil];
-	}
+    } else {
+	[NSBundle loadNibNamed:@"CredentialPanel" owner:self];
+	[NSApp beginSheet: credentialSheet
+	       modalForWindow: [[self mainView] window]
+	       modalDelegate: self
+	       didEndSelector: @selector(didEndCredentialSheet:returnCode:contextInfo:)
+	       contextInfo: nil];
+    }
 }
 
 
@@ -750,23 +696,22 @@
 // -------------------------------------------------------------------------------
 - (IBAction) unlog:(id) sender
 {
-	int index = -1;
-	NSIndexSet *selectedIndex = [(NSTableView*)tokensTable selectedRowIndexes];
-	if( [selectedIndex count] > 0) {
-		index = [selectedIndex firstIndex]; 
-		do {
-			NSString *tokenDesc = [tokenList objectAtIndex:index];
-			NSString *cellToUnlog = [tokenDesc estractTokenByDelimiter:@"afs@" 
-															  endToken:@" "];
-			[afsProperty unlog:cellToUnlog];
-		} while ((index = [selectedIndex indexGreaterThanIndex: index]) != NSNotFound);
-	} else {
-		[afsProperty unlog:nil];
-	}
-	[self refreshTokens:nil];
-	//Inform afs menuextra to updata afs status
-	[[NSDistributedNotificationCenter defaultCenter] postNotificationName:kAFSMenuExtraID object:kMExtraAFSStateChange];
-
+    int index = -1;
+    NSIndexSet *selectedIndex = [tokensTable selectedRowIndexes];
+    if( [selectedIndex count] > 0) {
+	index = [selectedIndex firstIndex];
+	do {
+	    NSString *tokenDesc = [tokenList objectAtIndex:index];
+	    NSString *cellToUnlog = [tokenDesc estractTokenByDelimiter:@"afs@"
+					       endToken:@" "];
+	    [afsProperty unlog:cellToUnlog];
+	} while ((index = [selectedIndex indexGreaterThanIndex: index]) != NSNotFound);
+    } else {
+	[afsProperty unlog:nil];
+    }
+    [self refreshTokens:nil];
+    //Inform afs menuextra to updata afs status
+    [[NSDistributedNotificationCenter defaultCenter] postNotificationName:kAFSMenuExtraID object:kMExtraAFSStateChange];
 }
 
 
@@ -775,47 +720,43 @@
 // -------------------------------------------------------------------------------
 - (IBAction) aklogSwitchEvent:(id) sender
 {
-	//afs menu extra is loaded inform it to read preference
-	@try {
-		if(![useAklogCheck state]) {
-			//deselect the checkbox
-			[aklogCredentialAtLoginTime setState:NO];
-		}
-		
-		[self writePreferenceFile];
-		
-		//Enable disable aklog at login time checkbox according the useAklog checkbox
-		[aklogCredentialAtLoginTime setEnabled:[useAklogCheck state]];
-		
-	}
-	@catch (NSException * e) {
-		[self showMessage:[e reason]];
+    //afs menu extra is loaded inform it to read preference
+    @try {
+	if(![useAklogCheck state]) {
+	    //deselect the checkbox
+	    [aklogCredentialAtLoginTime setState:NO];
 	}
 	
-		
+	[self writePreferenceFile];
+
+	//Enable disable aklog at login time checkbox according the useAklog checkbox
+	[aklogCredentialAtLoginTime setEnabled:[useAklogCheck state]];
+
+    }
+    @catch (NSException * e) {
+	[self showMessage:[e reason]];
+    }
 }
 
 // -------------------------------------------------------------------------------
 //  credentialAtLoginTimeEvent:
 // -------------------------------------------------------------------------------
 - (IBAction) credentialAtLoginTimeEvent:(id) sender {
-	[self writePreferenceFile];
+    [self writePreferenceFile];
 }
 
 // -------------------------------------------------------------------------------
 //  afsStartupSwitchEvent:
 // -------------------------------------------------------------------------------
 - (IBAction) afsStartupSwitchEvent:(id) sender {
-	NSString *rootHelperApp = [[self bundle] pathForResource:@"afshlp" ofType:@""];
-	//get the new state
-	startAFSAtLogin = [checkButtonAfsAtBootTime state];
-	const char *startupConfigureOption[] = {"start_afs_at_startup", startAFSAtLogin?"enable":"disable", 0L};
-	if([[AuthUtil shared] autorize] == noErr) {
-			//now disable the launchd configuration
-			[[AuthUtil shared] execUnixCommand:[rootHelperApp UTF8String]
-										  args:startupConfigureOption
-										output:nil];
-	}
+    NSString *rootHelperApp = [[self bundle] pathForResource:@"afshlp" ofType:@""];
+    //get the new state
+    startAFSAtLogin = [checkButtonAfsAtBootTime state];
+    [PListManager launchctlStringCommandAuth:startAFSAtLogin?@"load":@"unload"
+		  option:[NSArray arrayWithObjects:@"-w", nil]
+		  plistName:@AFS_DAEMON_PATH
+		  helper:rootHelperApp
+		  withAuthRef:[[authView authorization] authorizationRef]];
 }
 
 
@@ -823,20 +764,11 @@
 //  afsMenuActivationEvent:
 // -------------------------------------------------------------------------------
 - (IBAction) krb5KredentialAtLoginTimeEvent:(id) sender {
-	//
-	NSString *rootHelperApp = [[self bundle] pathForResource:@"afshlp" ofType:@""];
-	const char *args[] = {"enable_krb5_startup", [[installKRB5AuthAtLoginButton stringValue] UTF8String], "", 0L};
-	
-	//Check helper app
-	[self repairHelperTool];
-	if([[AuthUtil shared] autorize] == noErr) {
-		[[AuthUtil shared] execUnixCommand:[rootHelperApp UTF8String] 
-									  args:args
-									output:nil];
-		
-		//check if all is gone well
-		[installKRB5AuthAtLoginButton setState:[PListManager checkKrb5AtLoginTimeLaunchdEnable]];
-	}
+    NSString *rootHelperApp = [[self bundle] pathForResource:@"afshlp" ofType:@""];
+    [PListManager krb5TiketAtLoginTime:[installKRB5AuthAtLoginButton state] helper:rootHelperApp];
+
+    //check if all is gone well
+    [installKRB5AuthAtLoginButton setState:[PListManager checkKrb5AtLoginTimeLaunchdEnable]];
 }
 
 // -------------------------------------------------------------------------------
@@ -844,15 +776,15 @@
 // -------------------------------------------------------------------------------
 -(IBAction) afsMenuActivationEvent:(id) sender
 {
-	CFPreferencesSetValue((CFStringRef)PREFERENCE_SHOW_STATUS_MENU, 
-						  (CFNumberRef)[NSNumber numberWithBool:[(NSButton*)afsMenucheckBox state]],
-						  (CFStringRef)kAfsCommanderID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
-	
-	CFPreferencesSynchronize((CFStringRef)kAfsCommanderID,  kCFPreferencesAnyUser, kCFPreferencesAnyHost);
-	CFPreferencesSynchronize((CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
-	
-	//notify the backgrounder
-	[[NSDistributedNotificationCenter defaultCenter] postNotificationName:kAFSMenuExtraID object:kMExtraAFSMenuChangeState];
+    CFPreferencesSetValue((CFStringRef)PREFERENCE_SHOW_STATUS_MENU,
+			  (CFNumberRef)[NSNumber numberWithBool:[(NSButton*)afsMenucheckBox state]],
+			  (CFStringRef)kAfsCommanderID, kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
+
+    CFPreferencesSynchronize((CFStringRef)kAfsCommanderID,  kCFPreferencesAnyUser, kCFPreferencesAnyHost);
+    CFPreferencesSynchronize((CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
+
+    //notify the backgrounder
+    [[NSDistributedNotificationCenter defaultCenter] postNotificationName:kAFSMenuExtraID object:kMExtraAFSMenuChangeState];
 }
 
 // -------------------------------------------------------------------------------
@@ -861,10 +793,9 @@
 // -------------------------------------------------------------------------------
 - (IBAction) searchCellTextEvent:(id) sender
 {
-	
-	NSString *searchText = [[textSearchField stringValue] lowercaseString]; //filter string
-	[self filterCellServDB:searchText];
-	[((NSTableView*)cellList) reloadData];
+    NSString *searchText = [[textSearchField stringValue] lowercaseString]; //filter string
+    [self filterCellServDB:searchText];
+    [((NSTableView*)cellList) reloadData];
 }
 
 // -------------------------------------------------------------------------------
@@ -872,39 +803,39 @@
 //		clear the NSSearchField and showw all CellServDB table
 // -------------------------------------------------------------------------------
 - (void) clearCellServDBFiltering {
-	//Clear the text search
-	[textSearchField setStringValue:@""];
-	//load the temp array with all cell servdb
-	[self searchCellTextEvent:nil];
+    //Clear the text search
+    [textSearchField setStringValue:@""];
+    //load the temp array with all cell servdb
+    [self searchCellTextEvent:nil];
 }
 // --------------------------------------o-----------------------------------------
 //  filterCellServDB:
 //  make the NSMutableArray with all cellservdb or filtered element
 // -------------------------------------------------------------------------------
 - (void) filterCellServDB:(NSString*)textToFilter {
-	DBCellElement *cellElement; //Filtered element
-	BOOL doFilter = !(textToFilter == nil || ([textToFilter length] == 0));
-	
-	// We can do filtering and make the temp array
-	if(filteredCellDB){
-		[filteredCellDB release];
-	}
-	filteredCellDB = [[NSMutableArray alloc] init];
-	NSEnumerator *e = [[afsProperty getCellList] objectEnumerator];
-	while(cellElement = (DBCellElement*)[e nextObject]) {
-		// check if the element can be get
-		if(doFilter) {
-			//Get the CellServDB array enumerator
-			NSRange rsltRng = [[[cellElement getCellName] lowercaseString] rangeOfString:textToFilter];
-		   if(rsltRng.location != NSNotFound) {
-			//we can add this cell to filtered
-			[filteredCellDB addObject:[cellElement retain]];
-		   }
-		} else {
-			[filteredCellDB addObject:[cellElement retain]];
-
-		}
+    DBCellElement *cellElement; //Filtered element
+    BOOL doFilter = !(textToFilter == nil || ([textToFilter length] == 0));
+
+    // We can do filtering and make the temp array
+    if(filteredCellDB){
+	[filteredCellDB release];
+    }
+    filteredCellDB = [[NSMutableArray alloc] init];
+    NSEnumerator *e = [[afsProperty getCellList] objectEnumerator];
+    while(cellElement = (DBCellElement*)[e nextObject]) {
+	// check if the element can be get
+	if(doFilter) {
+	    //Get the CellServDB array enumerator
+	    NSRange rsltRng = [[[cellElement getCellName] lowercaseString] rangeOfString:textToFilter];
+	    if(rsltRng.location != NSNotFound) {
+		//we can add this cell to filtered
+		[filteredCellDB addObject:[cellElement retain]];
+	    }
+	} else {
+	    [filteredCellDB addObject:[cellElement retain]];
+
 	}
+    }
 }
 		   
 // -------------------------------------------------------------------------------
@@ -912,8 +843,8 @@
 // -------------------------------------------------------------------------------
 - (DBCellElement*) getCurrentCellInDB
 {
-	int rowSelected = [((NSTableView *) cellList) selectedRow];
-	return [self getCellByIDX:rowSelected];
+    int rowSelected = [cellList selectedRow];
+    return [self getCellByIDX:rowSelected];
 }
 
 // -------------------------------------------------------------------------------
@@ -921,23 +852,22 @@
 // -------------------------------------------------------------------------------
 - (DBCellElement*) getCellByIDX:(int) idx
 {
-	//NSMutableArray *cellArray = [afsProperty getCellList];
-	DBCellElement *cellElement =  (DBCellElement*)[filteredCellDB objectAtIndex:idx];
-	return cellElement;
+    DBCellElement *cellElement =  (DBCellElement*)[filteredCellDB objectAtIndex:idx];
+    return cellElement;
 }
 
 // -------------------------------------------------------------------------------
 //  showMessage:
 // -------------------------------------------------------------------------------
 -(void) showMessage:(NSString*) message{
-	NSAlert *alert = [[NSAlert alloc] init];
-	
-	[alert setMessageText:message];
-	[alert beginSheetModalForWindow:[[self mainView] window]
-					  modalDelegate:nil 
-					 didEndSelector:nil
-						contextInfo:nil];
-	[alert release];
+    NSAlert *alert = [[NSAlert alloc] init];
+
+    [alert setMessageText:message];
+    [alert beginSheetModalForWindow:[[self mainView] window]
+	   modalDelegate:nil
+	   didEndSelector:nil
+	   contextInfo:nil];
+    [alert release];
 }
 
 // -------------------------------------------------------------------------------
@@ -945,46 +875,36 @@
 // -------------------------------------------------------------------------------
 -(void) setAfsStatus
 {
-	
-	BOOL afsIsUp = [afsProperty checkAfsStatus];
-	BOOL afsEnabledAtStartup = NO;
-	
-	NSMutableString *commandOutput = [NSMutableString stringWithCapacity:20];
-	NSString *rootHelperApp = [[self bundle] pathForResource:@"afshlp" ofType:@""];
-		
-#if 0
-			// make the parameter to call the root helper app
-	const char *checkAFSDaemonParam[] = {"check_afs_daemon",  0L};
-	if([[AuthUtil shared] autorize] == noErr) {
-				//now disable the launchd configuration
-		[[AuthUtil shared] execUnixCommand:[rootHelperApp UTF8String]
-									  args:checkAFSDaemonParam
-									output:commandOutput];
-		afsEnabledAtStartup = [commandOutput rangeOfString:@"afshlp:afs daemon registration result:1"].location!=NSNotFound;
-	}
-#else
-	afsEnabledAtStartup = 1;
-#endif
-	
-	
+    BOOL afsIsUp = [afsProperty checkAfsStatus];
+    BOOL afsEnabledAtStartup = NO;
+    NSString *rootHelperApp = [[self bundle] pathForResource:@"afshlp" ofType:@""];
+
+    if ([self isUnlocked]) {
+	afsEnabledAtStartup = (
+	    [TaskUtil executeTaskWithAuth:@"/bin/launchctl"
+		      arguments:[NSArray arrayWithObjects:@"list",
+					 @"org.openafs.filesystems.afs", nil]
+		      helper:rootHelperApp
+		      withAuthRef:[[authView authorization] authorizationRef]
+	     ] == noErr)?YES:NO;
+	[checkButtonAfsAtBootTime setState:afsEnabledAtStartup];
+    }
 
+    [startStopButton setTitle: (afsIsUp?kAfsButtonShutdown:kAfsButtonStartup)];
 
-	[((NSButton *)startStopButton) setTitle: (afsIsUp?kAfsButtonShutdown:kAfsButtonStartup)];
-	
-	NSMutableAttributedString *colorTitle =[[NSMutableAttributedString alloc] initWithAttributedString:[((NSButton *)startStopButton) attributedTitle]];
+    NSMutableAttributedString *colorTitle =[[NSMutableAttributedString alloc] initWithAttributedString:[startStopButton attributedTitle]];
     NSRange titleRange = NSMakeRange(0, [colorTitle length]);
-	
+
     [colorTitle addAttribute:NSForegroundColorAttributeName
-                       value:(afsIsUp?[NSColor redColor]:[NSColor blackColor])
-                       range:titleRange];
-	
-    [((NSButton *)startStopButton) setAttributedTitle:colorTitle];
-	[checkButtonAfsAtBootTime setState:afsEnabledAtStartup];
-	if(afsIsUp) {
-		[self startTimer];
-	} else {
-		[self stopTimer];
-	}
+		value:(afsIsUp?[NSColor redColor]:[NSColor blackColor])
+		range:titleRange];
+
+    [startStopButton setAttributedTitle:colorTitle];
+    if(afsIsUp) {
+	[self startTimer];
+    } else {
+	[self stopTimer];
+    }
 }
 
 // -------------------------------------------------------------------------------
@@ -992,87 +912,86 @@
 // -------------------------------------------------------------------------------
 - (void) refreshTokens:(NSTimer*)theTimer;
 {
-	if(![tokensLock tryLock]) return;
-	if(tokenList){
-		[tokenList release];
-	}
-	
-	tokenList = [afsProperty getTokenList];
-	[((NSTableView*)tokensTable) reloadData];
-	[tokensLock unlock];
+    if(![tokensLock tryLock]) return;
+    if(tokenList){
+	[tokenList release];
+    }
+
+    tokenList = [afsProperty getTokenList];
+    [tokensTable reloadData];
+    [tokensLock unlock];
 }
 
 // -------------------------------------------------------------------------------
 //  removeExtra:
 // -------------------------------------------------------------------------------
 - (IBAction) addLink:(id) sender {
-	[NSBundle loadNibNamed:@"SymLinkEdit" owner:self];
-	
-	[NSApp beginSheet: lyncCreationSheet
+    [NSBundle loadNibNamed:@"SymLinkEdit" owner:self];
+
+    [NSApp beginSheet: lyncCreationSheet
 	   modalForWindow: [[self mainView] window]
-		modalDelegate: self
+	   modalDelegate: self
 	   didEndSelector: @selector(didEndSymlinkSheet:returnCode:contextInfo:)
-		  contextInfo: nil];
-	
+	   contextInfo: nil];
 }
 
 // -------------------------------------------------------------------------------
 //  removeExtra:
 // -------------------------------------------------------------------------------
 - (IBAction) removeLink:(id) sender {
-	if(!linkConfiguration) return;
-	int index = 0;
-	NSArray *keys = [linkConfiguration allKeys];
-	NSIndexSet *linkToRemove = [tableViewLink selectedRowIndexes];
-	if( [linkToRemove count] > 0) {
-		index = [linkToRemove firstIndex];
-		do {
-			[linkConfiguration removeObjectForKey:[keys objectAtIndex:index]];
-		} while ((index = [linkToRemove indexGreaterThanIndex:index]) != -1);
-	}
-	
-	//write the new configuration
-	NSData *prefData = nil;
-	if([linkConfiguration count] > 0) {
-		prefData = [NSPropertyListSerialization dataWithPropertyList:linkConfiguration
-															  format:NSPropertyListXMLFormat_v1_0
-															 options:0
-															   error:nil];
-	}
-	CFPreferencesSetValue((CFStringRef)PREFERENCE_LINK_CONFIGURATION,
-						  (CFDataRef)prefData,
-						  (CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
-	
-	CFPreferencesSynchronize((CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
-	
-	//reload the new data
-	[tableViewLink reloadData];
+    if(!linkConfiguration) return;
+    int index = 0;
+    NSArray *keys = [linkConfiguration allKeys];
+    NSIndexSet *linkToRemove = [tableViewLink selectedRowIndexes];
+    if( [linkToRemove count] > 0) {
+	index = [linkToRemove firstIndex];
+	do {
+	    [linkConfiguration removeObjectForKey:[keys objectAtIndex:index]];
+	} while ((index = [linkToRemove indexGreaterThanIndex:index]) != -1);
+    }
+
+    //write the new configuration
+    NSData *prefData = nil;
+    if([linkConfiguration count] > 0) {
+	prefData = [NSPropertyListSerialization dataWithPropertyList:linkConfiguration
+						format:NSPropertyListXMLFormat_v1_0
+						options:0
+						error:nil];
+    }
+    CFPreferencesSetValue((CFStringRef)PREFERENCE_LINK_CONFIGURATION,
+			  (CFDataRef)prefData,
+			  (CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
+
+    CFPreferencesSynchronize((CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
+
+    //reload the new data
+    [tableViewLink reloadData];
 }
 
 // -------------------------------------------------------------------------------
 //  removeExtra:
 // -------------------------------------------------------------------------------
 - (IBAction) enableLink:(id) sender {
-	[self writePreferenceFile];
+    [self writePreferenceFile];
 }
 
 // -------------------------------------------------------------------------------
 //  removeExtra:
 // -------------------------------------------------------------------------------
 - (IBAction) manageBackgrounderActivation:(id)sender {
-	[PListManager launchctlCommand:[(NSButton*)sender state] 
-						userDomain:YES 
-							option:[NSArray arrayWithObjects:@"-S", @"Aqua", nil] 
-						 plistName:[NSString stringWithFormat:@"%@.plist", BACKGROUNDER_P_FILE]];
-	//re ad the status to check taht all is gone well
-	[backgrounderActivationCheck setState:[PListManager launchdJobState:BACKGROUNDER_P_FILE]];
+    [PListManager launchctlCommand:[(NSButton*)sender state]
+		  userDomain:YES
+		  option:[NSArray arrayWithObjects:@"-S", @"Aqua", nil]
+		  plistName:[NSString stringWithFormat:@"%@.plist", BACKGROUNDER_P_FILE]];
+    //read the status to check that all is gone well
+    [backgrounderActivationCheck setState:[PListManager launchdJobState:BACKGROUNDER_P_FILE]];
 }
 
 // -------------------------------------------------------------------------------
 //  tableViewLinkPerformClick:
 // -------------------------------------------------------------------------------
 - (IBAction) tableViewLinkPerformClick:(id) sender {
-	NSLog(@"tableViewLinkPerformClick");
+    NSLog(@"tableViewLinkPerformClick");
 }
 
 // -------------------------------------------------------------------------------
@@ -1080,29 +999,49 @@
 // -------------------------------------------------------------------------------
 - (void)tabView:(NSTabView *)tabView willSelectTabViewItem: (NSTabViewItem *)tabViewItem 
 {
-	//check to see if the cache param tab is the tab that will be selected
-	if([((NSString*)[tabViewItem identifier]) intValue] == TAB_LINK)
-	{
-		[tableViewLink reloadData];
-	}
+    //check to see if the cache param tab is the tab that will be selected
+    if([((NSString*)[tabViewItem identifier]) intValue] == TAB_LINK)
+    {
+	[tableViewLink reloadData];
+    }
 }
 // -------------------------------------------------------------------------------
 //  tableViewLinkPerformClick:
 // -------------------------------------------------------------------------------
 - (IBAction) enableDisableKrb5RenewCheck:(id) sender {
-	//NSLog(@"enableDisableKrb5RenewCheck");
-	CFPreferencesSetValue((CFStringRef)PREFERENCE_KRB5_CHECK_ENABLE,
-						  (CFNumberRef) [NSNumber numberWithInt:[(NSButton*)sender intValue]],
-						  (CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
-	CFPreferencesSynchronize((CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
-		//notify the backgrounder
-	[[NSDistributedNotificationCenter defaultCenter] postNotificationName:kAFSMenuExtraID object:kPrefChangeNotification];
+    //NSLog(@"enableDisableKrb5RenewCheck");
+    CFPreferencesSetValue((CFStringRef)PREFERENCE_KRB5_CHECK_ENABLE,
+			  (CFNumberRef) [NSNumber numberWithInt:[(NSButton*)sender intValue]],
+			  (CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
+    CFPreferencesSynchronize((CFStringRef)kAfsCommanderID,  kCFPreferencesCurrentUser, kCFPreferencesAnyHost);
+    //notify the backgrounder
+    [[NSDistributedNotificationCenter defaultCenter] postNotificationName:kAFSMenuExtraID object:kPrefChangeNotification];
 }
 // -------------------------------------------------------------------------------
 //  tableViewLinkPerformClick:
 // -------------------------------------------------------------------------------
 - (IBAction) krb5RenewParamChange:(id) sender {
 }
+
+
+- (BOOL)isUnlocked {
+    return [authView authorizationState] == SFAuthorizationViewUnlockedState;
+}
+
+- (void)authorizationViewDidAuthorize:(SFAuthorizationView *)view {
+    // enable things
+    [startStopButton setEnabled:[self isUnlocked]];
+    [checkButtonAfsAtBootTime setEnabled:[self isUnlocked]];
+    [self setAfsStatus];
+    [installKRB5AuthAtLoginButton setEnabled:[self isUnlocked]];
+}
+
+- (void)authorizationViewDidDeauthorize:(SFAuthorizationView *)view {
+    // disable things
+    [startStopButton setEnabled:[self isUnlocked]];
+    [checkButtonAfsAtBootTime setEnabled:[self isUnlocked]];
+    [installKRB5AuthAtLoginButton setEnabled:[self isUnlocked]];
+}
 @end
 
 @implementation AFSCommanderPref (NSTableDataSource)
@@ -1116,29 +1055,28 @@
 - (void)tableView:(NSTableView *)table 
    setObjectValue:(id)data 
    forTableColumn:(NSTableColumn *)col 
-			  row:(int)row
+	      row:(int)row
 {
-	NSString *identifier = (NSString*)[col identifier];
-	switch([table tag]){
-		case TABLE_TOKENS_LIST:
-			break;
-			
-		case TABLE_CELL_LIST:
-			// we are editing checkbox for cellservdb table
-			if([identifier intValue] == CELLSRVDB_TABLE_USR_DFLT_CHECK_COLUMN) {
-				// set the user default cell
-				DBCellElement *cellElement =  (DBCellElement*)[filteredCellDB objectAtIndex:row];
-				[afsProperty setDefaultCellByName:[cellElement getCellName]];
-				//[afsDefaultCellLabel setStringValue:[afsProperty getDefaultCellName]];
-				[((NSTableView*)cellList) reloadData];
-			} else if([identifier intValue] == CELLSRVDB_TABLE_DFLT_CHECK_COLUMN) {
-				// set the cell for wich the user want to get token
-				DBCellElement *cellElement =  (DBCellElement*)[filteredCellDB objectAtIndex:row];
-				[cellElement setUserDefaultForToken:![cellElement userDefaultForToken]];
-			}  
-			break;
-	}
+    NSString *identifier = (NSString*)[col identifier];
+    switch([table tag]){
+    case TABLE_TOKENS_LIST:
+	break;
 	
+    case TABLE_CELL_LIST:
+	// we are editing checkbox for cellservdb table
+	if([identifier intValue] == CELLSRVDB_TABLE_USR_DFLT_CHECK_COLUMN) {
+	    // set the user default cell
+	    DBCellElement *cellElement =  (DBCellElement*)[filteredCellDB objectAtIndex:row];
+	    [afsProperty setDefaultCellByName:[cellElement getCellName]];
+	    //[afsDefaultCellLabel setStringValue:[afsProperty getDefaultCellName]];
+	    [((NSTableView*)cellList) reloadData];
+	} else if([identifier intValue] == CELLSRVDB_TABLE_DFLT_CHECK_COLUMN) {
+	    // set the cell for wich the user want to get token
+	    DBCellElement *cellElement =  (DBCellElement*)[filteredCellDB objectAtIndex:row];
+	    [cellElement setUserDefaultForToken:![cellElement userDefaultForToken]];
+	}
+	break;
+    }
 }
 
 
@@ -1146,31 +1084,28 @@
 //  tableView:
 //		refresh delegate method for two AFSCommander table
 // -------------------------------------------------------------------------------
-- (id) 	tableView:(NSTableView *) aTableView
-	objectValueForTableColumn:(NSTableColumn *) aTableColumn
-						  row:(int) rowIndex
+- (id) tableView:(NSTableView *) aTableView
+objectValueForTableColumn:(NSTableColumn *) aTableColumn
+	     row:(int) rowIndex
 {  
+    id result = nil;
+    NSString *identifier = (NSString*)[aTableColumn identifier];
+    switch([aTableView tag]){
+    case TABLE_TOKENS_LIST:
+	//We are refreshing tokens table
+	result = [self getTableTokensListValue:[identifier intValue] row:rowIndex];
+	break;
 	
-	id result = nil;
-	NSString *identifier = (NSString*)[aTableColumn identifier];
-	switch([aTableView tag]){
-		case TABLE_TOKENS_LIST:
-			//We are refreshing tokens table
-			result = [self getTableTokensListValue:[identifier intValue] row:rowIndex];
-			break;
-			
-		case TABLE_CELL_LIST:
-			//We are refreshing cell db table
-			result = [self getTableCelListValue:[identifier intValue] row:rowIndex];
-			break;
-			
-		case TABLE_LINK_LIST:
-			result = [self getTableLinkValue:[identifier intValue] row:rowIndex];
-			break;
-
-		
-	}
-	return result;  
+    case TABLE_CELL_LIST:
+	//We are refreshing cell db table
+	result = [self getTableCelListValue:[identifier intValue] row:rowIndex];
+	break;
+
+    case TABLE_LINK_LIST:
+	result = [self getTableLinkValue:[identifier intValue] row:rowIndex];
+	break;
+    }
+    return result;
 }
 
 
@@ -1179,14 +1114,14 @@
 // -------------------------------------------------------------------------------
 - (id)getTableTokensListValue:(int) colId row:(int)row
 {
-	id result = nil;
-	if(!tokenList) return nil;
-	switch(colId){
-		case 0:
-			result = (NSString*)[tokenList objectAtIndex:row];
-			break;
-	}
-	return result;
+    id result = nil;
+    if(!tokenList) return nil;
+    switch(colId){
+    case 0:
+	result = (NSString*)[tokenList objectAtIndex:row];
+	break;
+    }
+    return result;
 }
 
 
@@ -1195,26 +1130,26 @@
 // -------------------------------------------------------------------------------
 - (id)getTableCelListValue:(int) colId row:(int)row
 {
-	id result = nil;
-	//NSMutableArray *cellArray = [afsProperty getCellList];
-	DBCellElement *cellElement =  (DBCellElement*)[filteredCellDB objectAtIndex:row];
-	switch(colId){
-		case CELLSRVDB_TABLE_USR_DFLT_CHECK_COLUMN:
-			result = [NSNumber numberWithInt:[cellElement userDefaultForCell]];
-			break;
-			
-		case CELLSRVDB_TABLE_DFLT_CHECK_COLUMN:
-			result = [NSNumber numberWithInt:[cellElement userDefaultForToken]];
-			break;
-		case CELLSRVDB_TABLE_NAME_COLUMN:
-			result = [cellElement getCellName];
-			break;
-			
-		case CELLSRVDB_TABLE_DESCRIPTION_COLUMN:
-			result = [cellElement getCellComment];
-			break;
-	}
-	return result;
+    id result = nil;
+    //NSMutableArray *cellArray = [afsProperty getCellList];
+    DBCellElement *cellElement =  (DBCellElement*)[filteredCellDB objectAtIndex:row];
+    switch(colId){
+    case CELLSRVDB_TABLE_USR_DFLT_CHECK_COLUMN:
+	result = [NSNumber numberWithInt:[cellElement userDefaultForCell]];
+	break;
+
+    case CELLSRVDB_TABLE_DFLT_CHECK_COLUMN:
+	result = [NSNumber numberWithInt:[cellElement userDefaultForToken]];
+	break;
+    case CELLSRVDB_TABLE_NAME_COLUMN:
+	result = [cellElement getCellName];
+	break;
+
+    case CELLSRVDB_TABLE_DESCRIPTION_COLUMN:
+	result = [cellElement getCellComment];
+	break;
+    }
+    return result;
 }
 
 // -------------------------------------------------------------------------------
@@ -1222,18 +1157,18 @@
 // -------------------------------------------------------------------------------
 - (id)getTableLinkValue:(int) colId row:(int)row
 {
-	id result = nil;
-	NSArray *allKey = [linkConfiguration allKeys];
-	switch(colId){
-		case TABLE_COLUMN_LINK_NAME:
-			result = [allKey objectAtIndex:row];
-			break;
-			
-		case TABLE_COLUMN_LINK_PATH:
-			result = [linkConfiguration objectForKey:[allKey objectAtIndex:row]];
-			break;
-	}
-	return result;
+    id result = nil;
+    NSArray *allKey = [linkConfiguration allKeys];
+    switch(colId){
+    case TABLE_COLUMN_LINK_NAME:
+	result = [allKey objectAtIndex:row];
+	break;
+
+    case TABLE_COLUMN_LINK_PATH:
+	result = [linkConfiguration objectForKey:[allKey objectAtIndex:row]];
+	break;
+    }
+    return result;
 }
 
 
@@ -1242,25 +1177,21 @@
 // -------------------------------------------------------------------------------
 - (int)numberOfRowsInTableView:(NSTableView *)aTableView
 {
-	int rowCount = 0;
-	//NSMutableArray *cellArray = nil;
-	switch([aTableView tag]){
-		case TABLE_TOKENS_LIST:
-			if(tokenList)  rowCount = [tokenList count];
-			break;
-			
-		case TABLE_CELL_LIST:
-			//cellArray = [afsProperty getCellList];
-			if(filteredCellDB)  rowCount = [filteredCellDB count];
-			break;
-			
-		case TABLE_LINK_LIST:
-			if(linkConfiguration)  rowCount = [linkConfiguration count];
-			break;
-
-			
-	}	
-	return rowCount;  
+    int rowCount = 0;
+    switch([aTableView tag]){
+    case TABLE_TOKENS_LIST:
+	if(tokenList)  rowCount = [tokenList count];
+	break;
+
+    case TABLE_CELL_LIST:
+	if(filteredCellDB)  rowCount = [filteredCellDB count];
+	break;
+
+    case TABLE_LINK_LIST:
+	if(linkConfiguration)  rowCount = [linkConfiguration count];
+	break;
+    }
+    return rowCount;
 }
 @end
 
@@ -1271,22 +1202,21 @@
 // -------------------------------------------------------------------------------
 - (BOOL)selectionShouldChangeInTableView:(NSTableView *)aTable
 {
-	switch([aTable tag]){
-		case TABLE_TOKENS_LIST:
-			
-			break;
-			
-		case TABLE_CELL_LIST:
-			[self tableViewCellmanageButtonState:[aTable selectedRow]];
-			break;
-			
-		case TABLE_LINK_LIST:
-			break;
-			
-			
-	}	
+    switch([aTable tag]){
+    case TABLE_TOKENS_LIST:
+	break;
 	
-	return YES;
+    case TABLE_CELL_LIST:
+	[self tableViewCellmanageButtonState:[aTable selectedRow]];
+	break;
+
+    case TABLE_LINK_LIST:
+	break;
+
+
+    }
+
+    return YES;
 }
 
 // -------------------------------------------------------------------------------
@@ -1294,56 +1224,50 @@
 // -------------------------------------------------------------------------------
 - (BOOL)tableView:(NSTableView *)aTable shouldSelectRow:(int)aRow
 {
-	switch([aTable tag]){
-		case TABLE_TOKENS_LIST:
-			
-			break;
-			
-		case TABLE_CELL_LIST:
-			[self tableViewCellmanageButtonState:aRow];
-			break;
-			
-		case TABLE_LINK_LIST:
-			break;
-			
-			
-	}
+    switch([aTable tag]){
+    case TABLE_TOKENS_LIST:
+	break;
+
+    case TABLE_CELL_LIST:
+	[self tableViewCellmanageButtonState:aRow];
+	break;
 	
-	return YES;
+    case TABLE_LINK_LIST:
+	break;
+    }
+    return YES;
 }
 
 // -------------------------------------------------------------------------------
 //  tableView:
 // -------------------------------------------------------------------------------
 - (void)tableViewSelectionDidChange:(NSNotification *)aNotification {
-	NSTableView *aTable = [aNotification object];
-	switch([aTable tag]){
-		case TABLE_TOKENS_LIST:
-			break;
-			
-		case TABLE_CELL_LIST:
-			break;
-			
-		case TABLE_LINK_LIST:
-			[self tableViewLinkmanageButtonState:[aTable selectedRowIndexes]];
-			break;
-			
-			
-	}
+    NSTableView *aTable = [aNotification object];
+    switch([aTable tag]){
+    case TABLE_TOKENS_LIST:
+	break;
+
+    case TABLE_CELL_LIST:
+	break;
+
+    case TABLE_LINK_LIST:
+	[self tableViewLinkmanageButtonState:[aTable selectedRowIndexes]];
+	break;
+    }
 }
 // -------------------------------------------------------------------------------
 //  manageButtonState:
 // -------------------------------------------------------------------------------
 -(void) tableViewCellmanageButtonState:(int) rowSelected  {
-	[((NSControl*) cellIpButton) setEnabled:rowSelected >= 0];
-	[((NSControl*) removeCellButton) setEnabled:rowSelected >= 0];
+    [cellIpButton setEnabled:rowSelected >= 0];
+    [removeCellButton setEnabled:rowSelected >= 0];
 }
 
 // -------------------------------------------------------------------------------
 //  manageButtonState:
 // -------------------------------------------------------------------------------
 -(void) tableViewLinkmanageButtonState:(NSIndexSet *) rowsSelectedIndex {
-	[buttonRemoveLink setEnabled:[rowsSelectedIndex count]>0];
+    [buttonRemoveLink setEnabled:[rowsSelectedIndex count]>0];
 }
 @end
 
@@ -1355,9 +1279,9 @@
 - (void)didEndSheet:(NSWindow *)sheet returnCode:(int)returnCode contextInfo:(void *)contextInfo
 {
     [sheet orderOut:self];
-	//Filter the cellServDb and allocate filtered array
-	[self searchCellTextEvent:nil];
-	[((NSTableView*)cellList) reloadData];
+    //Filter the cellServDb and allocate filtered array
+    [self searchCellTextEvent:nil];
+    [cellList reloadData];
 }
 
 // -------------------------------------------------------------------------------
@@ -1365,18 +1289,17 @@
 // -------------------------------------------------------------------------------
 - (void)didEndCredentialSheet:(NSWindow *)sheet returnCode:(int)returnCode contextInfo:(void *)contextInfo
 {
-	if([((TokenCredentialController*)credentialCommander) takenToken] == YES){
-		/*[AFSPropertyManager klog:[((TokenCredentialController*)credentialCommander) uName] 
-							uPwd:[((TokenCredentialController*)credentialCommander) uPwd] ];*/
-		[afsProperty getTokens:true 
-						   usr:[((TokenCredentialController*)credentialCommander) uName] 
-						   pwd:[((TokenCredentialController*)credentialCommander) uPwd]];
-	}
+    if([((TokenCredentialController*)credentialCommander) takenToken] == YES){
+	/*[AFSPropertyManager klog:[((TokenCredentialController*)credentialCommander) uName]
+	  uPwd:[((TokenCredentialController*)credentialCommander) uPwd] ];*/
+	[afsProperty getTokens:true
+		     usr:[((TokenCredentialController*)credentialCommander) uName]
+		     pwd:[((TokenCredentialController*)credentialCommander) uPwd]];
+    }
     [sheet orderOut:self];
-	[self refreshTokens:nil];
-	//Inform afs menuextra to updata afs status
-	[[NSDistributedNotificationCenter defaultCenter] postNotificationName:kAFSMenuExtraID object:kMExtraAFSStateChange];
-
+    [self refreshTokens:nil];
+    //Inform afs menuextra to updata afs status
+    [[NSDistributedNotificationCenter defaultCenter] postNotificationName:kAFSMenuExtraID object:kMExtraAFSStateChange];
 }
 
 // -------------------------------------------------------------------------------
@@ -1384,7 +1307,7 @@
 // -------------------------------------------------------------------------------
 - (void)didEndInfoSheet:(NSWindow *)sheet returnCode:(int)returnCode contextInfo:(void *)contextInfo
 {
-	[sheet orderOut:self];
+    [sheet orderOut:self];
 }
 
 // -------------------------------------------------------------------------------
@@ -1392,9 +1315,8 @@
 // -------------------------------------------------------------------------------
 - (void)didEndSymlinkSheet:(NSWindow *)sheet returnCode:(int)returnCode contextInfo:(void *)contextInfo
 {
-	[lyncCreationSheet orderOut:self];
-	[self readPreferenceFile];
-	[tableViewLink reloadData];
-	
+    [lyncCreationSheet orderOut:self];
+    [self readPreferenceFile];
+    [tableViewLink reloadData];
 }
 @end
diff --git a/src/platform/DARWIN/AFSPreference/AFSPropertyManager.h b/src/platform/DARWIN/AFSPreference/AFSPropertyManager.h
index e229c76..0ed4cd4 100644
--- a/src/platform/DARWIN/AFSPreference/AFSPropertyManager.h
+++ b/src/platform/DARWIN/AFSPreference/AFSPropertyManager.h
@@ -29,7 +29,7 @@
 	NSString *afsRootMountPoint;
 	int statCacheEntry;
 	int dCacheDim;
-	int	cacheDimension;
+	int cacheDimension;
 	int daemonNumber;
 	int nVolEntry;
 	bool dynRoot;
diff --git a/src/platform/DARWIN/AFSPreference/AFSPropertyManager.m b/src/platform/DARWIN/AFSPreference/AFSPropertyManager.m
index fb696da..e96fc74 100644
--- a/src/platform/DARWIN/AFSPreference/AFSPropertyManager.m
+++ b/src/platform/DARWIN/AFSPreference/AFSPropertyManager.m
@@ -92,7 +92,6 @@
 	if(cellList) {[cellList removeAllObjects];[cellList release];}
 	if(cellName) {[cellName release];}
 	if(futil) {
-		[futil endAutorization];
 		[futil release];
 		futil = nil; 
 	}
@@ -360,7 +359,7 @@
 	
 	NSCharacterSet *returnCS = [NSCharacterSet characterSetWithCharactersInString:@"\n"];
 	NSFileHandle *fileH = [NSFileHandle fileHandleForReadingAtPath:filePath];
-	if (!fileH) return nil;
+	if (!fileH) return 0;
 	NSData *fileHData = [fileH readDataToEndOfFile];
 	NSString *cacheInfoStrData = [[NSString alloc] initWithData:fileHData
 													   encoding:NSASCIIStringEncoding];
@@ -465,7 +464,7 @@
 // -------------------------------------------------------------------------------
 -(int) readOldAfsdOption:(NSString*)filePath
 {
-	if(!filePath) return nil;
+	if(!filePath) return 0;
 	return [self readAFSDParamLineContent:[[NSString stringWithContentsOfFile:filePath 
 															  encoding:NSUTF8StringEncoding 
 																 error:nil] stringByStandardizingPath]];
@@ -475,7 +474,7 @@
 //  readAFSDParamLineContent:
 // -------------------------------------------------------------------------------
 -(int) readAFSDParamLineContent:(NSString*) paramLine{
-	if (!paramLine) return nil;
+	if (!paramLine) return 0;
 
 	NSString *tmpString = nil;
 	NSCharacterSet *space = [NSCharacterSet characterSetWithCharactersInString:@" "];
@@ -537,16 +536,16 @@
 // -------------------------------------------------------------------------------
 -(int) readNewAfsdOption:(NSString*)filePath
 {
-	if(!filePath) return nil;
-	NSString *currentLines = nil;
-	NSString *paramValue = nil;
-	NSScanner *lineScanner = nil;
+	if(!filePath) return 0;
+	NSString *currentLines = 0;
+	NSString *paramValue = 0;
+	NSScanner *lineScanner = 0;
 	
 	//Get file content
 	NSString *newAFSDConfContent = [NSString stringWithContentsOfFile:filePath 
 															 encoding:NSUTF8StringEncoding 
 																error:nil];
-	if (!newAFSDConfContent) return nil;
+	if (!newAFSDConfContent) return 0;
 	
 	//get lines in array
 	NSArray *confLines = [newAFSDConfContent componentsSeparatedByString:@"\n"];
@@ -1078,23 +1077,18 @@
 // -------------------------------------------------------------------------------
 -(void) shutdown
 {
-	@try {
-		const char *stopArgs[] = {"stop", 0L};
-		if([[AuthUtil shared] autorize] == noErr) {
-			[[AuthUtil shared] execUnixCommand:AFS_DAEMON_STARTUPSCRIPT
-										  args:stopArgs
-										output:nil];
-		}
-
-	}
-	@catch (NSException * e) {
-		@throw e;
-	}
-	@finally {
-	
-	}
-	
-	
+  NSString *rootHelperApp = [[NSBundle bundleForClass:[self class]] pathForResource:@"afshlp" ofType:@""];
+    @try {
+	const char *stopArgs[] = {AFS_DAEMON_STARTUPSCRIPT, "stop", 0L};
+	[[AuthUtil shared] execUnixCommand:[rootHelperApp fileSystemRepresentation]
+			   args:stopArgs
+			   output:nil];
+    }
+    @catch (NSException * e) {
+	@throw e;
+    }
+    @finally {
+    }
 }
 
 
@@ -1103,24 +1097,20 @@
 // -------------------------------------------------------------------------------
 -(void) startup
 {
-	@try {
-		const char *startArgs[] = {"start", 0L};
-		if([[AuthUtil shared] autorize] == noErr) {
-			[[AuthUtil shared] execUnixCommand:AFS_DAEMON_STARTUPSCRIPT
-										  args:startArgs
-										output:nil];
-		}
-
-	}
-	@catch (NSException * e) {
-		@throw e;
-	}
-	@finally {
-
-	}
-
-
+  NSString *rootHelperApp = [[NSBundle bundleForClass:[self class]] pathForResource:@"afshlp" ofType:@""];
+    @try {
+	const char *startArgs[] = {AFS_DAEMON_STARTUPSCRIPT, "start", 0L};
+	[[AuthUtil shared] execUnixCommand:[rootHelperApp fileSystemRepresentation]
+			   args:startArgs
+			   output:nil];
+    }
+    @catch (NSException * e) {
+	@throw e;
+    }
+    @finally {
+    }
 }
+
 // -------------------------------------------------------------------------------
 //  -(void) saveConfigurationFiles
 // -------------------------------------------------------------------------------
@@ -1166,13 +1156,6 @@
 							 encoding:  NSUTF8StringEncoding 
 								error:&err];
 		
-		// backup original file
-		if([futil startAutorization] != noErr){
-			@throw [NSException exceptionWithName:@"saveConfigurationFiles:startAutorization" 
-										   reason:kUserNotAuth
-										 userInfo:nil];
-		}
-
 		if(makeBackup) [self backupConfigurationFiles];
 
 		// install ThisCell
@@ -1220,12 +1203,6 @@
 		[self writeAfsdOption:useAfsdConfVersion?AFSD_TMP_NEW_PREFERENCE_FILE:AFSD_TMP_OLD_PREFERENCE_FILE];
 		
 		// backup original file
-		if([futil startAutorization] != noErr){
-			@throw [NSException exceptionWithName:@"AFSPropertyManager:saveCacheConfigurationFiles:startAutorization" 
-										   reason:kUserNotAuth
-										 userInfo:nil];
-		}
-		
 		if(makeBackup) {
 			//cacheinfo
 			[self backupFile:@"/etc/cacheinfo"];
@@ -1294,11 +1271,6 @@
 {	
 
 	@try{
-		if([futil startAutorization] != noErr){
-			@throw [NSException exceptionWithName:@"backupConfigurationFiles:startAutorization" 
-										   reason:kUserNotAuth
-										 userInfo:nil];
-		}
 		//This cell
 		[self backupFile:@"/etc/ThisCell"];
 	
@@ -1308,7 +1280,6 @@
 		//TheseCell
 		[self backupFile:@"/etc/TheseCells"];
 		
-		//[futil endAutorization];
 	} @catch (NSException *e) {
 		@throw e;
 	} @finally {
@@ -1329,8 +1300,6 @@
 		
 		//Check if the file at path exist
 		NSFileManager *fileManager = [NSFileManager defaultManager];
-		
-		//check if th efile exist
 		if(![fileManager fileExistsAtPath:[filePath stringByExpandingTildeInPath]]) return;
 		
 		// store the source path
diff --git a/src/platform/DARWIN/AFSPreference/English.lproj/OpenAFSPreference.xib b/src/platform/DARWIN/AFSPreference/English.lproj/OpenAFSPreference.xib
index 80acbdf..b1190ba 100644
--- a/src/platform/DARWIN/AFSPreference/English.lproj/OpenAFSPreference.xib
+++ b/src/platform/DARWIN/AFSPreference/English.lproj/OpenAFSPreference.xib
@@ -2,30 +2,46 @@
 <archive type="com.apple.InterfaceBuilder3.Cocoa.XIB" version="7.10">
 	<data>
 		<int key="IBDocument.SystemTarget">1050</int>
-		<string key="IBDocument.SystemVersion">10C540</string>
-		<string key="IBDocument.InterfaceBuilderVersion">762</string>
-		<string key="IBDocument.AppKitVersion">1038.25</string>
-		<string key="IBDocument.HIToolboxVersion">458.00</string>
+		<string key="IBDocument.SystemVersion">11D50d</string>
+		<string key="IBDocument.InterfaceBuilderVersion">2182</string>
+		<string key="IBDocument.AppKitVersion">1138.32</string>
+		<string key="IBDocument.HIToolboxVersion">568.00</string>
 		<object class="NSMutableDictionary" key="IBDocument.PluginVersions">
 			<string key="NS.key.0">com.apple.InterfaceBuilder.CocoaPlugin</string>
-			<string key="NS.object.0">762</string>
+			<string key="NS.object.0">2182</string>
 		</object>
-		<object class="NSMutableArray" key="IBDocument.EditedObjectIDs">
+		<object class="NSArray" key="IBDocument.IntegratedClassDependencies">
 			<bool key="EncodedWithXMLCoder">YES</bool>
-			<integer value="101"/>
+			<string>NSTabView</string>
+			<string>NSStepper</string>
+			<string>NSButton</string>
+			<string>NSCustomObject</string>
+			<string>NSTableView</string>
+			<string>NSCustomView</string>
+			<string>NSSearchField</string>
+			<string>NSTextField</string>
+			<string>NSNumberFormatter</string>
+			<string>NSSearchFieldCell</string>
+			<string>NSWindowTemplate</string>
+			<string>NSTextFieldCell</string>
+			<string>NSStepperCell</string>
+			<string>NSButtonCell</string>
+			<string>NSTableColumn</string>
+			<string>NSBox</string>
+			<string>NSView</string>
+			<string>NSScrollView</string>
+			<string>NSTabViewItem</string>
+			<string>NSTextView</string>
+			<string>NSScroller</string>
+			<string>NSTableHeaderView</string>
 		</object>
 		<object class="NSArray" key="IBDocument.PluginDependencies">
 			<bool key="EncodedWithXMLCoder">YES</bool>
 			<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
 		</object>
 		<object class="NSMutableDictionary" key="IBDocument.Metadata">
-			<bool key="EncodedWithXMLCoder">YES</bool>
-			<object class="NSArray" key="dict.sortedKeys" id="0">
-				<bool key="EncodedWithXMLCoder">YES</bool>
-			</object>
-			<object class="NSMutableArray" key="dict.values">
-				<bool key="EncodedWithXMLCoder">YES</bool>
-			</object>
+			<string key="NS.key.0">PluginDependencyRecalculationVersion</string>
+			<integer value="1" key="NS.object.0"/>
 		</object>
 		<object class="NSMutableArray" key="IBDocument.RootObjects" id="84888716">
 			<bool key="EncodedWithXMLCoder">YES</bool>
@@ -48,7 +64,7 @@
 				<object class="NSMutableString" key="NSViewClass">
 					<characters key="NS.bytes">View</characters>
 				</object>
-				<string key="NSWindowContentMaxSize">{1.79769e+308, 1.79769e+308}</string>
+				<nil key="NSUserInterfaceItemIdentifier"/>
 				<object class="NSView" key="NSWindowView" id="645279396">
 					<reference key="NSNextResponder"/>
 					<int key="NSvFlags">274</int>
@@ -59,6 +75,8 @@
 							<int key="NSvFlags">256</int>
 							<string key="NSFrame">{{17, 1}, {304, 14}}</string>
 							<reference key="NSSuperview" ref="645279396"/>
+							<reference key="NSWindow"/>
+							<reference key="NSNextKeyView" ref="1047946385"/>
 							<bool key="NSEnabled">YES</bool>
 							<object class="NSTextFieldCell" key="NSCell" id="947523856">
 								<int key="NSCellFlags">67239424</int>
@@ -97,7 +115,7 @@
 								<bool key="EncodedWithXMLCoder">YES</bool>
 								<object class="NSView" id="520583273">
 									<reference key="NSNextResponder" ref="748501112"/>
-									<int key="NSvFlags">256</int>
+									<int key="NSvFlags">274</int>
 									<object class="NSMutableArray" key="NSSubviews">
 										<bool key="EncodedWithXMLCoder">YES</bool>
 										<object class="NSButton" id="709840556">
@@ -105,6 +123,8 @@
 											<int key="NSvFlags">268</int>
 											<string key="NSFrame">{{13, 7}, {109, 28}}</string>
 											<reference key="NSSuperview" ref="520583273"/>
+											<reference key="NSWindow"/>
+											<reference key="NSNextKeyView" ref="713307252"/>
 											<bool key="NSEnabled">YES</bool>
 											<object class="NSButtonCell" key="NSCell" id="675447498">
 												<int key="NSCellFlags">67239424</int>
@@ -132,6 +152,8 @@
 											<int key="NSvFlags">265</int>
 											<string key="NSFrame">{{526, 9}, {21, 23}}</string>
 											<reference key="NSSuperview" ref="520583273"/>
+											<reference key="NSWindow"/>
+											<reference key="NSNextKeyView" ref="739317740"/>
 											<bool key="NSEnabled">YES</bool>
 											<object class="NSButtonCell" key="NSCell" id="1009755861">
 												<int key="NSCellFlags">-2080244224</int>
@@ -159,6 +181,8 @@
 											<int key="NSvFlags">268</int>
 											<string key="NSFrame">{{138, 13}, {117, 18}}</string>
 											<reference key="NSSuperview" ref="520583273"/>
+											<reference key="NSWindow"/>
+											<reference key="NSNextKeyView" ref="871603218"/>
 											<bool key="NSEnabled">YES</bool>
 											<object class="NSButtonCell" key="NSCell" id="98390178">
 												<int key="NSCellFlags">67239424</int>
@@ -184,10 +208,14 @@
 									</object>
 									<string key="NSFrame">{{1, 1}, {562, 43}}</string>
 									<reference key="NSSuperview" ref="748501112"/>
+									<reference key="NSWindow"/>
+									<reference key="NSNextKeyView" ref="709840556"/>
 								</object>
 							</object>
 							<string key="NSFrame">{{17, 423}, {564, 45}}</string>
 							<reference key="NSSuperview" ref="645279396"/>
+							<reference key="NSWindow"/>
+							<reference key="NSNextKeyView" ref="520583273"/>
 							<string key="NSOffsets">{0, 0}</string>
 							<object class="NSTextFieldCell" key="NSTitleCell">
 								<int key="NSCellFlags">67239424</int>
@@ -223,6 +251,8 @@
 							<int key="NSvFlags">274</int>
 							<string key="NSFrame">{{13, 15}, {572, 401}}</string>
 							<reference key="NSSuperview" ref="645279396"/>
+							<reference key="NSWindow"/>
+							<reference key="NSNextKeyView" ref="1020318718"/>
 							<object class="NSMutableArray" key="NSTabViewItems">
 								<bool key="EncodedWithXMLCoder">YES</bool>
 								<object class="NSTabViewItem" id="269508902">
@@ -249,6 +279,8 @@
 																<int key="NSvFlags">256</int>
 																<string key="NSFrameSize">{516, 140}</string>
 																<reference key="NSSuperview" ref="457121079"/>
+																<reference key="NSWindow"/>
+																<reference key="NSNextKeyView" ref="884311606"/>
 																<int key="NSTag">1</int>
 																<bool key="NSEnabled">YES</bool>
 																<object class="NSTableHeaderView" key="NSHeaderView" id="1048519426">
@@ -256,13 +288,14 @@
 																	<int key="NSvFlags">256</int>
 																	<string key="NSFrameSize">{516, 17}</string>
 																	<reference key="NSSuperview" ref="214413149"/>
+																	<reference key="NSWindow"/>
+																	<reference key="NSNextKeyView" ref="457121079"/>
 																	<reference key="NSTableView" ref="313963250"/>
 																</object>
-																<object class="_NSCornerView" key="NSCornerView" id="360324124">
-																	<reference key="NSNextResponder" ref="440720679"/>
+																<object class="_NSCornerView" key="NSCornerView">
+																	<nil key="NSNextResponder"/>
 																	<int key="NSvFlags">-2147483392</int>
 																	<string key="NSFrame">{{-22, 0}, {12, 17}}</string>
-																	<reference key="NSSuperview" ref="440720679"/>
 																</object>
 																<object class="NSMutableArray" key="NSTableColumns">
 																	<bool key="EncodedWithXMLCoder">YES</bool>
@@ -318,7 +351,7 @@
 																	</object>
 																</object>
 																<double key="NSRowHeight">12</double>
-																<int key="NSTvFlags">-692060160</int>
+																<int key="NSTvFlags">-155189248</int>
 																<reference key="NSDelegate"/>
 																<reference key="NSDataSource"/>
 																<int key="NSGridStyleMask">2</int>
@@ -327,10 +360,12 @@
 																<int key="NSDraggingSourceMaskForNonLocal">0</int>
 																<bool key="NSAllowsTypeSelect">YES</bool>
 																<int key="NSTableViewDraggingDestinationStyle">0</int>
+																<int key="NSTableViewGroupRowStyle">1</int>
 															</object>
 														</object>
 														<string key="NSFrame">{{1, 17}, {516, 140}}</string>
 														<reference key="NSSuperview" ref="440720679"/>
+														<reference key="NSWindow"/>
 														<reference key="NSNextKeyView" ref="313963250"/>
 														<reference key="NSDocView" ref="313963250"/>
 														<reference key="NSBGColor" ref="252569531"/>
@@ -341,6 +376,8 @@
 														<int key="NSvFlags">-2147483392</int>
 														<string key="NSFrame">{{494, 17}, {11, 80}}</string>
 														<reference key="NSSuperview" ref="440720679"/>
+														<reference key="NSWindow"/>
+														<reference key="NSNextKeyView" ref="258996751"/>
 														<int key="NSsFlags">256</int>
 														<reference key="NSTarget" ref="440720679"/>
 														<string key="NSAction">_doScroller:</string>
@@ -351,6 +388,8 @@
 														<int key="NSvFlags">-2147483392</int>
 														<string key="NSFrame">{{1, 97}, {505, 11}}</string>
 														<reference key="NSSuperview" ref="440720679"/>
+														<reference key="NSWindow"/>
+														<reference key="NSNextKeyView" ref="893552286"/>
 														<int key="NSsFlags">257</int>
 														<reference key="NSTarget" ref="440720679"/>
 														<string key="NSAction">_doScroller:</string>
@@ -365,22 +404,22 @@
 														</object>
 														<string key="NSFrame">{{1, 0}, {516, 17}}</string>
 														<reference key="NSSuperview" ref="440720679"/>
+														<reference key="NSWindow"/>
 														<reference key="NSNextKeyView" ref="1048519426"/>
 														<reference key="NSDocView" ref="1048519426"/>
 														<reference key="NSBGColor" ref="252569531"/>
 														<int key="NScvFlags">4</int>
 													</object>
-													<reference ref="360324124"/>
 												</object>
 												<string key="NSFrame">{{17, 199}, {518, 158}}</string>
 												<reference key="NSSuperview" ref="1020318718"/>
-												<reference key="NSNextKeyView" ref="457121079"/>
-												<int key="NSsFlags">562</int>
+												<reference key="NSWindow"/>
+												<reference key="NSNextKeyView" ref="214413149"/>
+												<int key="NSsFlags">133682</int>
 												<reference key="NSVScroller" ref="884311606"/>
 												<reference key="NSHScroller" ref="258996751"/>
 												<reference key="NSContentView" ref="457121079"/>
 												<reference key="NSHeaderClipView" ref="214413149"/>
-												<reference key="NSCornerView" ref="360324124"/>
 												<bytes key="NSScrollAmts">QSAAAEEgAABBYAAAQWAAAA</bytes>
 											</object>
 											<object class="NSButton" id="210387551">
@@ -388,6 +427,8 @@
 												<int key="NSvFlags">265</int>
 												<string key="NSFrame">{{329, 164}, {80, 28}}</string>
 												<reference key="NSSuperview" ref="1020318718"/>
+												<reference key="NSWindow"/>
+												<reference key="NSNextKeyView" ref="977607312"/>
 												<bool key="NSEnabled">YES</bool>
 												<object class="NSButtonCell" key="NSCell" id="327131725">
 													<int key="NSCellFlags">67239424</int>
@@ -411,6 +452,8 @@
 												<int key="NSvFlags">265</int>
 												<string key="NSFrame">{{407, 164}, {133, 28}}</string>
 												<reference key="NSSuperview" ref="1020318718"/>
+												<reference key="NSWindow"/>
+												<reference key="NSNextKeyView" ref="802059200"/>
 												<bool key="NSEnabled">YES</bool>
 												<object class="NSButtonCell" key="NSCell" id="73578210">
 													<int key="NSCellFlags">67239424</int>
@@ -434,6 +477,8 @@
 												<int key="NSvFlags">268</int>
 												<string key="NSFrame">{{14, 172}, {86, 18}}</string>
 												<reference key="NSSuperview" ref="1020318718"/>
+												<reference key="NSWindow"/>
+												<reference key="NSNextKeyView" ref="343070533"/>
 												<bool key="NSEnabled">YES</bool>
 												<object class="NSButtonCell" key="NSCell" id="428850916">
 													<int key="NSCellFlags">67239424</int>
@@ -458,7 +503,7 @@
 													<bool key="EncodedWithXMLCoder">YES</bool>
 													<object class="NSView" id="1000204505">
 														<reference key="NSNextResponder" ref="184192603"/>
-														<int key="NSvFlags">256</int>
+														<int key="NSvFlags">274</int>
 														<object class="NSMutableArray" key="NSSubviews">
 															<bool key="EncodedWithXMLCoder">YES</bool>
 															<object class="NSButton" id="478533800">
@@ -466,6 +511,8 @@
 																<int key="NSvFlags">268</int>
 																<string key="NSFrame">{{5, 32}, {75, 18}}</string>
 																<reference key="NSSuperview" ref="1000204505"/>
+																<reference key="NSWindow"/>
+																<reference key="NSNextKeyView" ref="541208829"/>
 																<bool key="NSEnabled">YES</bool>
 																<object class="NSButtonCell" key="NSCell" id="989004902">
 																	<int key="NSCellFlags">67239424</int>
@@ -488,6 +535,8 @@
 																<int key="NSvFlags">268</int>
 																<string key="NSFrame">{{5, 12}, {167, 18}}</string>
 																<reference key="NSSuperview" ref="1000204505"/>
+																<reference key="NSWindow"/>
+																<reference key="NSNextKeyView" ref="210387551"/>
 																<bool key="NSEnabled">YES</bool>
 																<object class="NSButtonCell" key="NSCell" id="95048095">
 																	<int key="NSCellFlags">67239424</int>
@@ -510,6 +559,8 @@
 																<int key="NSvFlags">268</int>
 																<string key="NSFrame">{{5, 52}, {170, 18}}</string>
 																<reference key="NSSuperview" ref="1000204505"/>
+																<reference key="NSWindow"/>
+																<reference key="NSNextKeyView" ref="478533800"/>
 																<bool key="NSEnabled">YES</bool>
 																<object class="NSButtonCell" key="NSCell" id="855912809">
 																	<int key="NSCellFlags">67239424</int>
@@ -530,10 +581,14 @@
 														</object>
 														<string key="NSFrame">{{1, 1}, {193, 78}}</string>
 														<reference key="NSSuperview" ref="184192603"/>
+														<reference key="NSWindow"/>
+														<reference key="NSNextKeyView" ref="239701474"/>
 													</object>
 												</object>
 												<string key="NSFrame">{{113, 97}, {195, 94}}</string>
 												<reference key="NSSuperview" ref="1020318718"/>
+												<reference key="NSWindow"/>
+												<reference key="NSNextKeyView" ref="1000204505"/>
 												<string key="NSOffsets">{0, 0}</string>
 												<object class="NSTextFieldCell" key="NSTitleCell">
 													<int key="NSCellFlags">67239424</int>
@@ -557,6 +612,8 @@
 												<int key="NSvFlags">268</int>
 												<string key="NSFrame">{{14, 152}, {96, 18}}</string>
 												<reference key="NSSuperview" ref="1020318718"/>
+												<reference key="NSWindow"/>
+												<reference key="NSNextKeyView" ref="184192603"/>
 												<bool key="NSEnabled">YES</bool>
 												<object class="NSButtonCell" key="NSCell" id="237101992">
 													<int key="NSCellFlags">67239424</int>
@@ -574,9 +631,21 @@
 													<int key="NSPeriodicInterval">25</int>
 												</object>
 											</object>
+											<object class="NSCustomView" id="802059200">
+												<reference key="NSNextResponder" ref="1020318718"/>
+												<int key="NSvFlags">268</int>
+												<string key="NSFrame">{{3, 3}, {400, 40}}</string>
+												<reference key="NSSuperview" ref="1020318718"/>
+												<reference key="NSWindow"/>
+												<reference key="NSNextKeyView"/>
+												<string key="NSReuseIdentifierKey">_NS:9</string>
+												<string key="NSClassName">SFAuthorizationView</string>
+											</object>
 										</object>
 										<string key="NSFrame">{{10, 25}, {552, 363}}</string>
 										<reference key="NSSuperview" ref="739317740"/>
+										<reference key="NSWindow"/>
+										<reference key="NSNextKeyView" ref="440720679"/>
 									</object>
 									<string key="NSLabel">Tokens</string>
 									<reference key="NSColor" ref="568311573"/>
@@ -632,7 +701,7 @@
 																	<string>AXDescription</string>
 																	<string>NSAccessibilityEncodedAttributesValueType</string>
 																</object>
-																<object class="NSMutableArray" key="dict.values">
+																<object class="NSArray" key="dict.values">
 																	<bool key="EncodedWithXMLCoder">YES</bool>
 																	<string>cancel</string>
 																	<integer value="1"/>
@@ -926,7 +995,7 @@
 																<reference key="NSBackgroundColor" ref="400556243"/>
 																<reference key="NSGridColor" ref="850792713"/>
 																<double key="NSRowHeight">15</double>
-																<int key="NSTvFlags">1522532352</int>
+																<int key="NSTvFlags">2059403264</int>
 																<reference key="NSDelegate"/>
 																<reference key="NSDataSource"/>
 																<int key="NSGridStyleMask">1</int>
@@ -935,6 +1004,7 @@
 																<int key="NSDraggingSourceMaskForNonLocal">0</int>
 																<bool key="NSAllowsTypeSelect">YES</bool>
 																<int key="NSTableViewDraggingDestinationStyle">0</int>
+																<int key="NSTableViewGroupRowStyle">1</int>
 															</object>
 														</object>
 														<string key="NSFrame">{{1, 17}, {516, 271}}</string>
@@ -984,12 +1054,11 @@
 												<string key="NSFrame">{{15, 41}, {518, 289}}</string>
 												<reference key="NSSuperview" ref="1069727156"/>
 												<reference key="NSNextKeyView" ref="259172039"/>
-												<int key="NSsFlags">562</int>
+												<int key="NSsFlags">133682</int>
 												<reference key="NSVScroller" ref="177605134"/>
 												<reference key="NSHScroller" ref="172641834"/>
 												<reference key="NSContentView" ref="259172039"/>
 												<reference key="NSHeaderClipView" ref="281754774"/>
-												<reference key="NSCornerView" ref="772760699"/>
 												<bytes key="NSScrollAmts">QSAAAEEgAABBiAAAQYgAAA</bytes>
 											</object>
 											<object class="NSTextField" id="747536303">
@@ -1032,7 +1101,7 @@
 													<bool key="EncodedWithXMLCoder">YES</bool>
 													<object class="NSView" id="1006532054">
 														<reference key="NSNextResponder" ref="1056952440"/>
-														<int key="NSvFlags">256</int>
+														<int key="NSvFlags">274</int>
 														<object class="NSMutableArray" key="NSSubviews">
 															<bool key="EncodedWithXMLCoder">YES</bool>
 															<object class="NSTextField" id="748314809">
@@ -1075,7 +1144,7 @@
 																				<string>numberStyle</string>
 																				<string>positiveFormat</string>
 																			</object>
-																			<object class="NSMutableArray" key="dict.values">
+																			<object class="NSArray" key="dict.values">
 																				<bool key="EncodedWithXMLCoder">YES</bool>
 																				<integer value="1"/>
 																				<integer value="1040"/>
@@ -1096,12 +1165,12 @@
 																		<nil key="NS.nil"/>
 																		<object class="NSAttributedString" key="NS.nan">
 																			<string key="NSString">NaN</string>
-																			<object class="NSDictionary" key="NSAttributes" id="383448102">
+																			<object class="NSDictionary" key="NSAttributes" id="571560357">
 																				<bool key="EncodedWithXMLCoder">YES</bool>
-																				<reference key="dict.sortedKeys" ref="0"/>
-																				<object class="NSMutableArray" key="dict.values">
+																				<object class="NSArray" key="dict.sortedKeys" id="0">
 																					<bool key="EncodedWithXMLCoder">YES</bool>
 																				</object>
+																				<reference key="dict.values" ref="0"/>
 																			</object>
 																		</object>
 																		<real value="1000" key="NS.min"/>
@@ -1159,7 +1228,7 @@
 																				<string>minimumIntegerDigits</string>
 																				<string>positiveFormat</string>
 																			</object>
-																			<object class="NSMutableArray" key="dict.values">
+																			<object class="NSArray" key="dict.values">
 																				<bool key="EncodedWithXMLCoder">YES</bool>
 																				<integer value="1"/>
 																				<integer value="1040"/>
@@ -1177,7 +1246,7 @@
 																		<nil key="NS.nil"/>
 																		<object class="NSAttributedString" key="NS.nan">
 																			<string key="NSString">NaN</string>
-																			<reference key="NSAttributes" ref="383448102"/>
+																			<reference key="NSAttributes" ref="571560357"/>
 																		</object>
 																		<real value="100" key="NS.min"/>
 																		<reference key="NS.max" ref="139642944"/>
@@ -1239,7 +1308,7 @@
 																				<string>minimumIntegerDigits</string>
 																				<string>positiveFormat</string>
 																			</object>
-																			<object class="NSMutableArray" key="dict.values">
+																			<object class="NSArray" key="dict.values">
 																				<bool key="EncodedWithXMLCoder">YES</bool>
 																				<integer value="1"/>
 																				<integer value="1040"/>
@@ -1258,7 +1327,7 @@
 																		<nil key="NS.nil"/>
 																		<object class="NSAttributedString" key="NS.nan">
 																			<string key="NSString">NaN</string>
-																			<reference key="NSAttributes" ref="383448102"/>
+																			<reference key="NSAttributes" ref="571560357"/>
 																		</object>
 																		<integer value="1" key="NS.min"/>
 																		<reference key="NS.max" ref="139642944"/>
@@ -1363,7 +1432,7 @@
 																				<string>numberStyle</string>
 																				<string>positiveFormat</string>
 																			</object>
-																			<object class="NSMutableArray" key="dict.values">
+																			<object class="NSArray" key="dict.values">
 																				<bool key="EncodedWithXMLCoder">YES</bool>
 																				<real value="0.0"/>
 																				<real value="0.0"/>
@@ -1387,7 +1456,7 @@
 																		<nil key="NS.nil"/>
 																		<object class="NSAttributedString" key="NS.nan">
 																			<string key="NSString">NaN</string>
-																			<reference key="NSAttributes" ref="383448102"/>
+																			<reference key="NSAttributes" ref="571560357"/>
 																		</object>
 																		<real value="10" key="NS.min"/>
 																		<reference key="NS.max" ref="139642944"/>
@@ -1482,7 +1551,7 @@
 																				<string>numberStyle</string>
 																				<string>positiveFormat</string>
 																			</object>
-																			<object class="NSMutableArray" key="dict.values">
+																			<object class="NSArray" key="dict.values">
 																				<bool key="EncodedWithXMLCoder">YES</bool>
 																				<integer value="1"/>
 																				<integer value="1040"/>
@@ -1501,7 +1570,7 @@
 																		<nil key="NS.nil"/>
 																		<object class="NSAttributedString" key="NS.nan">
 																			<string key="NSString">NaN</string>
-																			<reference key="NSAttributes" ref="383448102"/>
+																			<reference key="NSAttributes" ref="571560357"/>
 																		</object>
 																		<real value="10000" key="NS.min"/>
 																		<reference key="NS.max" ref="139642944"/>
@@ -1766,7 +1835,7 @@
 																<reference key="NSBackgroundColor" ref="400556243"/>
 																<reference key="NSGridColor" ref="850792713"/>
 																<double key="NSRowHeight">17</double>
-																<int key="NSTvFlags">-557842432</int>
+																<int key="NSTvFlags">-20971520</int>
 																<reference key="NSDelegate"/>
 																<reference key="NSDataSource"/>
 																<int key="NSGridStyleMask">2</int>
@@ -1775,6 +1844,7 @@
 																<int key="NSDraggingSourceMaskForNonLocal">0</int>
 																<bool key="NSAllowsTypeSelect">YES</bool>
 																<int key="NSTableViewDraggingDestinationStyle">0</int>
+																<int key="NSTableViewGroupRowStyle">1</int>
 															</object>
 														</object>
 														<string key="NSFrame">{{1, 17}, {501, 283}}</string>
@@ -1823,7 +1893,7 @@
 												<string key="NSFrame">{{17, 41}, {518, 316}}</string>
 												<reference key="NSSuperview" ref="786994103"/>
 												<reference key="NSNextKeyView" ref="229139620"/>
-												<int key="NSsFlags">50</int>
+												<int key="NSsFlags">133170</int>
 												<reference key="NSVScroller" ref="497462431"/>
 												<reference key="NSHScroller" ref="145484441"/>
 												<reference key="NSContentView" ref="229139620"/>
@@ -1913,7 +1983,7 @@
 													<bool key="EncodedWithXMLCoder">YES</bool>
 													<object class="NSView" id="660074200">
 														<reference key="NSNextResponder" ref="731215349"/>
-														<int key="NSvFlags">256</int>
+														<int key="NSvFlags">274</int>
 														<object class="NSMutableArray" key="NSSubviews">
 															<bool key="EncodedWithXMLCoder">YES</bool>
 															<object class="NSTextField" id="628152029">
@@ -1965,7 +2035,7 @@
 																				<string>numberStyle</string>
 																				<string>positiveInfinitySymbol</string>
 																			</object>
-																			<object class="NSMutableArray" key="dict.values">
+																			<object class="NSArray" key="dict.values">
 																				<bool key="EncodedWithXMLCoder">YES</bool>
 																				<boolean value="YES"/>
 																				<integer value="1040"/>
@@ -1990,7 +2060,7 @@
 																		</object>
 																		<object class="NSAttributedString" key="NS.nan">
 																			<string key="NSString">NaN</string>
-																			<reference key="NSAttributes" ref="383448102"/>
+																			<reference key="NSAttributes" ref="571560357"/>
 																		</object>
 																		<real value="60" key="NS.min"/>
 																		<reference key="NS.max" ref="139642944"/>
@@ -2057,7 +2127,7 @@
 																				<string>numberStyle</string>
 																				<string>positiveInfinitySymbol</string>
 																			</object>
-																			<object class="NSMutableArray" key="dict.values">
+																			<object class="NSArray" key="dict.values">
 																				<bool key="EncodedWithXMLCoder">YES</bool>
 																				<boolean value="YES"/>
 																				<integer value="1040"/>
@@ -2082,7 +2152,7 @@
 																		</object>
 																		<object class="NSAttributedString" key="NS.nan">
 																			<string key="NSString">NaN</string>
-																			<reference key="NSAttributes" ref="383448102"/>
+																			<reference key="NSAttributes" ref="571560357"/>
 																		</object>
 																		<real value="60" key="NS.min"/>
 																		<reference key="NS.max" ref="139642944"/>
@@ -2183,7 +2253,7 @@
 																				<string>numberStyle</string>
 																				<string>positiveInfinitySymbol</string>
 																			</object>
-																			<object class="NSMutableArray" key="dict.values">
+																			<object class="NSArray" key="dict.values">
 																				<bool key="EncodedWithXMLCoder">YES</bool>
 																				<boolean value="YES"/>
 																				<integer value="1040"/>
@@ -2206,7 +2276,7 @@
 																		</object>
 																		<object class="NSAttributedString" key="NS.nan">
 																			<string key="NSString">NaN</string>
-																			<reference key="NSAttributes" ref="383448102"/>
+																			<reference key="NSAttributes" ref="571560357"/>
 																		</object>
 																		<real value="0.0" key="NS.min"/>
 																		<real value="30" key="NS.max"/>
@@ -2269,7 +2339,7 @@
 																				<string>numberStyle</string>
 																				<string>positiveInfinitySymbol</string>
 																			</object>
-																			<object class="NSMutableArray" key="dict.values">
+																			<object class="NSArray" key="dict.values">
 																				<bool key="EncodedWithXMLCoder">YES</bool>
 																				<boolean value="YES"/>
 																				<integer value="1040"/>
@@ -2292,7 +2362,7 @@
 																		</object>
 																		<object class="NSAttributedString" key="NS.nan">
 																			<string key="NSString">NaN</string>
-																			<reference key="NSAttributes" ref="383448102"/>
+																			<reference key="NSAttributes" ref="571560357"/>
 																		</object>
 																		<real value="0.0" key="NS.min"/>
 																		<real value="24" key="NS.max"/>
@@ -2355,7 +2425,7 @@
 																				<string>numberStyle</string>
 																				<string>positiveInfinitySymbol</string>
 																			</object>
-																			<object class="NSMutableArray" key="dict.values">
+																			<object class="NSArray" key="dict.values">
 																				<bool key="EncodedWithXMLCoder">YES</bool>
 																				<boolean value="YES"/>
 																				<integer value="1040"/>
@@ -2378,7 +2448,7 @@
 																		</object>
 																		<object class="NSAttributedString" key="NS.nan">
 																			<string key="NSString">NaN</string>
-																			<reference key="NSAttributes" ref="383448102"/>
+																			<reference key="NSAttributes" ref="571560357"/>
 																		</object>
 																		<real value="0.0" key="NS.min"/>
 																		<real value="60" key="NS.max"/>
@@ -2473,7 +2543,7 @@
 																				<string>numberStyle</string>
 																				<string>positiveInfinitySymbol</string>
 																			</object>
-																			<object class="NSMutableArray" key="dict.values">
+																			<object class="NSArray" key="dict.values">
 																				<bool key="EncodedWithXMLCoder">YES</bool>
 																				<boolean value="YES"/>
 																				<integer value="1040"/>
@@ -2496,7 +2566,7 @@
 																		</object>
 																		<object class="NSAttributedString" key="NS.nan">
 																			<string key="NSString">NaN</string>
-																			<reference key="NSAttributes" ref="383448102"/>
+																			<reference key="NSAttributes" ref="571560357"/>
 																		</object>
 																		<real value="0.0" key="NS.min"/>
 																		<real value="60" key="NS.max"/>
@@ -2582,6 +2652,8 @@
 							<int key="NSvFlags">289</int>
 							<string key="NSFrame">{{323, 3}, {258, 11}}</string>
 							<reference key="NSSuperview" ref="645279396"/>
+							<reference key="NSWindow"/>
+							<reference key="NSNextKeyView"/>
 							<bool key="NSEnabled">YES</bool>
 							<object class="NSTextFieldCell" key="NSCell" id="999146642">
 								<int key="NSCellFlags">68288064</int>
@@ -2600,9 +2672,12 @@
 					</object>
 					<string key="NSFrameSize">{595, 486}</string>
 					<reference key="NSSuperview"/>
+					<reference key="NSWindow"/>
+					<reference key="NSNextKeyView" ref="748501112"/>
 				</object>
-				<string key="NSScreenRect">{{0, 0}, {1920, 1178}}</string>
-				<string key="NSMaxSize">{1.79769e+308, 1.79769e+308}</string>
+				<string key="NSScreenRect">{{0, 0}, {1680, 1028}}</string>
+				<string key="NSMaxSize">{10000000000000, 10000000000000}</string>
+				<bool key="NSWindowIsRestorable">YES</bool>
 			</object>
 			<object class="NSWindowTemplate" id="52789773">
 				<int key="NSWindowStyleMask">9</int>
@@ -2616,7 +2691,7 @@
 				<object class="NSMutableString" key="NSViewClass">
 					<characters key="NS.bytes">View</characters>
 				</object>
-				<string key="NSWindowContentMaxSize">{1.79769e+308, 1.79769e+308}</string>
+				<nil key="NSUserInterfaceItemIdentifier"/>
 				<object class="NSView" key="NSWindowView" id="1017822711">
 					<nil key="NSNextResponder"/>
 					<int key="NSvFlags">256</int>
@@ -2635,7 +2710,7 @@
 										<object class="NSTextView" id="297493656">
 											<reference key="NSNextResponder" ref="853671207"/>
 											<int key="NSvFlags">2322</int>
-											<string key="NSFrameSize">{662, 14}</string>
+											<string key="NSFrameSize">{673, 14}</string>
 											<reference key="NSSuperview" ref="853671207"/>
 											<object class="NSTextContainer" key="NSTextContainer" id="512204159">
 												<object class="NSLayoutManager" key="NSLayoutManager">
@@ -2653,11 +2728,11 @@
 													<nil key="NSDelegate"/>
 												</object>
 												<reference key="NSTextView" ref="297493656"/>
-												<double key="NSWidth">662</double>
+												<double key="NSWidth">673</double>
 												<int key="NSTCFlags">1</int>
 											</object>
 											<object class="NSTextViewSharedData" key="NSSharedData">
-												<int key="NSFlags">2913</int>
+												<int key="NSFlags">67111777</int>
 												<int key="NSTextCheckingTypes">0</int>
 												<nil key="NSMarkedAttributes"/>
 												<reference key="NSBackgroundColor" ref="400556243"/>
@@ -2668,7 +2743,7 @@
 														<string>NSBackgroundColor</string>
 														<string>NSColor</string>
 													</object>
-													<object class="NSMutableArray" key="dict.values">
+													<object class="NSArray" key="dict.values">
 														<bool key="EncodedWithXMLCoder">YES</bool>
 														<object class="NSColor">
 															<int key="NSColorSpace">6</int>
@@ -2692,7 +2767,7 @@
 														<string>NSColor</string>
 														<string>NSUnderline</string>
 													</object>
-													<object class="NSMutableArray" key="dict.values">
+													<object class="NSArray" key="dict.values">
 														<bool key="EncodedWithXMLCoder">YES</bool>
 														<object class="NSColor">
 															<int key="NSColorSpace">1</int>
@@ -2702,21 +2777,40 @@
 													</object>
 												</object>
 												<nil key="NSDefaultParagraphStyle"/>
+												<nil key="NSTextFinder"/>
+												<int key="NSPreferredTextFinderStyle">0</int>
 											</object>
 											<int key="NSTVFlags">6</int>
-											<string key="NSMaxSize">{1337, 1e+07}</string>
+											<string key="NSMaxSize">{1337, 10000000}</string>
 											<string key="NSMinize">{114, 0}</string>
 											<nil key="NSDelegate"/>
 										</object>
 									</object>
-									<string key="NSFrame">{{1, 1}, {662, 423}}</string>
+									<string key="NSFrame">{{1, 1}, {673, 423}}</string>
 									<reference key="NSSuperview" ref="935020490"/>
 									<reference key="NSNextKeyView" ref="297493656"/>
 									<reference key="NSDocView" ref="297493656"/>
 									<reference key="NSBGColor" ref="400556243"/>
 									<object class="NSCursor" key="NSCursor">
-										<string key="NSHotSpot">{4, -5}</string>
-										<int key="NSCursorType">1</int>
+										<string key="NSHotSpot">{4, 5}</string>
+										<object class="NSImage" key="NSImage">
+											<int key="NSImageFlags">79691776</int>
+											<object class="NSArray" key="NSReps">
+												<bool key="EncodedWithXMLCoder">YES</bool>
+												<object class="NSArray">
+													<bool key="EncodedWithXMLCoder">YES</bool>
+													<integer value="5"/>
+													<object class="NSURL">
+														<nil key="NS.base"/>
+														<string key="NS.relative">file://localhost/Applications/Xcode.app/Contents/SharedFrameworks/DVTKit.framework/Resources/DVTIbeamCursor.tiff</string>
+													</object>
+												</object>
+											</object>
+											<object class="NSColor" key="NSColor">
+												<int key="NSColorSpace">3</int>
+												<bytes key="NSWhite">MCAwAA</bytes>
+											</object>
+										</object>
 									</object>
 									<int key="NScvFlags">4</int>
 								</object>
@@ -2745,7 +2839,7 @@
 							<string key="NSFrame">{{20, 40}, {675, 425}}</string>
 							<reference key="NSSuperview" ref="1017822711"/>
 							<reference key="NSNextKeyView" ref="853671207"/>
-							<int key="NSsFlags">18</int>
+							<int key="NSsFlags">133138</int>
 							<reference key="NSVScroller" ref="11642274"/>
 							<reference key="NSHScroller" ref="574894181"/>
 							<reference key="NSContentView" ref="853671207"/>
@@ -2776,8 +2870,9 @@
 					</object>
 					<string key="NSFrameSize">{715, 485}</string>
 				</object>
-				<string key="NSScreenRect">{{0, 0}, {1920, 1178}}</string>
-				<string key="NSMaxSize">{1.79769e+308, 1.79769e+308}</string>
+				<string key="NSScreenRect">{{0, 0}, {1680, 1028}}</string>
+				<string key="NSMaxSize">{10000000000000, 10000000000000}</string>
+				<bool key="NSWindowIsRestorable">YES</bool>
 			</object>
 			<object class="NSCustomObject" id="176554930">
 				<string key="NSClassName">InfoController</string>
@@ -2876,30 +2971,6 @@
 				</object>
 				<object class="IBConnectionRecord">
 					<object class="IBOutletConnection" key="connection">
-						<string key="label">infoPanel</string>
-						<reference key="source" ref="176554930"/>
-						<reference key="destination" ref="52789773"/>
-					</object>
-					<int key="connectionID">226</int>
-				</object>
-				<object class="IBConnectionRecord">
-					<object class="IBOutletConnection" key="connection">
-						<string key="label">texEditInfo</string>
-						<reference key="source" ref="176554930"/>
-						<reference key="destination" ref="297493656"/>
-					</object>
-					<int key="connectionID">227</int>
-				</object>
-				<object class="IBConnectionRecord">
-					<object class="IBActionConnection" key="connection">
-						<string key="label">closePanel:</string>
-						<reference key="source" ref="176554930"/>
-						<reference key="destination" ref="729692979"/>
-					</object>
-					<int key="connectionID">228</int>
-				</object>
-				<object class="IBConnectionRecord">
-					<object class="IBOutletConnection" key="connection">
 						<string key="label">afsCommanderView</string>
 						<reference key="source" ref="773588579"/>
 						<reference key="destination" ref="645279396"/>
@@ -2972,14 +3043,6 @@
 				</object>
 				<object class="IBConnectionRecord">
 					<object class="IBOutletConnection" key="connection">
-						<string key="label">delegate</string>
-						<reference key="source" ref="739317740"/>
-						<reference key="destination" ref="773588579"/>
-					</object>
-					<int key="connectionID">669</int>
-				</object>
-				<object class="IBConnectionRecord">
-					<object class="IBOutletConnection" key="connection">
 						<string key="label">textSearchField</string>
 						<reference key="source" ref="773588579"/>
 						<reference key="destination" ref="530233415"/>
@@ -2995,14 +3058,6 @@
 					<int key="connectionID">817</int>
 				</object>
 				<object class="IBConnectionRecord">
-					<object class="IBOutletConnection" key="connection">
-						<string key="label">delegate</string>
-						<reference key="source" ref="530233415"/>
-						<reference key="destination" ref="773588579"/>
-					</object>
-					<int key="connectionID">886</int>
-				</object>
-				<object class="IBConnectionRecord">
 					<object class="IBActionConnection" key="connection">
 						<string key="label">startStopAfs:</string>
 						<reference key="source" ref="773588579"/>
@@ -3252,22 +3307,6 @@
 				</object>
 				<object class="IBConnectionRecord">
 					<object class="IBOutletConnection" key="connection">
-						<string key="label">dataSource</string>
-						<reference key="source" ref="1029505942"/>
-						<reference key="destination" ref="773588579"/>
-					</object>
-					<int key="connectionID">2060</int>
-				</object>
-				<object class="IBConnectionRecord">
-					<object class="IBOutletConnection" key="connection">
-						<string key="label">delegate</string>
-						<reference key="source" ref="1029505942"/>
-						<reference key="destination" ref="773588579"/>
-					</object>
-					<int key="connectionID">2061</int>
-				</object>
-				<object class="IBConnectionRecord">
-					<object class="IBOutletConnection" key="connection">
 						<string key="label">buttonRemoveLink</string>
 						<reference key="source" ref="773588579"/>
 						<reference key="destination" ref="635503948"/>
@@ -3323,70 +3362,6 @@
 					<int key="connectionID">2093</int>
 				</object>
 				<object class="IBConnectionRecord">
-					<object class="IBActionConnection" key="connection">
-						<string key="label">takeIntegerValueFrom:</string>
-						<reference key="source" ref="724013147"/>
-						<reference key="destination" ref="719182296"/>
-					</object>
-					<int key="connectionID">2104</int>
-				</object>
-				<object class="IBConnectionRecord">
-					<object class="IBActionConnection" key="connection">
-						<string key="label">takeIntegerValueFrom:</string>
-						<reference key="source" ref="791385502"/>
-						<reference key="destination" ref="338319881"/>
-					</object>
-					<int key="connectionID">2114</int>
-				</object>
-				<object class="IBConnectionRecord">
-					<object class="IBActionConnection" key="connection">
-						<string key="label">takeIntegerValueFrom:</string>
-						<reference key="source" ref="826525177"/>
-						<reference key="destination" ref="564887063"/>
-					</object>
-					<int key="connectionID">2120</int>
-				</object>
-				<object class="IBConnectionRecord">
-					<object class="IBActionConnection" key="connection">
-						<string key="label">takeIntegerValueFrom:</string>
-						<reference key="source" ref="338319881"/>
-						<reference key="destination" ref="791385502"/>
-					</object>
-					<int key="connectionID">2127</int>
-				</object>
-				<object class="IBConnectionRecord">
-					<object class="IBActionConnection" key="connection">
-						<string key="label">takeIntValueFrom:</string>
-						<reference key="source" ref="719182296"/>
-						<reference key="destination" ref="724013147"/>
-					</object>
-					<int key="connectionID">2128</int>
-				</object>
-				<object class="IBConnectionRecord">
-					<object class="IBActionConnection" key="connection">
-						<string key="label">takeIntValueFrom:</string>
-						<reference key="source" ref="564887063"/>
-						<reference key="destination" ref="826525177"/>
-					</object>
-					<int key="connectionID">2129</int>
-				</object>
-				<object class="IBConnectionRecord">
-					<object class="IBActionConnection" key="connection">
-						<string key="label">takeIntegerValueFrom:</string>
-						<reference key="source" ref="681255345"/>
-						<reference key="destination" ref="724827539"/>
-					</object>
-					<int key="connectionID">2140</int>
-				</object>
-				<object class="IBConnectionRecord">
-					<object class="IBActionConnection" key="connection">
-						<string key="label">takeIntValueFrom:</string>
-						<reference key="source" ref="724827539"/>
-						<reference key="destination" ref="681255345"/>
-					</object>
-					<int key="connectionID">2141</int>
-				</object>
-				<object class="IBConnectionRecord">
 					<object class="IBOutletConnection" key="connection">
 						<string key="label">nsTextFieldKrb5RenewTimeD</string>
 						<reference key="source" ref="773588579"/>
@@ -3450,80 +3425,208 @@
 					</object>
 					<int key="connectionID">2149</int>
 				</object>
-			</object>
-			<object class="IBMutableOrderedSet" key="objectRecords">
-				<object class="NSArray" key="orderedObjects">
-					<bool key="EncodedWithXMLCoder">YES</bool>
-					<object class="IBObjectRecord">
-						<int key="objectID">0</int>
-						<reference key="object" ref="0"/>
-						<reference key="children" ref="84888716"/>
-						<nil key="parent"/>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">authView</string>
+						<reference key="source" ref="773588579"/>
+						<reference key="destination" ref="802059200"/>
 					</object>
-					<object class="IBObjectRecord">
-						<int key="objectID">-2</int>
-						<reference key="object" ref="773588579"/>
-						<reference key="parent" ref="0"/>
-						<string key="objectName">File's Owner</string>
+					<int key="connectionID">2151</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">delegate</string>
+						<reference key="source" ref="739317740"/>
+						<reference key="destination" ref="773588579"/>
 					</object>
-					<object class="IBObjectRecord">
-						<int key="objectID">-1</int>
-						<reference key="object" ref="270520968"/>
-						<reference key="parent" ref="0"/>
-						<string key="objectName">First Responder</string>
+					<int key="connectionID">669</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">delegate</string>
+						<reference key="source" ref="530233415"/>
+						<reference key="destination" ref="773588579"/>
 					</object>
-					<object class="IBObjectRecord">
-						<int key="objectID">-3</int>
-						<reference key="object" ref="173116405"/>
-						<reference key="parent" ref="0"/>
-						<string key="objectName">Application</string>
+					<int key="connectionID">886</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">infoPanel</string>
+						<reference key="source" ref="176554930"/>
+						<reference key="destination" ref="52789773"/>
 					</object>
-					<object class="IBObjectRecord">
-						<int key="objectID">12</int>
-						<reference key="object" ref="61231707"/>
-						<object class="NSMutableArray" key="children">
-							<bool key="EncodedWithXMLCoder">YES</bool>
-							<reference ref="645279396"/>
-						</object>
-						<reference key="parent" ref="0"/>
-						<string key="objectName">PrefPane</string>
+					<int key="connectionID">226</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">texEditInfo</string>
+						<reference key="source" ref="176554930"/>
+						<reference key="destination" ref="297493656"/>
 					</object>
-					<object class="IBObjectRecord">
-						<int key="objectID">6</int>
-						<reference key="object" ref="645279396"/>
-						<object class="NSMutableArray" key="children">
-							<bool key="EncodedWithXMLCoder">YES</bool>
-							<reference ref="1047946385"/>
-							<reference ref="415603882"/>
-							<reference ref="739317740"/>
-							<reference ref="748501112"/>
-						</object>
-						<reference key="parent" ref="61231707"/>
+					<int key="connectionID">227</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">closePanel:</string>
+						<reference key="source" ref="176554930"/>
+						<reference key="destination" ref="729692979"/>
 					</object>
-					<object class="IBObjectRecord">
-						<int key="objectID">101</int>
-						<reference key="object" ref="739317740"/>
-						<object class="NSMutableArray" key="children">
-							<bool key="EncodedWithXMLCoder">YES</bool>
-							<reference ref="269508902"/>
-							<reference ref="443722606"/>
-							<reference ref="584361947"/>
-							<reference ref="126070858"/>
-							<reference ref="585584503"/>
-						</object>
-						<reference key="parent" ref="645279396"/>
+					<int key="connectionID">228</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">dataSource</string>
+						<reference key="source" ref="1029505942"/>
+						<reference key="destination" ref="773588579"/>
 					</object>
-					<object class="IBObjectRecord">
-						<int key="objectID">104</int>
-						<reference key="object" ref="269508902"/>
-						<object class="NSMutableArray" key="children">
-							<bool key="EncodedWithXMLCoder">YES</bool>
-							<reference ref="1020318718"/>
-						</object>
-						<reference key="parent" ref="739317740"/>
+					<int key="connectionID">2060</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBOutletConnection" key="connection">
+						<string key="label">delegate</string>
+						<reference key="source" ref="1029505942"/>
+						<reference key="destination" ref="773588579"/>
 					</object>
-					<object class="IBObjectRecord">
-						<int key="objectID">105</int>
+					<int key="connectionID">2061</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">takeIntValueFrom:</string>
+						<reference key="source" ref="719182296"/>
+						<reference key="destination" ref="724013147"/>
+					</object>
+					<int key="connectionID">2128</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">takeIntegerValueFrom:</string>
+						<reference key="source" ref="724013147"/>
+						<reference key="destination" ref="719182296"/>
+					</object>
+					<int key="connectionID">2104</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">takeIntegerValueFrom:</string>
+						<reference key="source" ref="338319881"/>
+						<reference key="destination" ref="791385502"/>
+					</object>
+					<int key="connectionID">2127</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">takeIntegerValueFrom:</string>
+						<reference key="source" ref="791385502"/>
+						<reference key="destination" ref="338319881"/>
+					</object>
+					<int key="connectionID">2114</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">takeIntValueFrom:</string>
+						<reference key="source" ref="564887063"/>
+						<reference key="destination" ref="826525177"/>
+					</object>
+					<int key="connectionID">2129</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">takeIntegerValueFrom:</string>
+						<reference key="source" ref="826525177"/>
+						<reference key="destination" ref="564887063"/>
+					</object>
+					<int key="connectionID">2120</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">takeIntValueFrom:</string>
+						<reference key="source" ref="724827539"/>
+						<reference key="destination" ref="681255345"/>
+					</object>
+					<int key="connectionID">2141</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">takeIntegerValueFrom:</string>
+						<reference key="source" ref="681255345"/>
+						<reference key="destination" ref="724827539"/>
+					</object>
+					<int key="connectionID">2140</int>
+				</object>
+			</object>
+			<object class="IBMutableOrderedSet" key="objectRecords">
+				<object class="NSArray" key="orderedObjects">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<object class="IBObjectRecord">
+						<int key="objectID">0</int>
+						<reference key="object" ref="0"/>
+						<reference key="children" ref="84888716"/>
+						<nil key="parent"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">-2</int>
+						<reference key="object" ref="773588579"/>
+						<reference key="parent" ref="0"/>
+						<string key="objectName">File's Owner</string>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">-1</int>
+						<reference key="object" ref="270520968"/>
+						<reference key="parent" ref="0"/>
+						<string key="objectName">First Responder</string>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">-3</int>
+						<reference key="object" ref="173116405"/>
+						<reference key="parent" ref="0"/>
+						<string key="objectName">Application</string>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">12</int>
+						<reference key="object" ref="61231707"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="645279396"/>
+						</object>
+						<reference key="parent" ref="0"/>
+						<string key="objectName">PrefPane</string>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">6</int>
+						<reference key="object" ref="645279396"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="1047946385"/>
+							<reference ref="415603882"/>
+							<reference ref="739317740"/>
+							<reference ref="748501112"/>
+						</object>
+						<reference key="parent" ref="61231707"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">101</int>
+						<reference key="object" ref="739317740"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="269508902"/>
+							<reference ref="443722606"/>
+							<reference ref="584361947"/>
+							<reference ref="126070858"/>
+							<reference ref="585584503"/>
+						</object>
+						<reference key="parent" ref="645279396"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">104</int>
+						<reference key="object" ref="269508902"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="1020318718"/>
+						</object>
+						<reference key="parent" ref="739317740"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">105</int>
 						<reference key="object" ref="1020318718"/>
 						<object class="NSMutableArray" key="children">
 							<bool key="EncodedWithXMLCoder">YES</bool>
@@ -3533,6 +3636,7 @@
 							<reference ref="893552286"/>
 							<reference ref="343070533"/>
 							<reference ref="210387551"/>
+							<reference ref="802059200"/>
 						</object>
 						<reference key="parent" ref="269508902"/>
 					</object>
@@ -4864,86 +4968,54 @@
 						<reference key="object" ref="426972560"/>
 						<reference key="parent" ref="724827539"/>
 					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">2150</int>
+						<reference key="object" ref="802059200"/>
+						<reference key="parent" ref="1020318718"/>
+					</object>
 				</object>
 			</object>
 			<object class="NSMutableDictionary" key="flattenedProperties">
 				<bool key="EncodedWithXMLCoder">YES</bool>
 				<object class="NSArray" key="dict.sortedKeys">
 					<bool key="EncodedWithXMLCoder">YES</bool>
+					<string>-1.IBPluginDependency</string>
+					<string>-2.IBPluginDependency</string>
 					<string>-3.IBPluginDependency</string>
-					<string>-3.ImportedFromIB2</string>
 					<string>101.IBPluginDependency</string>
-					<string>101.ImportedFromIB2</string>
 					<string>104.IBPluginDependency</string>
-					<string>104.ImportedFromIB2</string>
 					<string>105.IBPluginDependency</string>
-					<string>105.ImportedFromIB2</string>
 					<string>1103.IBPluginDependency</string>
-					<string>1103.ImportedFromIB2</string>
 					<string>1107.IBPluginDependency</string>
-					<string>1107.ImportedFromIB2</string>
 					<string>1111.IBPluginDependency</string>
-					<string>1111.ImportedFromIB2</string>
 					<string>1122.IBPluginDependency</string>
-					<string>1122.ImportedFromIB2</string>
 					<string>1199.IBPluginDependency</string>
-					<string>1199.ImportedFromIB2</string>
-					<string>12.IBEditorWindowLastContentRect</string>
 					<string>12.IBPluginDependency</string>
-					<string>12.IBViewEditorWindowController.showingBoundsRectangles</string>
-					<string>12.IBViewEditorWindowController.showingLayoutRectangles</string>
 					<string>12.IBWindowTemplateEditedContentRect</string>
-					<string>12.ImportedFromIB2</string>
-					<string>12.windowTemplate.hasMinSize</string>
-					<string>12.windowTemplate.maxSize</string>
-					<string>12.windowTemplate.minSize</string>
 					<string>1203.IBPluginDependency</string>
-					<string>1203.ImportedFromIB2</string>
 					<string>1204.IBPluginDependency</string>
-					<string>1204.ImportedFromIB2</string>
 					<string>1207.IBPluginDependency</string>
-					<string>1207.ImportedFromIB2</string>
 					<string>1209.IBPluginDependency</string>
-					<string>1209.ImportedFromIB2</string>
 					<string>1280.IBPluginDependency</string>
-					<string>1280.ImportedFromIB2</string>
 					<string>1422.IBPluginDependency</string>
-					<string>1422.ImportedFromIB2</string>
 					<string>1426.IBPluginDependency</string>
-					<string>1426.ImportedFromIB2</string>
 					<string>1715.IBPluginDependency</string>
-					<string>1715.ImportedFromIB2</string>
 					<string>177.IBPluginDependency</string>
-					<string>177.ImportedFromIB2</string>
 					<string>178.IBPluginDependency</string>
-					<string>178.ImportedFromIB2</string>
 					<string>1787.IBPluginDependency</string>
-					<string>1787.ImportedFromIB2</string>
 					<string>1789.IBPluginDependency</string>
-					<string>1789.ImportedFromIB2</string>
 					<string>179.IBPluginDependency</string>
-					<string>179.ImportedFromIB2</string>
 					<string>180.IBPluginDependency</string>
-					<string>180.ImportedFromIB2</string>
 					<string>181.IBPluginDependency</string>
-					<string>181.ImportedFromIB2</string>
 					<string>182.IBPluginDependency</string>
-					<string>182.ImportedFromIB2</string>
 					<string>183.IBPluginDependency</string>
-					<string>183.ImportedFromIB2</string>
 					<string>184.IBPluginDependency</string>
-					<string>184.ImportedFromIB2</string>
 					<string>1845.IBPluginDependency</string>
-					<string>1845.ImportedFromIB2</string>
 					<string>185.IBPluginDependency</string>
-					<string>185.ImportedFromIB2</string>
 					<string>186.IBPluginDependency</string>
-					<string>186.ImportedFromIB2</string>
 					<string>1902.IBPluginDependency</string>
-					<string>1902.ImportedFromIB2</string>
 					<string>1960.IBAttributePlaceholdersKey</string>
 					<string>1960.IBPluginDependency</string>
-					<string>1960.ImportedFromIB2</string>
 					<string>1964.IBPluginDependency</string>
 					<string>1965.IBPluginDependency</string>
 					<string>1966.IBPluginDependency</string>
@@ -4980,7 +5052,6 @@
 					<string>1998.IBPluginDependency</string>
 					<string>1999.IBPluginDependency</string>
 					<string>200.IBPluginDependency</string>
-					<string>200.ImportedFromIB2</string>
 					<string>2000.IBPluginDependency</string>
 					<string>2000.IBShouldRemoveOnLegacySave</string>
 					<string>2001.IBPluginDependency</string>
@@ -5034,7 +5105,6 @@
 					<string>2066.IBPluginDependency</string>
 					<string>2067.IBPluginDependency</string>
 					<string>207.IBPluginDependency</string>
-					<string>207.ImportedFromIB2</string>
 					<string>2071.IBPluginDependency</string>
 					<string>2072.IBPluginDependency</string>
 					<string>2073.IBAttributePlaceholdersKey</string>
@@ -5048,13 +5118,8 @@
 					<string>2077.IBPluginDependency</string>
 					<string>2078.IBPluginDependency</string>
 					<string>2079.IBPluginDependency</string>
-					<string>208.IBEditorWindowLastContentRect</string>
 					<string>208.IBPluginDependency</string>
 					<string>208.IBWindowTemplateEditedContentRect</string>
-					<string>208.ImportedFromIB2</string>
-					<string>208.windowTemplate.hasMinSize</string>
-					<string>208.windowTemplate.maxSize</string>
-					<string>208.windowTemplate.minSize</string>
 					<string>2080.IBNumberFormatterBehaviorMetadataKey</string>
 					<string>2080.IBNumberFormatterLocalizesFormatMetadataKey</string>
 					<string>2080.IBPluginDependency</string>
@@ -5063,7 +5128,6 @@
 					<string>2087.IBPluginDependency</string>
 					<string>2088.IBPluginDependency</string>
 					<string>209.IBPluginDependency</string>
-					<string>209.ImportedFromIB2</string>
 					<string>2100.IBPluginDependency</string>
 					<string>2101.IBPluginDependency</string>
 					<string>2102.IBAttributePlaceholdersKey</string>
@@ -5103,148 +5167,84 @@
 					<string>2138.IBPluginDependency</string>
 					<string>2139.IBPluginDependency</string>
 					<string>214.IBPluginDependency</string>
-					<string>214.ImportedFromIB2</string>
 					<string>215.IBPluginDependency</string>
-					<string>215.ImportedFromIB2</string>
+					<string>2150.IBPluginDependency</string>
 					<string>216.IBPluginDependency</string>
-					<string>216.ImportedFromIB2</string>
-					<string>224.ImportedFromIB2</string>
+					<string>224.IBPluginDependency</string>
 					<string>265.IBPluginDependency</string>
-					<string>265.ImportedFromIB2</string>
 					<string>337.IBPluginDependency</string>
-					<string>337.ImportedFromIB2</string>
 					<string>338.IBPluginDependency</string>
-					<string>338.ImportedFromIB2</string>
 					<string>339.IBPluginDependency</string>
-					<string>339.ImportedFromIB2</string>
 					<string>340.IBPluginDependency</string>
-					<string>340.ImportedFromIB2</string>
 					<string>342.IBPluginDependency</string>
-					<string>342.ImportedFromIB2</string>
 					<string>344.IBAttributePlaceholdersKey</string>
 					<string>344.IBPluginDependency</string>
-					<string>344.ImportedFromIB2</string>
 					<string>345.IBPluginDependency</string>
-					<string>345.ImportedFromIB2</string>
 					<string>348.IBAttributePlaceholdersKey</string>
 					<string>348.IBPluginDependency</string>
-					<string>348.ImportedFromIB2</string>
 					<string>349.IBPluginDependency</string>
-					<string>349.ImportedFromIB2</string>
 					<string>352.IBPluginDependency</string>
-					<string>352.ImportedFromIB2</string>
 					<string>400.IBPluginDependency</string>
-					<string>400.ImportedFromIB2</string>
 					<string>402.IBPluginDependency</string>
-					<string>402.ImportedFromIB2</string>
 					<string>404.IBAttributePlaceholdersKey</string>
 					<string>404.IBPluginDependency</string>
-					<string>404.ImportedFromIB2</string>
 					<string>406.IBPluginDependency</string>
-					<string>406.ImportedFromIB2</string>
 					<string>408.IBAttributePlaceholdersKey</string>
 					<string>408.IBPluginDependency</string>
-					<string>408.ImportedFromIB2</string>
 					<string>411.IBNumberFormatterLocalizesFormatMetadataKey</string>
 					<string>411.IBPluginDependency</string>
-					<string>411.ImportedFromIB2</string>
 					<string>413.IBPluginDependency</string>
-					<string>413.ImportedFromIB2</string>
 					<string>415.IBAttributePlaceholdersKey</string>
 					<string>415.IBPluginDependency</string>
-					<string>415.ImportedFromIB2</string>
 					<string>417.IBNumberFormatterLocalizesFormatMetadataKey</string>
 					<string>417.IBPluginDependency</string>
-					<string>417.ImportedFromIB2</string>
 					<string>425.IBPluginDependency</string>
-					<string>425.ImportedFromIB2</string>
 					<string>475.IBPluginDependency</string>
-					<string>475.ImportedFromIB2</string>
 					<string>6.IBPluginDependency</string>
-					<string>6.ImportedFromIB2</string>
 					<string>740.IBNumberFormatterLocalizesFormatMetadataKey</string>
 					<string>740.IBPluginDependency</string>
-					<string>740.ImportedFromIB2</string>
 					<string>741.IBNumberFormatterLocalizesFormatMetadataKey</string>
 					<string>741.IBPluginDependency</string>
-					<string>741.ImportedFromIB2</string>
 					<string>742.IBNumberFormatterLocalizesFormatMetadataKey</string>
 					<string>742.IBPluginDependency</string>
-					<string>742.ImportedFromIB2</string>
 				</object>
-				<object class="NSMutableArray" key="dict.values">
+				<object class="NSArray" key="dict.values">
 					<bool key="EncodedWithXMLCoder">YES</bool>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
-					<string>{{208, 366}, {595, 486}}</string>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<boolean value="NO"/>
-					<boolean value="NO"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
 					<string>{{208, 366}, {595, 486}}</string>
-					<integer value="1"/>
-					<boolean value="NO"/>
-					<string>{3.40282e+38, 3.40282e+38}</string>
-					<string>{0, 0}</string>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<object class="NSMutableDictionary">
 						<string key="NS.key.0">ToolTip</string>
 						<object class="IBToolTipAttribute" key="NS.object.0">
@@ -5254,7 +5254,6 @@
 						</object>
 					</object>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
@@ -5299,7 +5298,6 @@ Zm9yIGRlYnVnZ2luZyBhcyBpdCBwcmludHMgYSBMT1Qgb2YgaW5mb3JtYXRpb24uCg</string>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
 					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
@@ -5353,7 +5351,6 @@ Zm9yIGRlYnVnZ2luZyBhcyBpdCBwcmludHMgYSBMT1Qgb2YgaW5mb3JtYXRpb24uCg</string>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
 					<object class="NSMutableDictionary">
@@ -5381,13 +5378,8 @@ Zm9yIGRlYnVnZ2luZyBhcyBpdCBwcmludHMgYSBMT1Qgb2YgaW5mb3JtYXRpb24uCg</string>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<string>{{0, 510}, {715, 485}}</string>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
 					<string>{{0, 510}, {715, 485}}</string>
-					<integer value="1"/>
-					<boolean value="NO"/>
-					<string>{3.40282e+38, 3.40282e+38}</string>
-					<string>{0, 0}</string>
 					<integer value="1040"/>
 					<boolean value="YES"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
@@ -5403,7 +5395,6 @@ Zm9yIGRlYnVnZ2luZyBhcyBpdCBwcmludHMgYSBMT1Qgb2YgaW5mb3JtYXRpb24uCg</string>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
 					<object class="NSMutableDictionary">
@@ -5471,24 +5462,16 @@ Zm9yIGRlYnVnZ2luZyBhcyBpdCBwcmludHMgYSBMT1Qgb2YgaW5mb3JtYXRpb24uCg</string>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
 					<object class="NSMutableDictionary">
 						<string key="NS.key.0">ToolTip</string>
 						<object class="IBToolTipAttribute" key="NS.object.0">
@@ -5498,9 +5481,7 @@ Zm9yIGRlYnVnZ2luZyBhcyBpdCBwcmludHMgYSBMT1Qgb2YgaW5mb3JtYXRpb24uCg</string>
 						</object>
 					</object>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<object class="NSMutableDictionary">
 						<string key="NS.key.0">ToolTip</string>
 						<object class="IBToolTipAttribute" key="NS.object.0">
@@ -5510,15 +5491,10 @@ Zm9yIGRlYnVnZ2luZyBhcyBpdCBwcmludHMgYSBMT1Qgb2YgaW5mb3JtYXRpb24uCg</string>
 						</object>
 					</object>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<object class="NSMutableDictionary">
 						<string key="NS.key.0">ToolTip</string>
 						<object class="IBToolTipAttribute" key="NS.object.0">
@@ -5528,9 +5504,7 @@ Zm9yIGRlYnVnZ2luZyBhcyBpdCBwcmludHMgYSBMT1Qgb2YgaW5mb3JtYXRpb24uCg</string>
 						</object>
 					</object>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<object class="NSMutableDictionary">
 						<string key="NS.key.0">ToolTip</string>
 						<object class="IBToolTipAttribute" key="NS.object.0">
@@ -5540,12 +5514,9 @@ Zm9yIGRlYnVnZ2luZyBhcyBpdCBwcmludHMgYSBMT1Qgb2YgaW5mb3JtYXRpb24uCg</string>
 						</object>
 					</object>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<boolean value="YES"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<object class="NSMutableDictionary">
 						<string key="NS.key.0">ToolTip</string>
 						<object class="IBToolTipAttribute" key="NS.object.0">
@@ -5555,44 +5526,32 @@ Zm9yIGRlYnVnZ2luZyBhcyBpdCBwcmludHMgYSBMT1Qgb2YgaW5mb3JtYXRpb24uCg</string>
 						</object>
 					</object>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<boolean value="YES"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<boolean value="YES"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<boolean value="YES"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 					<boolean value="YES"/>
 					<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-					<integer value="1"/>
 				</object>
 			</object>
 			<object class="NSMutableDictionary" key="unlocalizedProperties">
 				<bool key="EncodedWithXMLCoder">YES</bool>
 				<reference key="dict.sortedKeys" ref="0"/>
-				<object class="NSMutableArray" key="dict.values">
-					<bool key="EncodedWithXMLCoder">YES</bool>
-				</object>
+				<reference key="dict.values" ref="0"/>
 			</object>
 			<nil key="activeLocalization"/>
 			<object class="NSMutableDictionary" key="localizations">
 				<bool key="EncodedWithXMLCoder">YES</bool>
 				<reference key="dict.sortedKeys" ref="0"/>
-				<object class="NSMutableArray" key="dict.values">
-					<bool key="EncodedWithXMLCoder">YES</bool>
-				</object>
+				<reference key="dict.values" ref="0"/>
 			</object>
 			<nil key="sourceID"/>
-			<int key="maxID">2149</int>
+			<int key="maxID">2151</int>
 		</object>
 		<object class="IBClassDescriber" key="IBDocument.Classes">
 			<object class="NSMutableArray" key="referencedPartialClassDescriptions">
@@ -5628,7 +5587,7 @@ Zm9yIGRlYnVnZ2luZyBhcyBpdCBwcmludHMgYSBMT1Qgb2YgaW5mb3JtYXRpb24uCg</string>
 							<string>tableViewLinkPerformClick:</string>
 							<string>unlog:</string>
 						</object>
-						<object class="NSMutableArray" key="dict.values">
+						<object class="NSArray" key="dict.values">
 							<bool key="EncodedWithXMLCoder">YES</bool>
 							<string>id</string>
 							<string>id</string>
@@ -5655,53 +5614,170 @@ Zm9yIGRlYnVnZ2luZyBhcyBpdCBwcmludHMgYSBMT1Qgb2YgaW5mb3JtYXRpb24uCg</string>
 							<string>id</string>
 						</object>
 					</object>
-					<object class="NSMutableDictionary" key="outlets">
+					<object class="NSMutableDictionary" key="actionInfosByName">
 						<bool key="EncodedWithXMLCoder">YES</bool>
 						<object class="NSArray" key="dict.sortedKeys">
 							<bool key="EncodedWithXMLCoder">YES</bool>
-							<string>addCellButton</string>
-							<string>afsCommanderView</string>
-							<string>afsDB</string>
-							<string>afsDefaultCellLabel</string>
-							<string>afsMenucheckBox</string>
-							<string>afsRootMountPoint</string>
-							<string>afsVersionLabel</string>
-							<string>aklogCredentialAtLoginTime</string>
-							<string>backgrounderActivationCheck</string>
-							<string>buttonAddLink</string>
-							<string>buttonRemoveLink</string>
-							<string>cacheDimension</string>
-							<string>cellIpButton</string>
-							<string>cellList</string>
-							<string>checkButtonAfsAtBootTime</string>
-							<string>checkEnableLink</string>
-							<string>credentialCommander</string>
-							<string>credentialSheet</string>
-							<string>dCacheDim</string>
-							<string>daemonNumber</string>
-							<string>dynRoot</string>
-							<string>groupsBox</string>
-							<string>infoController</string>
-							<string>infoSheet</string>
-							<string>installKRB5AuthAtLoginButton</string>
-							<string>ipConfControllerCommander</string>
-							<string>ipConfigurationSheet</string>
-							<string>labelSaveResult</string>
-							<string>lyncCreationSheet</string>
-							<string>lynkCreationController</string>
-							<string>nVolEntry</string>
-							<string>nsButtonEnableDisableKrb5RenewCheck</string>
-							<string>nsStepperKrb5RenewTimeD</string>
-							<string>nsStepperKrb5RenewTimeH</string>
-							<string>nsStepperKrb5RenewTimeM</string>
-							<string>nsStepperKrb5RenewTimeS</string>
-							<string>nsTextFieldKrb5RenewCheckIntervall</string>
-							<string>nsTextFieldKrb5RenewTimeD</string>
-							<string>nsTextFieldKrb5RenewTimeH</string>
-							<string>nsTextFieldKrb5RenewTimeM</string>
-							<string>nsTextFieldKrb5RenewTimeS</string>
-							<string>nsTextFieldKrb5SecToExpireDateForRenew</string>
-							<string>removeCellButton</string>
+							<string>addLink:</string>
+							<string>addRemoveCell:</string>
+							<string>afsMenuActivationEvent:</string>
+							<string>afsStartupSwitchEvent:</string>
+							<string>aklogSwitchEvent:</string>
+							<string>credentialAtLoginTimeEvent:</string>
+							<string>enableDisableKrb5RenewCheck:</string>
+							<string>enableLink:</string>
+							<string>getNewToken:</string>
+							<string>info:</string>
+							<string>krb5KredentialAtLoginTimeEvent:</string>
+							<string>krb5RenewParamChange:</string>
+							<string>manageBackgrounderActivation:</string>
+							<string>refreshConfiguration:</string>
+							<string>removeLink:</string>
+							<string>saveCacheManagerParam:</string>
+							<string>saveConfiguration:</string>
+							<string>searchCellTextEvent:</string>
+							<string>showCellIP:</string>
+							<string>startStopAfs:</string>
+							<string>tableDoubleAction:</string>
+							<string>tableViewLinkPerformClick:</string>
+							<string>unlog:</string>
+						</object>
+						<object class="NSArray" key="dict.values">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<object class="IBActionInfo">
+								<string key="name">addLink:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+							<object class="IBActionInfo">
+								<string key="name">addRemoveCell:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+							<object class="IBActionInfo">
+								<string key="name">afsMenuActivationEvent:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+							<object class="IBActionInfo">
+								<string key="name">afsStartupSwitchEvent:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+							<object class="IBActionInfo">
+								<string key="name">aklogSwitchEvent:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+							<object class="IBActionInfo">
+								<string key="name">credentialAtLoginTimeEvent:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+							<object class="IBActionInfo">
+								<string key="name">enableDisableKrb5RenewCheck:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+							<object class="IBActionInfo">
+								<string key="name">enableLink:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+							<object class="IBActionInfo">
+								<string key="name">getNewToken:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+							<object class="IBActionInfo">
+								<string key="name">info:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+							<object class="IBActionInfo">
+								<string key="name">krb5KredentialAtLoginTimeEvent:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+							<object class="IBActionInfo">
+								<string key="name">krb5RenewParamChange:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+							<object class="IBActionInfo">
+								<string key="name">manageBackgrounderActivation:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+							<object class="IBActionInfo">
+								<string key="name">refreshConfiguration:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+							<object class="IBActionInfo">
+								<string key="name">removeLink:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+							<object class="IBActionInfo">
+								<string key="name">saveCacheManagerParam:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+							<object class="IBActionInfo">
+								<string key="name">saveConfiguration:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+							<object class="IBActionInfo">
+								<string key="name">searchCellTextEvent:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+							<object class="IBActionInfo">
+								<string key="name">showCellIP:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+							<object class="IBActionInfo">
+								<string key="name">startStopAfs:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+							<object class="IBActionInfo">
+								<string key="name">tableDoubleAction:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+							<object class="IBActionInfo">
+								<string key="name">tableViewLinkPerformClick:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+							<object class="IBActionInfo">
+								<string key="name">unlog:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+						</object>
+					</object>
+					<object class="NSMutableDictionary" key="outlets">
+						<bool key="EncodedWithXMLCoder">YES</bool>
+						<object class="NSArray" key="dict.sortedKeys">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>addCellButton</string>
+							<string>afsCommanderView</string>
+							<string>afsDB</string>
+							<string>afsDefaultCellLabel</string>
+							<string>afsMenucheckBox</string>
+							<string>afsRootMountPoint</string>
+							<string>afsVersionLabel</string>
+							<string>aklogCredentialAtLoginTime</string>
+							<string>authView</string>
+							<string>backgrounderActivationCheck</string>
+							<string>buttonAddLink</string>
+							<string>buttonRemoveLink</string>
+							<string>cacheDimension</string>
+							<string>cellIpButton</string>
+							<string>cellList</string>
+							<string>checkButtonAfsAtBootTime</string>
+							<string>checkEnableLink</string>
+							<string>dCacheDim</string>
+							<string>daemonNumber</string>
+							<string>dynRoot</string>
+							<string>groupsBox</string>
+							<string>installKRB5AuthAtLoginButton</string>
+							<string>lynkCreationController</string>
+							<string>nVolEntry</string>
+							<string>nsButtonEnableDisableKrb5RenewCheck</string>
+							<string>nsStepperKrb5RenewTimeD</string>
+							<string>nsStepperKrb5RenewTimeH</string>
+							<string>nsStepperKrb5RenewTimeM</string>
+							<string>nsStepperKrb5RenewTimeS</string>
+							<string>nsTextFieldKrb5RenewCheckIntervall</string>
+							<string>nsTextFieldKrb5RenewTimeD</string>
+							<string>nsTextFieldKrb5RenewTimeH</string>
+							<string>nsTextFieldKrb5RenewTimeM</string>
+							<string>nsTextFieldKrb5RenewTimeS</string>
+							<string>nsTextFieldKrb5SecToExpireDateForRenew</string>
+							<string>removeCellButton</string>
 							<string>saveConfigurationButton</string>
 							<string>startStopButton</string>
 							<string>statCacheEntry</string>
@@ -5714,7 +5790,7 @@ Zm9yIGRlYnVnZ2luZyBhcyBpdCBwcmludHMgYSBMT1Qgb2YgaW5mb3JtYXRpb24uCg</string>
 							<string>useAklogCheck</string>
 							<string>verbose</string>
 						</object>
-						<object class="NSMutableArray" key="dict.values">
+						<object class="NSArray" key="dict.values">
 							<bool key="EncodedWithXMLCoder">YES</bool>
 							<string>NSControl</string>
 							<string>NSView</string>
@@ -5724,6 +5800,7 @@ Zm9yIGRlYnVnZ2luZyBhcyBpdCBwcmludHMgYSBMT1Qgb2YgaW5mb3JtYXRpb24uCg</string>
 							<string>NSTextField</string>
 							<string>NSTextField</string>
 							<string>NSButton</string>
+							<string>SFAuthorizationView</string>
 							<string>NSButton</string>
 							<string>NSButton</string>
 							<string>NSButton</string>
@@ -5732,19 +5809,11 @@ Zm9yIGRlYnVnZ2luZyBhcyBpdCBwcmludHMgYSBMT1Qgb2YgaW5mb3JtYXRpb24uCg</string>
 							<string>NSTableView</string>
 							<string>NSButton</string>
 							<string>NSButton</string>
-							<string>id</string>
-							<string>id</string>
 							<string>NSTextField</string>
 							<string>NSTextField</string>
 							<string>NSButton</string>
 							<string>NSBox</string>
-							<string>id</string>
-							<string>id</string>
 							<string>NSButton</string>
-							<string>id</string>
-							<string>id</string>
-							<string>id</string>
-							<string>id</string>
 							<string>LynkCreationController</string>
 							<string>NSTextField</string>
 							<string>NSButton</string>
@@ -5772,38 +5841,253 @@ Zm9yIGRlYnVnZ2luZyBhcyBpdCBwcmludHMgYSBMT1Qgb2YgaW5mb3JtYXRpb24uCg</string>
 							<string>NSButton</string>
 						</object>
 					</object>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBProjectSource</string>
-						<string key="minorKey">AFSCommanderPref.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">AFSCommanderPref</string>
-					<string key="superclassName">NSPreferencePane</string>
-					<object class="NSMutableDictionary" key="outlets">
+					<object class="NSMutableDictionary" key="toOneOutletInfosByName">
 						<bool key="EncodedWithXMLCoder">YES</bool>
 						<object class="NSArray" key="dict.sortedKeys">
 							<bool key="EncodedWithXMLCoder">YES</bool>
-							<string>cellPopupButton</string>
-							<string>getTokenButton</string>
+							<string>addCellButton</string>
+							<string>afsCommanderView</string>
+							<string>afsDB</string>
+							<string>afsDefaultCellLabel</string>
+							<string>afsMenucheckBox</string>
+							<string>afsRootMountPoint</string>
+							<string>afsVersionLabel</string>
+							<string>aklogCredentialAtLoginTime</string>
+							<string>authView</string>
+							<string>backgrounderActivationCheck</string>
+							<string>buttonAddLink</string>
+							<string>buttonRemoveLink</string>
+							<string>cacheDimension</string>
+							<string>cellIpButton</string>
+							<string>cellList</string>
+							<string>checkButtonAfsAtBootTime</string>
+							<string>checkEnableLink</string>
+							<string>dCacheDim</string>
+							<string>daemonNumber</string>
+							<string>dynRoot</string>
+							<string>groupsBox</string>
+							<string>installKRB5AuthAtLoginButton</string>
+							<string>lynkCreationController</string>
+							<string>nVolEntry</string>
+							<string>nsButtonEnableDisableKrb5RenewCheck</string>
+							<string>nsStepperKrb5RenewTimeD</string>
+							<string>nsStepperKrb5RenewTimeH</string>
+							<string>nsStepperKrb5RenewTimeM</string>
+							<string>nsStepperKrb5RenewTimeS</string>
+							<string>nsTextFieldKrb5RenewCheckIntervall</string>
+							<string>nsTextFieldKrb5RenewTimeD</string>
+							<string>nsTextFieldKrb5RenewTimeH</string>
+							<string>nsTextFieldKrb5RenewTimeM</string>
+							<string>nsTextFieldKrb5RenewTimeS</string>
+							<string>nsTextFieldKrb5SecToExpireDateForRenew</string>
+							<string>removeCellButton</string>
+							<string>saveConfigurationButton</string>
+							<string>startStopButton</string>
+							<string>statCacheEntry</string>
+							<string>tableViewLink</string>
+							<string>textFieldDevInfoLabel</string>
+							<string>textSearchField</string>
+							<string>tokensButton</string>
+							<string>tokensTable</string>
+							<string>unlogButton</string>
+							<string>useAklogCheck</string>
+							<string>verbose</string>
 						</object>
-						<object class="NSMutableArray" key="dict.values">
+						<object class="NSArray" key="dict.values">
 							<bool key="EncodedWithXMLCoder">YES</bool>
-							<string>NSPopUpButton</string>
-							<string>NSPopUpButton</string>
+							<object class="IBToOneOutletInfo">
+								<string key="name">addCellButton</string>
+								<string key="candidateClassName">NSControl</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">afsCommanderView</string>
+								<string key="candidateClassName">NSView</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">afsDB</string>
+								<string key="candidateClassName">NSButton</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">afsDefaultCellLabel</string>
+								<string key="candidateClassName">NSTextField</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">afsMenucheckBox</string>
+								<string key="candidateClassName">NSControl</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">afsRootMountPoint</string>
+								<string key="candidateClassName">NSTextField</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">afsVersionLabel</string>
+								<string key="candidateClassName">NSTextField</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">aklogCredentialAtLoginTime</string>
+								<string key="candidateClassName">NSButton</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">authView</string>
+								<string key="candidateClassName">SFAuthorizationView</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">backgrounderActivationCheck</string>
+								<string key="candidateClassName">NSButton</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">buttonAddLink</string>
+								<string key="candidateClassName">NSButton</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">buttonRemoveLink</string>
+								<string key="candidateClassName">NSButton</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">cacheDimension</string>
+								<string key="candidateClassName">NSTextField</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">cellIpButton</string>
+								<string key="candidateClassName">NSControl</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">cellList</string>
+								<string key="candidateClassName">NSTableView</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">checkButtonAfsAtBootTime</string>
+								<string key="candidateClassName">NSButton</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">checkEnableLink</string>
+								<string key="candidateClassName">NSButton</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">dCacheDim</string>
+								<string key="candidateClassName">NSTextField</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">daemonNumber</string>
+								<string key="candidateClassName">NSTextField</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">dynRoot</string>
+								<string key="candidateClassName">NSButton</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">groupsBox</string>
+								<string key="candidateClassName">NSBox</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">installKRB5AuthAtLoginButton</string>
+								<string key="candidateClassName">NSButton</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">lynkCreationController</string>
+								<string key="candidateClassName">LynkCreationController</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">nVolEntry</string>
+								<string key="candidateClassName">NSTextField</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">nsButtonEnableDisableKrb5RenewCheck</string>
+								<string key="candidateClassName">NSButton</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">nsStepperKrb5RenewTimeD</string>
+								<string key="candidateClassName">NSStepper</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">nsStepperKrb5RenewTimeH</string>
+								<string key="candidateClassName">NSStepper</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">nsStepperKrb5RenewTimeM</string>
+								<string key="candidateClassName">NSStepper</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">nsStepperKrb5RenewTimeS</string>
+								<string key="candidateClassName">NSStepper</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">nsTextFieldKrb5RenewCheckIntervall</string>
+								<string key="candidateClassName">NSTextField</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">nsTextFieldKrb5RenewTimeD</string>
+								<string key="candidateClassName">NSTextField</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">nsTextFieldKrb5RenewTimeH</string>
+								<string key="candidateClassName">NSTextField</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">nsTextFieldKrb5RenewTimeM</string>
+								<string key="candidateClassName">NSTextField</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">nsTextFieldKrb5RenewTimeS</string>
+								<string key="candidateClassName">NSTextField</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">nsTextFieldKrb5SecToExpireDateForRenew</string>
+								<string key="candidateClassName">NSTextField</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">removeCellButton</string>
+								<string key="candidateClassName">NSControl</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">saveConfigurationButton</string>
+								<string key="candidateClassName">NSControl</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">startStopButton</string>
+								<string key="candidateClassName">NSButton</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">statCacheEntry</string>
+								<string key="candidateClassName">NSTextField</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">tableViewLink</string>
+								<string key="candidateClassName">NSTableView</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">textFieldDevInfoLabel</string>
+								<string key="candidateClassName">NSTextField</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">textSearchField</string>
+								<string key="candidateClassName">NSSearchField</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">tokensButton</string>
+								<string key="candidateClassName">NSButton</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">tokensTable</string>
+								<string key="candidateClassName">NSTableView</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">unlogButton</string>
+								<string key="candidateClassName">NSButton</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">useAklogCheck</string>
+								<string key="candidateClassName">NSButton</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">verbose</string>
+								<string key="candidateClassName">NSButton</string>
+							</object>
 						</object>
 					</object>
 					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBUserSource</string>
-						<string key="minorKey"/>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">FirstResponder</string>
-					<string key="superclassName">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBUserSource</string>
-						<string key="minorKey"/>
+						<string key="majorKey">IBProjectSource</string>
+						<string key="minorKey">./Classes/AFSCommanderPref.h</string>
 					</object>
 				</object>
 				<object class="IBPartialClassDescription">
@@ -5813,30 +6097,16 @@ Zm9yIGRlYnVnZ2luZyBhcyBpdCBwcmludHMgYSBMT1Qgb2YgaW5mb3JtYXRpb24uCg</string>
 						<string key="NS.key.0">closePanel:</string>
 						<string key="NS.object.0">id</string>
 					</object>
-					<object class="NSMutableDictionary" key="outlets">
-						<bool key="EncodedWithXMLCoder">YES</bool>
-						<object class="NSArray" key="dict.sortedKeys">
-							<bool key="EncodedWithXMLCoder">YES</bool>
-							<string>infoPanel</string>
-							<string>texEditInfo</string>
-						</object>
-						<object class="NSMutableArray" key="dict.values">
-							<bool key="EncodedWithXMLCoder">YES</bool>
-							<string>id</string>
-							<string>id</string>
+					<object class="NSMutableDictionary" key="actionInfosByName">
+						<string key="NS.key.0">closePanel:</string>
+						<object class="IBActionInfo" key="NS.object.0">
+							<string key="name">closePanel:</string>
+							<string key="candidateClassName">id</string>
 						</object>
 					</object>
 					<object class="IBClassDescriptionSource" key="sourceIdentifier">
 						<string key="majorKey">IBProjectSource</string>
-						<string key="minorKey">InfoController.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">InfoController</string>
-					<string key="superclassName">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBUserSource</string>
-						<string key="minorKey"/>
+						<string key="minorKey">./Classes/InfoController.h</string>
 					</object>
 				</object>
 				<object class="IBPartialClassDescription">
@@ -5850,13 +6120,37 @@ Zm9yIGRlYnVnZ2luZyBhcyBpdCBwcmludHMgYSBMT1Qgb2YgaW5mb3JtYXRpb24uCg</string>
 							<string>save:</string>
 							<string>selectLinkDest:</string>
 						</object>
-						<object class="NSMutableArray" key="dict.values">
+						<object class="NSArray" key="dict.values">
 							<bool key="EncodedWithXMLCoder">YES</bool>
 							<string>id</string>
 							<string>id</string>
 							<string>id</string>
 						</object>
 					</object>
+					<object class="NSMutableDictionary" key="actionInfosByName">
+						<bool key="EncodedWithXMLCoder">YES</bool>
+						<object class="NSArray" key="dict.sortedKeys">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>cancell:</string>
+							<string>save:</string>
+							<string>selectLinkDest:</string>
+						</object>
+						<object class="NSArray" key="dict.values">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<object class="IBActionInfo">
+								<string key="name">cancell:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+							<object class="IBActionInfo">
+								<string key="name">save:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+							<object class="IBActionInfo">
+								<string key="name">selectLinkDest:</string>
+								<string key="candidateClassName">id</string>
+							</object>
+						</object>
+					</object>
 					<object class="NSMutableDictionary" key="outlets">
 						<bool key="EncodedWithXMLCoder">YES</bool>
 						<object class="NSArray" key="dict.sortedKeys">
@@ -5865,402 +6159,40 @@ Zm9yIGRlYnVnZ2luZyBhcyBpdCBwcmludHMgYSBMT1Qgb2YgaW5mb3JtYXRpb24uCg</string>
 							<string>textFieldLinkDestPath</string>
 							<string>textfieldLinkName</string>
 						</object>
-						<object class="NSMutableArray" key="dict.values">
+						<object class="NSArray" key="dict.values">
 							<bool key="EncodedWithXMLCoder">YES</bool>
 							<string>NSPanel</string>
 							<string>NSTextField</string>
 							<string>NSTextField</string>
 						</object>
 					</object>
+					<object class="NSMutableDictionary" key="toOneOutletInfosByName">
+						<bool key="EncodedWithXMLCoder">YES</bool>
+						<object class="NSArray" key="dict.sortedKeys">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>lynkCreationSheet</string>
+							<string>textFieldLinkDestPath</string>
+							<string>textfieldLinkName</string>
+						</object>
+						<object class="NSArray" key="dict.values">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<object class="IBToOneOutletInfo">
+								<string key="name">lynkCreationSheet</string>
+								<string key="candidateClassName">NSPanel</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">textFieldLinkDestPath</string>
+								<string key="candidateClassName">NSTextField</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">textfieldLinkName</string>
+								<string key="candidateClassName">NSTextField</string>
+							</object>
+						</object>
+					</object>
 					<object class="IBClassDescriptionSource" key="sourceIdentifier">
 						<string key="majorKey">IBProjectSource</string>
-						<string key="minorKey">LynkCreationController.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSPreferencePane</string>
-					<string key="superclassName">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBUserSource</string>
-						<string key="minorKey"/>
-					</object>
-				</object>
-			</object>
-			<object class="NSMutableArray" key="referencedPartialClassDescriptionsV3.2+">
-				<bool key="EncodedWithXMLCoder">YES</bool>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSActionCell</string>
-					<string key="superclassName">NSCell</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSActionCell.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSApplication</string>
-					<string key="superclassName">NSResponder</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier" id="204676479">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSApplication.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSApplication</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier" id="621097933">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSApplicationScripting.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSApplication</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier" id="104909186">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSColorPanel.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSApplication</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSHelpManager.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSApplication</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSPageLayout.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSApplication</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSUserInterfaceItemSearching.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSBox</string>
-					<string key="superclassName">NSView</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSBox.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSButton</string>
-					<string key="superclassName">NSControl</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSButton.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSButtonCell</string>
-					<string key="superclassName">NSActionCell</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSButtonCell.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSCell</string>
-					<string key="superclassName">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSCell.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSControl</string>
-					<string key="superclassName">NSView</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier" id="41055177">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSControl.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSFormatter</string>
-					<string key="superclassName">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">Foundation.framework/Headers/NSFormatter.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSMenu</string>
-					<string key="superclassName">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier" id="734906022">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSMenu.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSNumberFormatter</string>
-					<string key="superclassName">NSFormatter</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">Foundation.framework/Headers/NSNumberFormatter.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSAccessibility.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<reference key="sourceIdentifier" ref="204676479"/>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<reference key="sourceIdentifier" ref="621097933"/>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<reference key="sourceIdentifier" ref="104909186"/>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<reference key="sourceIdentifier" ref="41055177"/>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSDictionaryController.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSDragging.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSFontManager.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSFontPanel.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSKeyValueBinding.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<reference key="sourceIdentifier" ref="734906022"/>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSNibLoading.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSOutlineView.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSPasteboard.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSSavePanel.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier" id="616595462">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSTableView.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSToolbarItem.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier" id="354787859">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSView.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">Foundation.framework/Headers/NSArchiver.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">Foundation.framework/Headers/NSClassDescription.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">Foundation.framework/Headers/NSError.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">Foundation.framework/Headers/NSFileManager.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">Foundation.framework/Headers/NSKeyValueCoding.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">Foundation.framework/Headers/NSKeyValueObserving.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">Foundation.framework/Headers/NSKeyedArchiver.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">Foundation.framework/Headers/NSObject.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">Foundation.framework/Headers/NSObjectScripting.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">Foundation.framework/Headers/NSPortCoder.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">Foundation.framework/Headers/NSRunLoop.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">Foundation.framework/Headers/NSScriptClassDescription.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">Foundation.framework/Headers/NSScriptKeyValueCoding.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">Foundation.framework/Headers/NSScriptObjectSpecifiers.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">Foundation.framework/Headers/NSScriptWhoseTests.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">Foundation.framework/Headers/NSThread.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">Foundation.framework/Headers/NSURL.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">Foundation.framework/Headers/NSURLConnection.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">Foundation.framework/Headers/NSURLDownload.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSPanel</string>
-					<string key="superclassName">NSWindow</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSPanel.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSPopUpButton</string>
-					<string key="superclassName">NSButton</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSPopUpButton.h</string>
+						<string key="minorKey">./Classes/LynkCreationController.h</string>
 					</object>
 				</object>
 				<object class="IBPartialClassDescription">
@@ -6275,7 +6207,7 @@ Zm9yIGRlYnVnZ2luZyBhcyBpdCBwcmludHMgYSBMT1Qgb2YgaW5mb3JtYXRpb24uCg</string>
 							<string>_lastKeyView</string>
 							<string>_window</string>
 						</object>
-						<object class="NSMutableArray" key="dict.values">
+						<object class="NSArray" key="dict.values">
 							<bool key="EncodedWithXMLCoder">YES</bool>
 							<string>NSView</string>
 							<string>NSView</string>
@@ -6283,189 +6215,38 @@ Zm9yIGRlYnVnZ2luZyBhcyBpdCBwcmludHMgYSBMT1Qgb2YgaW5mb3JtYXRpb24uCg</string>
 							<string>NSWindow</string>
 						</object>
 					</object>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">PreferencePanes.framework/Headers/NSPreferencePane.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSResponder</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSInterfaceStyle.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSResponder</string>
-					<string key="superclassName">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSResponder.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSScrollView</string>
-					<string key="superclassName">NSView</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSScrollView.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSScroller</string>
-					<string key="superclassName">NSControl</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSScroller.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSSearchField</string>
-					<string key="superclassName">NSTextField</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSSearchField.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSSearchFieldCell</string>
-					<string key="superclassName">NSTextFieldCell</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSSearchFieldCell.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSStepper</string>
-					<string key="superclassName">NSControl</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSStepper.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSStepperCell</string>
-					<string key="superclassName">NSActionCell</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSStepperCell.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSTabView</string>
-					<string key="superclassName">NSView</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSTabView.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSTabViewItem</string>
-					<string key="superclassName">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSTabViewItem.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSTableColumn</string>
-					<string key="superclassName">NSObject</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSTableColumn.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSTableHeaderView</string>
-					<string key="superclassName">NSView</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSTableHeaderView.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSTableView</string>
-					<string key="superclassName">NSControl</string>
-					<reference key="sourceIdentifier" ref="616595462"/>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSText</string>
-					<string key="superclassName">NSView</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSText.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSTextField</string>
-					<string key="superclassName">NSControl</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSTextField.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSTextFieldCell</string>
-					<string key="superclassName">NSActionCell</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSTextFieldCell.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSTextView</string>
-					<string key="superclassName">NSText</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSTextView.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSView</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSClipView.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSView</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSMenuItem.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSView</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSRulerView.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSView</string>
-					<string key="superclassName">NSResponder</string>
-					<reference key="sourceIdentifier" ref="354787859"/>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSWindow</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSDrawer.h</string>
-					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSWindow</string>
-					<string key="superclassName">NSResponder</string>
-					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSWindow.h</string>
+					<object class="NSMutableDictionary" key="toOneOutletInfosByName">
+						<bool key="EncodedWithXMLCoder">YES</bool>
+						<object class="NSArray" key="dict.sortedKeys">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>_firstKeyView</string>
+							<string>_initialKeyView</string>
+							<string>_lastKeyView</string>
+							<string>_window</string>
+						</object>
+						<object class="NSArray" key="dict.values">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<object class="IBToOneOutletInfo">
+								<string key="name">_firstKeyView</string>
+								<string key="candidateClassName">NSView</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">_initialKeyView</string>
+								<string key="candidateClassName">NSView</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">_lastKeyView</string>
+								<string key="candidateClassName">NSView</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">_window</string>
+								<string key="candidateClassName">NSWindow</string>
+							</object>
+						</object>
 					</object>
-				</object>
-				<object class="IBPartialClassDescription">
-					<string key="className">NSWindow</string>
 					<object class="IBClassDescriptionSource" key="sourceIdentifier">
-						<string key="majorKey">IBFrameworkSource</string>
-						<string key="minorKey">AppKit.framework/Headers/NSWindowScripting.h</string>
+						<string key="majorKey">IBProjectSource</string>
+						<string key="minorKey">./Classes/NSPreferencePane.h</string>
 					</object>
 				</object>
 			</object>
@@ -6481,7 +6262,6 @@ Zm9yIGRlYnVnZ2luZyBhcyBpdCBwcmludHMgYSBMT1Qgb2YgaW5mb3JtYXRpb24uCg</string>
 			<integer value="3000" key="NS.object.0"/>
 		</object>
 		<bool key="IBDocument.PluginDeclaredDependenciesTrackSystemTargetVersion">YES</bool>
-		<string key="IBDocument.LastKnownRelativeProjectPath">../OpenAFS.xcodeproj</string>
 		<int key="IBDocument.defaultPropertyAccessControl">3</int>
 		<object class="NSMutableDictionary" key="IBDocument.LastKnownImageSizes">
 			<string key="NS.key.0">NSSwitch</string>
diff --git a/src/platform/DARWIN/AFSPreference/IpConfiguratorCommander.m b/src/platform/DARWIN/AFSPreference/IpConfiguratorCommander.m
index 3042397..70a50ab 100644
--- a/src/platform/DARWIN/AFSPreference/IpConfiguratorCommander.m
+++ b/src/platform/DARWIN/AFSPreference/IpConfiguratorCommander.m
@@ -16,8 +16,8 @@
 // -------------------------------------------------------------------------------
 - (void)awakeFromNib
 {
-	[((NSTableView*)tableViewCellIP) setDelegate:self];
-	[((NSTableView*)tableViewCellIP) setDataSource:self];
+	[tableViewCellIP setDelegate:self];
+	[tableViewCellIP setDataSource:self];
 }
 
 // -------------------------------------------------------------------------------
@@ -44,8 +44,8 @@
 - (void) commitModify
 {
 	//store the cell name
-	[cellElement setCellName:[((NSControl*) textFieldCellName) stringValue]];
-	[cellElement setCellComment:[((NSControl*) textFieldComment) stringValue]];
+	[cellElement setCellName:[textFieldCellName stringValue]];
+	[cellElement setCellComment:[textFieldComment stringValue]];
 	[bkIPArray removeAllObjects];
 	[bkIPArray setArray:workIPArray];
 	[workIPArray release];
@@ -81,8 +81,8 @@
 	[workIPArray addObject:ip];
 	[ip release];
 	currentSelectedIP = ip;
-	[((NSTableView*)tableViewCellIP) reloadData];
-	[((NSTableView *) tableViewCellIP)  scrollRowToVisible:[[cellElement getIp] count]-1];
+	[tableViewCellIP reloadData];
+	[tableViewCellIP scrollRowToVisible:[[cellElement getIp] count]-1];
 }
 
 // -------------------------------------------------------------------------------
@@ -90,10 +90,10 @@
 // -------------------------------------------------------------------------------
 - (IBAction) cancelIP:(id) sender
 {
-	[workIPArray removeObjectAtIndex:[((NSTableView*)tableViewCellIP) selectedRow]];
-	[((NSTableView*)tableViewCellIP) deselectAll:nil];
+	[workIPArray removeObjectAtIndex:[tableViewCellIP selectedRow]];
+	[tableViewCellIP deselectAll:nil];
 	[self manageTableSelection:-1];
-	[((NSTableView*)tableViewCellIP) reloadData];
+	[tableViewCellIP reloadData];
 
 }
 
@@ -110,9 +110,9 @@
 // -------------------------------------------------------------------------------
 - (void) loadValueFromCellIPClass
 {
-	[((NSTextField*)textFieldCellName) setStringValue:[cellElement getCellName]]; 
-	[((NSTextField*)textFieldComment) setStringValue:[cellElement getCellComment]]; 
-	[((NSTableView*)tableViewCellIP) reloadData];
+	[textFieldCellName setStringValue:[cellElement getCellName]];
+	[textFieldComment setStringValue:[cellElement getCellComment]];
+	[tableViewCellIP reloadData];
 }
 
 // -------------------------------------------------------------------------------
@@ -121,7 +121,7 @@
 - (void) manageTableSelection:(int)row
 {
 	//[((NSControl*) modifyButton) setEnabled:row>=0];
-	[((NSControl*) deleteButton) setEnabled:row>=0];
+	[deleteButton setEnabled:row>=0];
 }
 
 - (id) getPanel
@@ -194,7 +194,7 @@
    forTableColumn:(NSTableColumn *)aCol row:(int)aRow
 {
 	CellIp *ipElement =  (CellIp*)[workIPArray objectAtIndex:aRow];
-	switch([((NSNumber*)[aCol identifier]) intValue])
+	switch([[aCol identifier] intValue])
 	{
 		case 1:
 			[ipElement setCellIp:[aData description]];
diff --git a/src/platform/DARWIN/AFSPreference/PListManager.h b/src/platform/DARWIN/AFSPreference/PListManager.h
index c1fb051..44f90bf 100644
--- a/src/platform/DARWIN/AFSPreference/PListManager.h
+++ b/src/platform/DARWIN/AFSPreference/PListManager.h
@@ -40,7 +40,7 @@
  @abstract   Enable or disable the system to get kerberos ticket at login time
  @discussion <#(comprehensive description)#>
  */
-+(void) krb5TiketAtLoginTime:(BOOL)enable;
++(void) krb5TiketAtLoginTime:(BOOL)enable helper:(NSString *)helper;
 
 /*!
  @method     checkKrb5AtLoginTimeLaunchdEnable
@@ -80,9 +80,7 @@
  @abstract   exec the launchctl command on a particular plist job
  @discussion <#(comprehensive description)#>
  */
-+(void) launchctlStringCommand:(NSString*)operation
-						option:(NSArray*)option
-					 plistName:(NSString*)plistName;
++(void) launchctlStringCommandAuth:(NSString*)operation option:(NSArray*)option plistName:(NSString*)plistName helper:(NSString *)helper withAuthRef:(AuthorizationRef)authRef;
 /*!
  @method     launchdJobState
  @abstract   check is a job has been submitted to launchd
diff --git a/src/platform/DARWIN/AFSPreference/PListManager.m b/src/platform/DARWIN/AFSPreference/PListManager.m
index 8497870..977f962 100644
--- a/src/platform/DARWIN/AFSPreference/PListManager.m
+++ b/src/platform/DARWIN/AFSPreference/PListManager.m
@@ -17,7 +17,8 @@
 // -------------------------------------------------------------------------------
 //  krb5TiketAtLoginTime:
 // -------------------------------------------------------------------------------
-+(void) krb5TiketAtLoginTime:(BOOL)enable{
++(void) krb5TiketAtLoginTime:(BOOL)enable helper:(NSString *)helper
+{
 	NSData					*plistData = nil;
 	NSString				*error = nil;
 	NSString				*toRemove = nil;
@@ -112,16 +113,15 @@
 	
 	//now we can move the file
 	futil = [[FileUtil alloc] init];
-	if([futil startAutorization] == noErr) {
-		if(![[NSFileManager defaultManager] fileExistsAtPath:AUTH_FILE_BK]) {
-			//bk file doesn't exist so make it
-			[futil autorizedCopy:AUTH_FILE toPath:AUTH_FILE_BK];
-		}
-		// chmod on tmp file
-		[futil autorizedChown:TMP_FILE owner:@"root" group:@"wheel"];
-		//move the file 
-		[futil autorizedMoveFile:TMP_FILE toPath:AUTH_FILE_DIR];
+	if(![[NSFileManager defaultManager] fileExistsAtPath:AUTH_FILE_BK]) {
+	    //bk file doesn't exist so make it
+	    [futil autorizedCopy:AUTH_FILE toPath:AUTH_FILE_BK];
 	}
+	// chmod on tmp file
+	[futil autorizedChown:TMP_FILE owner:@"root" group:@"wheel"];
+	//move the file
+	[futil autorizedMoveFile:TMP_FILE toPath:AUTH_FILE_DIR];
+
 	[futil release];
 }
 
@@ -223,9 +223,9 @@
 //  installAfsStartupLaunchdFile:
 // -------------------------------------------------------------------------------
 +(void) manageAfsStartupLaunchdFile:(BOOL)enable 
-				   afsStartupScript:(NSString*)afsStartupScript 
-						afsBasePath:(NSString*)afsBasePath 
-						   afsdPath:(NSString*)afsdPath {
+		   afsStartupScript:(NSString*)afsStartupScript
+			afsBasePath:(NSString*)afsBasePath
+			   afsdPath:(NSString*)afsdPath {
 	NSData				*plistData = nil;
 	NSMutableDictionary *launchdDic = nil;
 	NSString			*error = nil;
@@ -288,9 +288,10 @@
 //  launchctlCommand:
 // -------------------------------------------------------------------------------
 +(void) launchctlCommand:(BOOL)enable
-			  userDomain:(BOOL)userDomain
-					   option:(NSArray*)option 
-					plistName:(NSString*)plistName {
+	      userDomain:(BOOL)userDomain
+		  option:(NSArray*)option
+	       plistName:(NSString*)plistName
+{
 	NSMutableArray *argument = [NSMutableArray array];
 	NSMutableString *commandPath = [NSMutableString stringWithCapacity:0];
 	NSUInteger searchDomain = userDomain?NSUserDomainMask:NSSystemDomainMask;
@@ -307,17 +308,21 @@
 	[commandPath appendFormat:@"/LaunchAgents/%@", plistName];
 	
 	[argument addObject:commandPath];
+
 	//exec the command
-	[TaskUtil executeTaskSearchingPath:@"launchctl"  
-								  args:argument];
+	[TaskUtil executeTask:@"/bin/launchctl"
+		  arguments:argument];
 }
 
 // -------------------------------------------------------------------------------
 //  launchctlCommand:
 // -------------------------------------------------------------------------------
-+(void) launchctlStringCommand:(NSString*)operation
-				  option:(NSArray*)option
-			   plistName:(NSString*)plistName {
++(void) launchctlStringCommandAuth:(NSString *)operation
+			    option:(NSArray *)option
+			 plistName:(NSString *)plistName
+			    helper:(NSString *)helper
+		       withAuthRef:(AuthorizationRef)authRef
+{
 	NSMutableArray *argument = [NSMutableArray array];
 
 	//set the load unload
@@ -330,8 +335,8 @@
 	[argument addObject: plistName];
 
 	//exec the command
-	[TaskUtil executeTaskSearchingPath:@"launchctl"
-								  args:argument];
+	[TaskUtil executeTaskWithAuth:@"/bin/launchctl"
+		  arguments:argument helper:helper withAuthRef:authRef];
 }
 
 // -------------------------------------------------------------------------------
diff --git a/src/platform/DARWIN/AFSPreference/TaskUtil.h b/src/platform/DARWIN/AFSPreference/TaskUtil.h
index b7fc7ec..459b68e 100644
--- a/src/platform/DARWIN/AFSPreference/TaskUtil.h
+++ b/src/platform/DARWIN/AFSPreference/TaskUtil.h
@@ -16,4 +16,5 @@
 +(NSString*) executeTaskSearchingPath:(NSString*)unixCommand args:(NSArray*)args;
 +(NSString*) executeTask:(NSString*) taskName arguments:(NSArray *)args;
 +(int) executeTaskWithAuth:(NSString*) taskName arguments:(NSArray *)args authExtForm:(NSData*)auth;
++(int) executeTaskWithAuth:(NSString*) taskName arguments:(NSArray *)args helper:(NSString *)helper withAuthRef:(AuthorizationRef)authRef;
 @end
diff --git a/src/platform/DARWIN/AFSPreference/TaskUtil.m b/src/platform/DARWIN/AFSPreference/TaskUtil.m
index c27ee8f..3c94524 100644
--- a/src/platform/DARWIN/AFSPreference/TaskUtil.m
+++ b/src/platform/DARWIN/AFSPreference/TaskUtil.m
@@ -7,6 +7,7 @@
 //
 
 #import "TaskUtil.h"
+#import "AuthUtil.h"
 
 
 @implementation TaskUtil
@@ -75,6 +76,36 @@
 // -------------------------------------------------------------------------------
 //  executeTask:
 // -------------------------------------------------------------------------------
++(int) executeTaskWithAuth:(NSString*) taskName arguments:(NSArray *)args helper:(NSString *)helper withAuthRef:(AuthorizationRef)authRef {
+    const char *rootHelperApp = [helper fileSystemRepresentation];
+    OSStatus status;
+    AuthorizationFlags flags = kAuthorizationFlagDefaults;
+    int count = [args count];
+    char **myArguments = calloc(count + 2, sizeof(char *));
+    int i=0;
+
+    myArguments[0] = strdup([taskName UTF8String]);
+    for(i=0;i < count;i++) {
+	const char *string = [[args objectAtIndex:i] UTF8String];
+	if(!string)
+	    break;
+	myArguments[1+i] = strdup(string);
+    }
+    myArguments[1+i] = NULL;
+
+    // should use SMJobBless but we need to sign things...
+    status = AuthorizationExecuteWithPrivileges(authRef, rootHelperApp, flags, myArguments, NULL);
+
+    i = 0;
+    while (myArguments[i] != NULL) {
+        free(myArguments[i]);
+        i++;
+    }
+
+    free(myArguments);
+    return status;
+}
+
 +(int) executeTaskWithAuth:(NSString*) taskName arguments:(NSArray *)args authExtForm:(NSData*)auth {
 	NSString *result = nil;
 	int status = 0;
diff --git a/src/platform/DARWIN/AFSPreference/afshlp.m b/src/platform/DARWIN/AFSPreference/afshlp.m
index ad59d94..5d2f702 100644
--- a/src/platform/DARWIN/AFSPreference/afshlp.m
+++ b/src/platform/DARWIN/AFSPreference/afshlp.m
@@ -1,213 +1,11 @@
-//
-//  afshlp.m
-//  AFSCommander
-//
-//  Created by Claudio on 28/06/07.
-//
-
-
-#include <sys/types.h>
-#include <unistd.h>
-#include <Security/Authorization.h>
-#include <Security/AuthorizationTags.h>
-#include <sys/param.h>
-#include <sys/stat.h>
-#include <sys/wait.h>
-#include <sys/types.h>
-#include <sys/fcntl.h>
-#include <sys/errno.h>
 #include <unistd.h>
-#include <stdlib.h>
-#include <string.h>
-#include <asl.h>
-#include <sys/event.h>
-#include <mach-o/dyld.h>
-#import "TaskUtil.h"
-#import "AuthUtil.h"
-#import "PListManager.h"
-
-#define AFS_DAEMON_STARTUPSCRIPT	"/Library/OpenAFS/Tools/root.client/usr/vice/etc/afs.rc"
-#define AFS_DAEMON_PATH				"/Library/LaunchDaemons/org.openafs.filesystems.afs.plist"
-
- void stopAfs(int argc, char *argv[]);
- void getPath(char **selfPathPtr);
- void selfRepair(char *selfPath);
- void runWithSelfRepair(char *selfPath,int argc, char *argv[]);
-
-int main(int argc, char *argv[])
-{
-	if (argc < 2)
-		return 1; // nothing to do
-	NSString *cmdString = [NSString stringWithCString:(const char *)argv[1] encoding:NSUTF8StringEncoding];
-
-	if(argc == 2 && [cmdString rangeOfString:@"stop_afs"].location!=NSNotFound ){
-		if (setuid(0) == -1)
-			return 1;
-		const char *stopArgs[] = {"stop", 0L};
-		[[AuthUtil shared] execUnixCommand:AFS_DAEMON_STARTUPSCRIPT
-									  args:stopArgs
-									output:nil];
-	} else 	if(argc == 2 && [cmdString rangeOfString:@"start_afs"].location!=NSNotFound){
-		if (setuid(0) == -1)
-			return 1;
-		const char *startArgs[] = {"start", 0L};
-		[[AuthUtil shared] execUnixCommand:AFS_DAEMON_STARTUPSCRIPT
-									  args:startArgs
-									output:nil];
-	} else if(argc == 4 && [cmdString rangeOfString:@"enable_krb5_startup"].location!=NSNotFound) {
-		int olduid = getuid();
-		setuid(0);
-		int arg2 = atoi(argv[2]);
-		[PListManager krb5TiketAtLoginTime:[[NSNumber numberWithInt:arg2] boolValue]];
-	} else if(argc == 3 && [cmdString rangeOfString:@"start_afs_at_startup"].location!=NSNotFound){
-		if (setuid(0) == -1)
-			return 1;
-		BOOL enable = strcmp("enable", argv[2])==0;
-		NSLog(@"Manage start_afs_at_startup with option %s from helper", argv[2]);
-		[PListManager launchctlStringCommand:enable?@"load":@"unload"
-									  option:[NSArray arrayWithObjects:@"-w", nil]
-								   plistName:@AFS_DAEMON_PATH];
-#if 0
-	} else if(argc == 2 && [cmdString rangeOfString:@"check_afs_daemon"].location!=NSNotFound) {
-		NSString *fsResult = [TaskUtil executeTaskSearchingPath:@"launchctl" args:[NSArray arrayWithObjects: @"list", nil]];
-		BOOL checkAfsDaemon = (fsResult?([fsResult rangeOfString:@"org.openafs.filesystems.afs"].location != NSNotFound):NO);
-		printf("afshlp:afs daemon registration result:%d",checkAfsDaemon);
-#endif
-	}
-	return 0;
-}
-
-#if 0
-void stopAfs(int argc, char *argv[])
-{
-	const char *umountArgs[] = {"-f", "/afs", 0L};
-	[[AuthUtil shared] execUnixCommand:"/sbin/umount" 
-								  args:umountArgs
-								output:nil];
-	
-	const char *afsdArgs[] = {"-shutdown", 0L};
-	[[AuthUtil shared] execUnixCommand:argv[3]
-								  args:afsdArgs
-								output:nil];
-	
-	const char *kernelExtArgs[] = {argv[2], 0L};
-	[[AuthUtil shared] execUnixCommand:"/sbin/kextunload"
-								  args:kernelExtArgs
-								output:nil];
-	
-	[[AuthUtil shared] deautorize];
-}
-
-// Code to get the path to the executable using _NSGetExecutablePath.
-void getPath(char **selfPathPtr)
-{
-    uint32_t selfPathSize = MAXPATHLEN;
-    if(!(*selfPathPtr = malloc(selfPathSize)))
-    {
-        exit(-1);
-    }
-    if(_NSGetExecutablePath(*selfPathPtr, &selfPathSize) == -1)
-    {
-        // Try reallocating selfPath with the size returned by the function.
-        if(!(*selfPathPtr = realloc(*selfPathPtr, selfPathSize + 1)))
-        {
-            NSLog(@"Could not allocate memory to hold executable path.");
-            exit(-1);
-        }
-        if(_NSGetExecutablePath(*selfPathPtr, &selfPathSize) != 0)
-        {
-            NSLog(@"Could not get executable path.");
-            exit(-1);
-        }
-    }
-}
-
-int main(int argc, char *argv[])
-{
-	NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
-    char *selfPath;
-	
-	NSLog(@"num of arguments %d", argc);
-	int status = [[AuthUtil shared] autorize];
-	if(status != noErr) exit(-1);
-	
-    // Get the path to the tool's executable
-    getPath(&selfPath);
-
-    //selfRepair(selfPath);
-    // All done with the executable path
-    if(selfPath) free(selfPath);
-	
-	// Now do the real work of running the command.
-    runCommand(argc, argv);
-    [[AuthUtil shared] deautorize];
-    [pool release];
-	
-	return 0;
-}
-
-// Self-repair code. Found somehwere in internet
-void selfRepair(char *selfPath)
+int
+main(int argc, char *argv[], char *envp[])
 {
-    struct stat st;
-    int fdTool;
-	printf("selfRepair"); 
-	
-//    [[AuthUtil shared] autorize];
-    
-    // Open tool exclusively, noone can touch it when we work on it, this idea i kepped somewhere in internet
-    fdTool = open(selfPath, O_NONBLOCK | O_RDONLY | O_EXLOCK, 0);
-    
-    if(fdTool == -1)
-    {
-        NSLog(@"Open Filed: %d.", errno);
-        exit(-1);
-    }
-    
-    if(fstat(fdTool, &st))
-    {
-        NSLog(@"fstat failed.");
-        exit(-1);
-    }
-    
-    // Disable group and world writability and make setuid root.
-    if ((st.st_uid != 0) || (st.st_mode & S_IWGRP) || (st.st_mode & S_IWOTH) ||
-	!(st.st_mode & S_ISUID))
-    {
-        fchown(fdTool, 0, st.st_gid);
-	fchmod(fdTool, (st.st_mode & (~(S_IWGRP | S_IWOTH))) | S_ISUID);
-    } else  NSLog(@"st_uid = 0");
-    
-    close(fdTool);
-    
-    NSLog(@"Self-repair done.");
+    int euid;
+    euid = geteuid();
+    if (setuid(euid) != 0)
+	return -1;
+    return execve(argv[1], &argv[1], envp);
 }
 
-
-// Code to execute the tool in self-repair mode.
-void runWithSelfRepair(char *selfPath, int argc, char *argv[])
-{
-    int status;
-    int pid;
-	
-      
-	// Make the qargs array for passing to child the same args of father
-    const char *arguments[] = {argv[1], argv[2], argv[3], "--self-repair", 0L};
-	
-	// Get the privileged AuthorizationRef
-    [[AuthUtil shared] autorize];
-	[[AuthUtil shared] execUnixCommand:selfPath 
-								  args:arguments 
-								output:nil];
-
-    pid = wait(&status);
-    if(pid == -1 || !WIFEXITED(status))
-    {
-        NSLog(@"Error returned from wait().");
-        exit(-1);
-    }
-    
-    // Exit with the same exit code as the self-repair child
-    exit(WEXITSTATUS(status));
-}
-#endif
diff --git a/src/ptserver/db_verify.c b/src/ptserver/db_verify.c
index e998639..0e76765 100644
--- a/src/ptserver/db_verify.c
+++ b/src/ptserver/db_verify.c
@@ -536,17 +536,13 @@ WalkNextChain(char map[],		/* one byte per db entry */
 	    if (id == PRBADID)
 		continue;
 	    else if (id) {
-		int eid_s, id_s;
+		int id_s;
 		sgcount++;
 		/* in case the ids are large, convert to pure sign. */
 		if (id > 0)
 		    id_s = 1;
 		else
 		    id_s = -1;
-		if (eid > 0)
-		    eid_s = 1;
-		else
-		    eid_s = -1;
 		if (id_s > 0) {
 		    fprintf(stderr,
 			    "User can't be member of supergroup list\n");
diff --git a/src/rx/rx.c b/src/rx/rx.c
index 0ef85e5..f35bf83 100644
--- a/src/rx/rx.c
+++ b/src/rx/rx.c
@@ -3171,11 +3171,13 @@ rxi_ReceivePacket(struct rx_packet *np, osi_socket socket,
 			   np->header.cid, np->header.epoch, type,
 			   np->header.securityIndex);
 
+    /* To avoid having 2 connections just abort at each other,
+       don't abort an abort. */
     if (!conn) {
-	/* If no connection found or fabricated, just ignore the packet.
-	 * (An argument could be made for sending an abort packet for
-	 * the conn) */
-	return np;
+        if (np->header.type != RX_PACKET_TYPE_ABORT)
+            rxi_SendRawAbort(socket, host, port, RX_INVALID_OPERATION,
+                             np, 0);
+        return np;
     }
 
     /* If the connection is in an error state, send an abort packet and ignore
@@ -4921,12 +4923,11 @@ rxi_AttachServerProc(struct rx_call *call,
 	if (call->flags & RX_CALL_WAIT_PROC) {
 	    /* Conservative:  I don't think this should happen */
 	    call->flags &= ~RX_CALL_WAIT_PROC;
+	    MUTEX_ENTER(&rx_waiting_mutex);
+	    rx_nWaiting--;
+	    MUTEX_EXIT(&rx_waiting_mutex);
 	    if (queue_IsOnQueue(call)) {
 		queue_Remove(call);
-
-                MUTEX_ENTER(&rx_waiting_mutex);
-                rx_nWaiting--;
-                MUTEX_EXIT(&rx_waiting_mutex);
 	    }
 	}
 	call->state = RX_STATE_ACTIVE;
@@ -5428,6 +5429,11 @@ rxi_ResetCall(struct rx_call *call, int newcall)
 	osi_rxWakeup(&call->twind);
 #endif
 
+    if (flags & RX_CALL_WAIT_PROC) {
+	MUTEX_ENTER(&rx_stats_mutex);
+	rx_nWaiting--;
+	MUTEX_EXIT(&rx_stats_mutex);
+    }
 #ifdef RX_ENABLE_LOCKS
     /* The following ensures that we don't mess with any queue while some
      * other thread might also be doing so. The call_queue_lock field is
@@ -5442,12 +5448,6 @@ rxi_ResetCall(struct rx_call *call, int newcall)
 	MUTEX_ENTER(call->call_queue_lock);
 	if (queue_IsOnQueue(call)) {
 	    queue_Remove(call);
-	    if (flags & RX_CALL_WAIT_PROC) {
-
-                MUTEX_ENTER(&rx_waiting_mutex);
-                rx_nWaiting--;
-                MUTEX_EXIT(&rx_waiting_mutex);
-	    }
 	}
 	MUTEX_EXIT(call->call_queue_lock);
 	CLEAR_CALL_QUEUE_LOCK(call);
@@ -5455,8 +5455,6 @@ rxi_ResetCall(struct rx_call *call, int newcall)
 #else /* RX_ENABLE_LOCKS */
     if (queue_IsOnQueue(call)) {
 	queue_Remove(call);
-	if (flags & RX_CALL_WAIT_PROC)
-	    rx_nWaiting--;
     }
 #endif /* RX_ENABLE_LOCKS */
 
diff --git a/src/rx/rx_packet.c b/src/rx/rx_packet.c
index 314504a..4d733de 100644
--- a/src/rx/rx_packet.c
+++ b/src/rx/rx_packet.c
@@ -2548,6 +2548,41 @@ rxi_SendPacketList(struct rx_call *call, struct rx_connection *conn,
     }
 }
 
+/* Send a raw abort packet, without any call or connection structures */
+void
+rxi_SendRawAbort(osi_socket socket, afs_uint32 host, u_short port,
+		 afs_int32 error, struct rx_packet *source, int istack)
+{
+    struct rx_header theader;
+    struct sockaddr_in addr;
+    struct iovec iov[2];
+
+    memset(&theader, 0, sizeof(theader));
+    theader.epoch = htonl(source->header.epoch);
+    theader.callNumber = htonl(source->header.callNumber);
+    theader.serial = htonl(1);
+    theader.type = RX_PACKET_TYPE_ABORT;
+    theader.serviceId = htons(source->header.serviceId);
+    theader.securityIndex = source->header.securityIndex;
+    theader.cid = htonl(source->header.cid);
+
+    error = htonl(error);
+
+    iov[0].iov_base = &theader;
+    iov[0].iov_len = sizeof(struct rx_header);
+    iov[1].iov_base = &error;
+    iov[1].iov_len = sizeof(error);
+
+    addr.sin_family = AF_INET;
+    addr.sin_addr.s_addr = host;
+    addr.sin_port = port;
+#ifdef STRUCT_SOCKADDR_HAS_SA_LEN
+    addr.sin_len = sizeof(struct sockaddr_in);
+#endif
+
+    osi_NetSend(socket, &addr, iov, 2,
+		sizeof(struct rx_header) + sizeof(error), istack);
+}
 
 /* Send a "special" packet to the peer connection.  If call is
  * specified, then the packet is directed to a specific call channel
diff --git a/src/rx/rx_prototypes.h b/src/rx/rx_prototypes.h
index 3315116..d433dfe 100644
--- a/src/rx/rx_prototypes.h
+++ b/src/rx/rx_prototypes.h
@@ -564,6 +564,9 @@ extern void rxi_SendPacket(struct rx_call *call, struct rx_connection *conn,
 extern void rxi_SendPacketList(struct rx_call *call,
 			       struct rx_connection *conn,
 			       struct rx_packet **list, int len, int istack);
+extern void rxi_SendRawAbort(osi_socket socket, afs_uint32 host, u_short port,
+			     afs_int32 error, struct rx_packet *source,
+			     int istack);
 extern struct rx_packet *rxi_SendSpecial(struct rx_call *call,
 					 struct rx_connection *conn,
 					 struct rx_packet *optionalPacket,
diff --git a/src/rxgen/rpc_parse.c b/src/rxgen/rpc_parse.c
index a88a069..a19ca54 100644
--- a/src/rxgen/rpc_parse.c
+++ b/src/rxgen/rpc_parse.c
@@ -1658,11 +1658,6 @@ ss_ProcTail_setup(definition * defp, int somefrees)
     for (plist = defp->pc.plists; plist; plist = plist->next) {
 	if (plist->component_kind == DEF_PARAM
 	    && (plist->pl.param_flag & FREETHIS_PARAM)) {
-	    char *dot = "", *extens = "";
-	    if (plist->pl.string_name) {
-		dot = ".";
-		extens = plist->pl.string_name;
-	    }
 	    f_print(fout, "\tif (!%s) goto fail1;\n", plist->scode);
 	}
     }
diff --git a/src/rxkad/v5gen.c b/src/rxkad/v5gen.c
index fe8ab6b..eb576fb 100644
--- a/src/rxkad/v5gen.c
+++ b/src/rxkad/v5gen.c
@@ -14,9 +14,8 @@ encode_krb5int32(unsigned char *p, size_t len, const krb5int32 * data, size_t *
 {
     size_t ret = 0;
     size_t l;
-    int i, e;
+    int e;
 
-    i = 0;
     e = der_put_integer(p, len, data, &l);
     if (e)
 	return e;
@@ -117,9 +116,8 @@ encode_Ticket(unsigned char *p, size_t len, const Ticket * data, size_t * size)
 {
     size_t ret = 0;
     size_t l;
-    int i, e;
+    int e;
 
-    i = 0;
 /* enc-part */
     {
 	size_t Top_tag_tag_oldret = ret;
@@ -460,9 +458,8 @@ encode_AuthorizationDataElement(unsigned char *p, size_t len, const Authorizatio
 {
     size_t ret = 0;
     size_t l;
-    int i, e;
+    int e;
 
-    i = 0;
 /* ad-data */
     {
 	size_t Top_tag_oldret = ret;
@@ -691,9 +688,8 @@ encode_EncryptedData(unsigned char *p, size_t len, const EncryptedData * data, s
 {
     size_t ret = 0;
     size_t l;
-    int i, e;
+    int e;
 
-    i = 0;
 /* cipher */
     {
 	size_t Top_tag_oldret = ret;
@@ -1463,9 +1459,8 @@ encode_HostAddress(unsigned char *p, size_t len, const HostAddress * data, size_
 {
     size_t ret = 0;
     size_t l;
-    int i, e;
+    int e;
 
-    i = 0;
 /* address */
     {
 	size_t Top_tag_oldret = ret;
@@ -1890,9 +1885,8 @@ encode_EncTicketPart(unsigned char *p, size_t len, const EncTicketPart * data, s
 {
     size_t ret = 0;
     size_t l;
-    int i, e;
+    int e;
 
-    i = 0;
 /* authorization-data */
     if ((data)->authorization_data) {
 	size_t Top_tag_tag_oldret = ret;
@@ -2692,9 +2686,8 @@ encode_KerberosTime(unsigned char *p, size_t len, const KerberosTime * data, siz
 {
     size_t ret = 0;
     size_t l;
-    int i, e;
+    int e;
 
-    i = 0;
     e = der_put_generalized_time(p, len, data, &l);
     if (e)
 	return e;
@@ -2795,9 +2788,8 @@ encode_TransitedEncoding(unsigned char *p, size_t len, const TransitedEncoding *
 {
     size_t ret = 0;
     size_t l;
-    int i, e;
+    int e;
 
-    i = 0;
 /* contents */
     {
 	size_t Top_tag_oldret = ret;
@@ -3026,9 +3018,8 @@ encode_EncryptionKey(unsigned char *p, size_t len, const EncryptionKey * data, s
 {
     size_t ret = 0;
     size_t l;
-    int i, e;
+    int e;
 
-    i = 0;
 /* keyvalue */
     {
 	size_t Top_tag_oldret = ret;
@@ -3257,9 +3248,8 @@ encode_TicketFlags(unsigned char *p, size_t len, const TicketFlags * data, size_
 {
     size_t ret = 0;
     size_t l;
-    int i, e;
+    int e;
 
-    i = 0;
     {
 	unsigned char c = 0;
 	if (len < 1)
@@ -3519,9 +3509,8 @@ encode_Realm(unsigned char *p, size_t len, const Realm * data, size_t * size)
 {
     size_t ret = 0;
     size_t l;
-    int i, e;
+    int e;
 
-    i = 0;
     e = der_put_general_string(p, len, data, &l);
     if (e)
 	return e;
@@ -3627,9 +3616,8 @@ encode_ENCTYPE(unsigned char *p, size_t len, const ENCTYPE * data, size_t * size
 {
     size_t ret = 0;
     size_t l;
-    int i, e;
+    int e;
 
-    i = 0;
     {
 	int enumint = (int) *data;
 	e = der_put_integer(p, len, &enumint, &l);
@@ -3741,9 +3729,8 @@ encode_NAME_TYPE(unsigned char *p, size_t len, const NAME_TYPE * data, size_t *
 {
     size_t ret = 0;
     size_t l;
-    int i, e;
+    int e;
 
-    i = 0;
     {
 	int enumint = (int) *data;
 	e = der_put_integer(p, len, &enumint, &l);
diff --git a/src/scout/scout.c b/src/scout/scout.c
index 9877ae1..2c2b392 100644
--- a/src/scout/scout.c
+++ b/src/scout/scout.c
@@ -1031,7 +1031,6 @@ mini_PrintDiskStats(struct mini_line *a_srvline,
 {				/*mini_PrintDiskStats */
 
     static char rn[] = "mini_PrintDiskStats";	/*Routine name */
-    int code;			/*Return code */
     char s[128];		/*String buffer */
     struct onode *curr_disklight;	/*Ptr to current disk light */
     struct onode *srvname_light;	/*Ptr to server name light */
@@ -1087,13 +1086,13 @@ mini_PrintDiskStats(struct mini_line *a_srvline,
 			used_disk_idx, diskdata->label);
 		fflush(scout_debugfd);
 	    }
-	    code = mini_justify(" ",	/*Src buffer */
+	    mini_justify(" ",	/*Src buffer */
 				diskdata->label,	/*Dest buffer */
 				scout_col_width[COL_DISK],	/*Dest's width */
 				SCOUT_RIGHT_JUSTIFY,	/*Right-justify */
 				SCOUT_LEFT_TRUNC,	/*Left-truncate */
 				SCOUT_ISNT_LDISK);	/*Not a labeled disk */
-	    code = gator_light_set(curr_disklight, 0);
+	    gator_light_set(curr_disklight, 0);
 	    if (a_fix_line_num) {
 		curr_disklight->o_y += a_delta_line_num;
 		disk_strparams = (struct gwin_strparams *)(diskdata->llrock);
@@ -1199,14 +1198,14 @@ mini_PrintDiskStats(struct mini_line *a_srvline,
 			    rn, s, found_idx, diskdata->label);
 		    fflush(scout_debugfd);
 		}
-		code = mini_justify(s,	/*Src buffer */
+		mini_justify(s,	/*Src buffer */
 				    diskdata->label,	/*Dest buffer */
 				    scout_col_width[COL_DISK],	/*Dest's width */
 				    SCOUT_LEFT_JUSTIFY,	/*Left-justify */
 				    SCOUT_LEFT_TRUNC,	/*Left-truncate */
 				    SCOUT_IS_LDISK);	/*Labeled disk */
 
-		code = gator_light_set(sc_disk->disk_lp, pastthreshold);
+		gator_light_set(sc_disk->disk_lp, pastthreshold);
 
 	    }			/*Found disk record */
 	}
diff --git a/src/tptserver/Makefile.in b/src/tptserver/Makefile.in
index 379dc61..a2f38c5 100644
--- a/src/tptserver/Makefile.in
+++ b/src/tptserver/Makefile.in
@@ -105,11 +105,13 @@ pthread_glock.o: ${UTIL}/pthread_glock.c
 ptserver.o: ${PTSERVER}/ptserver.c ${INCLS}
 	${CCRULE} ${srcdir}/${PTSERVER}/ptserver.c
 
+# When supergroups is enabled, some parts of ptserver cast between
+# # incompatible structs.
 ptutils.o: ${PTSERVER}/ptutils.c ${INCLS}
-	${CCRULE} ${srcdir}/${PTSERVER}/ptutils.c
+	${CCRULE} @CFLAGS_NOSTRICT@ ${srcdir}/${PTSERVER}/ptutils.c
 
 ptprocs.o: ${PTSERVER}/ptprocs.c ${INCLS}
-	${CCRULE} ${srcdir}/${PTSERVER}/ptprocs.c
+	${CCRULE} @CFLAGS_NOSTRICT@ ${srcdir}/${PTSERVER}/ptprocs.c
 
 utils.o: ${PTSERVER}/utils.c ${INCLS}
 	${CCRULE} ${srcdir}/${PTSERVER}/utils.c
diff --git a/src/ubik/recovery.c b/src/ubik/recovery.c
index f0b09ae..b17d054 100644
--- a/src/ubik/recovery.c
+++ b/src/ubik/recovery.c
@@ -453,7 +453,7 @@ urecovery_Interact(void *dummy)
     struct ubik_server *bestServer = NULL;
     struct ubik_server *ts;
     int dbok, doingRPC, now;
-    afs_int32 lastProbeTime, lastDBVCheck;
+    afs_int32 lastProbeTime;
     /* if we're the sync site, the best db version we've found yet */
     static struct ubik_version bestDBVersion;
     struct ubik_version tversion;
@@ -466,14 +466,13 @@ urecovery_Interact(void *dummy)
     char hoststr[16];
 #ifndef OLD_URECOVERY
     char pbuffer[1028];
-    int flen, fd = -1;
+    int fd = -1;
     afs_int32 pass;
 #endif
 
     /* otherwise, begin interaction */
     urecovery_state = 0;
     lastProbeTime = 0;
-    lastDBVCheck = 0;
     while (1) {
 	/* Run through this loop every 4 seconds */
 	tv.tv_sec = 4;
@@ -552,7 +551,6 @@ urecovery_Interact(void *dummy)
 		 */
 		urecovery_state &= ~UBIK_RECHAVEDB;
 	    }
-	    lastDBVCheck = FT_ApproxTime();
 	    urecovery_state |= UBIK_RECFOUNDDB;
 	    urecovery_state &= ~UBIK_RECSENTDB;
 	}
@@ -616,7 +614,6 @@ urecovery_Interact(void *dummy)
 		goto FetchEndCall;
 	    }
 #ifndef OLD_URECOVERY
-	    flen = length;
 	    afs_snprintf(pbuffer, sizeof(pbuffer), "%s.DB%s%d.TMP", ubik_dbase->pathName, (file<0)?"SYS":"", (file<0)?-file:file);
 	    fd = open(pbuffer, O_CREAT | O_RDWR | O_TRUNC, 0600);
 	    if (fd < 0) {
diff --git a/src/ubik/remote.c b/src/ubik/remote.c
index 9fa996d..a669da2 100644
--- a/src/ubik/remote.c
+++ b/src/ubik/remote.c
@@ -487,7 +487,7 @@ SDISK_SendFile(struct rx_call *rxcall, afs_int32 file,
     char hoststr[16];
 #ifndef OLD_URECOVERY
     char pbuffer[1028];
-    int flen, fd = -1;
+    int fd = -1;
     afs_int32 epoch = 0;
     afs_int32 pass;
 #endif
@@ -537,7 +537,6 @@ SDISK_SendFile(struct rx_call *rxcall, afs_int32 file,
     tversion.epoch = 0;		/* start off by labelling in-transit db as invalid */
     (*dbase->setlabel) (dbase, file, &tversion);	/* setlabel does sync */
 #ifndef OLD_URECOVERY
-    flen = length;
     afs_snprintf(pbuffer, sizeof(pbuffer), "%s.DB%s%d.TMP", ubik_dbase->pathName, (file<0)?"SYS":"", (file<0)?-file:file);
     fd = open(pbuffer, O_CREAT | O_RDWR | O_TRUNC, 0600);
     if (fd < 0) {
diff --git a/src/update/server.c b/src/update/server.c
index a7fc60f..7c44ab9 100644
--- a/src/update/server.c
+++ b/src/update/server.c
@@ -249,10 +249,8 @@ main(int argc, char *argv[])
 	  usage:
 	    Quit("Usage: upserver [<directory>+] [-crypt <directory>+] [-clear <directory>+] [-auth <directory>+] [-rxbind] [-help]\n");
 	} else {
-	    int dirlen;
 	    if (nDirs >= sizeof(dirName) / sizeof(dirName[0]))
 		Quit("Too many dirs");
-	    dirlen = strlen(argv[a]);
 	    if (AddObject(&dirName[nDirs], argv[a])) {
 		printf("%s: Unable to export dir %s. Skipping\n", whoami,
 		       argv[a]);
diff --git a/src/uss/uss.c b/src/uss/uss.c
index f551715..1163fc1 100644
--- a/src/uss/uss.c
+++ b/src/uss/uss.c
@@ -1792,7 +1792,6 @@ main(int argc, char *argv[])
 {				/*Main routine */
 
     struct cmd_syndesc *cs;	/*Command line syntax descriptor */
-    afs_int32 code;	/*Return code */
 
 #ifdef	AFS_AIX32_ENV
     /*
@@ -1979,7 +1978,7 @@ main(int argc, char *argv[])
     /*
      * Execute the parsed command.
      */
-    code = cmd_Dispatch(argc, argv);
+    cmd_Dispatch(argc, argv);
 #if 0
     if (code) {
 	fprintf(stderr, "%s: Call to cmd_Dispatch() failed; code is %d\n",
@@ -1988,7 +1987,7 @@ main(int argc, char *argv[])
     }
 #endif /* 0 */
     if (doUnlog) {
-	code = uss_fs_UnlogToken(uss_Cell);
+	uss_fs_UnlogToken(uss_Cell);
     }
     return 0;
 }				/*Main routine */
diff --git a/src/uss/uss_acl.c b/src/uss/uss_acl.c
index 9ed9aeb..30a696e 100644
--- a/src/uss/uss_acl.c
+++ b/src/uss/uss_acl.c
@@ -672,7 +672,6 @@ uss_acl_SetDiskQuota(char *a_path, int a_q)
     static char rn[] = "uss_acl_SetDiskQuota";
 #endif
     uss_VolumeStatus_t *status;
-    char *name, *motd, *offmsg;
     char *input;
     char tmp_str[AFS_PIOCTL_MAXSIZE];
 
@@ -683,7 +682,6 @@ uss_acl_SetDiskQuota(char *a_path, int a_q)
 
     status = (uss_VolumeStatus_t *) tmp_str;
     status->MinQuota = status->MaxQuota = -1;
-    name = motd = offmsg = NULL;
     status->MaxQuota = a_q;
 
     input = (char *)status + sizeof(*status);
diff --git a/src/venus/fs.c b/src/venus/fs.c
index 31b2f56..5ffa27b 100644
--- a/src/venus/fs.c
+++ b/src/venus/fs.c
@@ -2367,10 +2367,8 @@ CallBackRxConnCmd(struct cmd_syndesc *as, void *arock)
     struct cmd_item *ti;
     afs_int32 hostAddr;
     struct hostent *thp;
-    int setp;
 
     ti = as->parms[0].items;
-    setp = 1;
     if (ti) {
         thp = hostutil_GetHostByName(ti->data);
 	if (!thp) {
@@ -2380,7 +2378,6 @@ CallBackRxConnCmd(struct cmd_syndesc *as, void *arock)
 	else memcpy(&hostAddr, thp->h_addr, sizeof(afs_int32));
     } else {
         hostAddr = 0;   /* means don't set host */
-	setp = 0;       /* aren't setting host */
     }
 
     /* now do operation */
@@ -2751,7 +2748,7 @@ ExportAfsCmd(struct cmd_syndesc *as, void *arock)
     afs_int32 code;
     struct ViceIoctl blob;
     struct cmd_item *ti;
-    int export = 0, type = 0, mode = 0, exp = 0, exportcall, pwsync =
+    int export = 0, type = 0, mode = 0, exportcall, pwsync =
 	0, smounts = 0, clipags = 0, pagcb = 0;
 
     ti = as->parms[0].items;
@@ -2773,7 +2770,6 @@ ExportAfsCmd(struct cmd_syndesc *as, void *arock)
 	    fprintf(stderr, "Illegal argument %s\n", ti->data);
 	    return 1;
 	}
-	exp = 1;
     }
     if ((ti = as->parms[2].items)) {	/* -noconvert */
 	if (strcmp(ti->data, "on") == 0)
@@ -3305,6 +3301,7 @@ StoreBehindCmd(struct cmd_syndesc *as, void *arock)
     afs_int32 allfiles;
     char *t;
     int error = 0;
+    int async_default = -1;
 
     tsb.sb_thisfile = -1;
     ti = as->parms[0].items;	/* -kbytes */
@@ -3365,14 +3362,18 @@ StoreBehindCmd(struct cmd_syndesc *as, void *arock)
 	    continue;
 	}
 
-	if (verbose && (blob.out_size == sizeof(tsb2))) {
-	    if (tsb2.sb_thisfile == -1) {
-		fprintf(stdout, "Will store %s according to default.\n",
-			ti->data);
+	if (blob.out_size == sizeof(tsb2)) {
+	    async_default = tsb2.sb_default;
+
+	    if (verbose) {
+		if (tsb2.sb_thisfile == -1) {
+		    fprintf(stdout, "Will store %s according to default.\n",
+			    ti->data);
 	    } else {
-		fprintf(stdout,
-			"Will store up to %d kbytes of %s asynchronously.\n",
-			(tsb2.sb_thisfile / 1024), ti->data);
+		    fprintf(stdout,
+			    "Will store up to %d kbytes of %s asynchronously.\n",
+			    (tsb2.sb_thisfile / 1024), ti->data);
+		}
 	    }
 	}
     }
@@ -3380,7 +3381,7 @@ StoreBehindCmd(struct cmd_syndesc *as, void *arock)
     /* If no files - make at least one pioctl call, or
      * set the allfiles default if we need to.
      */
-    if (!as->parms[1].items || (allfiles != -1)) {
+    if (async_default < 0 || (allfiles != -1)) {
 	tsb.sb_default = allfiles;
         memset(&tsb2, 0, sizeof(tsb2));
 	blob.out = (char *)&tsb2;
@@ -3389,13 +3390,16 @@ StoreBehindCmd(struct cmd_syndesc *as, void *arock)
 	if (code) {
 	    Die(errno, ((allfiles == -1) ? 0 : "-allfiles"));
 	    error = 1;
+
+	} else if (blob.out_size == sizeof(tsb2)) {
+	    async_default = tsb2.sb_default;
 	}
     }
 
     /* Having no arguments also reports the default store asynchrony */
-    if (!error && verbose && (blob.out_size == sizeof(tsb2))) {
+    if (async_default >= 0 && verbose) {
 	fprintf(stdout, "Default store asynchrony is %d kbytes.\n",
-		(tsb2.sb_default / 1024));
+		(async_default / 1024));
     }
 
     return error;
@@ -4075,12 +4079,10 @@ FlushMountCmd(struct cmd_syndesc *as, void *arock)
     char *last_component;	/*Last component of true name */
     struct stat statbuff;	/*Buffer for status info */
     int link_chars_read;	/*Num chars read in readlink() */
-    int thru_symlink;		/*Did we get to a mount point via a symlink? */
     int error = 0;
 
     for (ti = as->parms[0].items; ti; ti = ti->next) {
 	/* once per file */
-	thru_symlink = 0;
 	sprintf(orig_name, "%s%s", (ti->data[0] == '/') ? "" : "./",
 		ti->data);
 
@@ -4096,7 +4098,6 @@ FlushMountCmd(struct cmd_syndesc *as, void *arock)
 	 * the file name with the link name.
 	 */
 	if ((statbuff.st_mode & S_IFMT) == S_IFLNK) {
-	    thru_symlink = 1;
 	    /*
 	     * Read name of resolved file.
 	     */
diff --git a/src/viced/afsfileprocs.c b/src/viced/afsfileprocs.c
index 17224b9..cf0dd0b 100644
--- a/src/viced/afsfileprocs.c
+++ b/src/viced/afsfileprocs.c
@@ -1247,7 +1247,7 @@ RXStore_AccessList(Vnode * targetptr, struct AFSOpaque *AccessList)
 static int
 CopyOnWrite(Vnode * targetptr, Volume * volptr, afs_foff_t off, afs_fsize_t len)
 {
-    Inode ino, nearInode;
+    Inode ino, nearInode AFS_UNUSED;
     ssize_t rdlen;
     ssize_t wrlen;
     afs_fsize_t size;
@@ -1347,7 +1347,7 @@ CopyOnWrite(Vnode * targetptr, Volume * volptr, afs_foff_t off, afs_fsize_t len)
 		IH_RELEASE(newH);
 		FDH_REALLYCLOSE(targFdP);
 		rc = IH_DEC(V_linkHandle(volptr), ino, V_parentId(volptr));
-		if (!rc) {
+		if (rc) {
 		    ViceLog(0,
 			    ("CopyOnWrite failed: error %u after i_dec on disk full, volume %u in partition %s needs salvage\n",
 			     rc, V_id(volptr), volptr->partition->name));
@@ -1824,7 +1824,7 @@ Alloc_NewVnode(Vnode * parentptr, DirHandle * dir, Volume * volptr,
     Error errorCode = 0;		/* Error code returned back */
     Error temp;
     Inode inode = 0;
-    Inode nearInode;		/* hint for inode allocation in solaris */
+    Inode nearInode AFS_UNUSED;		/* hint for inode allocation in solaris */
     afs_ino_str_t stmp;
 
     if ((errorCode =
@@ -2045,8 +2045,8 @@ RXGetVolumeStatus(AFSFetchVolumeStatus * status, char **name, char **offMsg,
     status->MinQuota = V_minquota(volptr);
     status->MaxQuota = V_maxquota(volptr);
     status->BlocksInUse = V_diskused(volptr);
-    status->PartBlocksAvail = RoundInt64ToInt32(volptr->partition->free);
-    status->PartMaxBlocks = RoundInt64ToInt32(volptr->partition->totalUsable);
+    status->PartBlocksAvail = RoundInt64ToInt31(volptr->partition->free);
+    status->PartMaxBlocks = RoundInt64ToInt31(volptr->partition->totalUsable);
 
     /* now allocate and copy these things; they're freed by the RXGEN stub */
     temp = strlen(V_name(volptr)) + 1;
@@ -5741,8 +5741,8 @@ SetVolumeStats(struct AFSStatistics *stats)
 
     for (part = DiskPartitionList; part && i < AFS_MSTATDISKS;
 	 part = part->next) {
-	stats->Disks[i].TotalBlocks = RoundInt64ToInt32(part->totalUsable);
-	stats->Disks[i].BlocksAvailable = RoundInt64ToInt32(part->free);
+	stats->Disks[i].TotalBlocks = RoundInt64ToInt31(part->totalUsable);
+	stats->Disks[i].BlocksAvailable = RoundInt64ToInt31(part->free);
 	memset(stats->Disks[i].Name, 0, AFS_DISKNAMESIZE);
 	strncpy(stats->Disks[i].Name, part->name, AFS_DISKNAMESIZE);
 	i++;
@@ -6019,7 +6019,7 @@ SRXAFS_XStatsVersion(struct rx_call * a_call, afs_int32 * a_versionP)
 static void
 FillPerfValues(struct afs_PerfStats *a_perfP)
 {				/*FillPerfValues */
-    afs_uint32 hi, lo;
+    afs_uint32 hi AFS_UNUSED, lo;
     int dir_Buffers;		/*# buffers in use by dir package */
     int dir_Calls;		/*# read calls in dir package */
     int dir_IOs;		/*# I/O ops in dir package */
diff --git a/src/vlserver/vldb_check.c b/src/vlserver/vldb_check.c
index 01645ae..64b1ca7 100644
--- a/src/vlserver/vldb_check.c
+++ b/src/vlserver/vldb_check.c
@@ -87,6 +87,14 @@ struct er {
 } *record;
 afs_int32 maxentries;
 int serveraddrs[MAXSERVERID + 2];
+u_char serverxref[MAXSERVERID + 2];  /**< to resolve cross-linked mh entries */
+int serverref[MAXSERVERID + 2];      /**< which addrs are referenced by vl entries */
+
+struct mhinfo {
+    afs_uint32 addr;			/**< vldb file record */
+    char orphan[VL_MHSRV_PERBLK];	/**< unreferenced mh enties */
+} mhinfo[VL_MAX_ADDREXTBLKS];
+
 
 /*  Used to control what goes to stdout based on quiet flag */
 void
@@ -277,7 +285,7 @@ readheader(struct vlheader *headerp)
 	    ntohl(headerp->vital_header.totalEntries[1]);
 
     headerp->SIT = ntohl(headerp->SIT);
-    for (i = 0; i < MAXSERVERID; i++)
+    for (i = 0; i <= MAXSERVERID; i++)
 	headerp->IpMappedAddr[i] = ntohl(headerp->IpMappedAddr[i]);
     for (i = 0; i < HASHSIZE; i++)
 	headerp->VolnameHash[i] = ntohl(headerp->VolnameHash[i]);
@@ -341,7 +349,7 @@ writeheader(struct vlheader *headerp)
 	    htonl(headerp->vital_header.totalEntries[1]);
 
     headerp->SIT = htonl(headerp->SIT);
-    for (i = 0; i < MAXSERVERID; i++)
+    for (i = 0; i <= MAXSERVERID; i++)
 	headerp->IpMappedAddr[i] = htonl(headerp->IpMappedAddr[i]);
     for (i = 0; i < HASHSIZE; i++)
 	headerp->VolnameHash[i] = htonl(headerp->VolnameHash[i]);
@@ -353,18 +361,20 @@ writeheader(struct vlheader *headerp)
 }
 
 void
-readMH(afs_int32 addr, struct extentaddr *mhblockP)
+readMH(afs_uint32 addr, int block, struct extentaddr *mhblockP)
 {
     int i, j;
     struct extentaddr *e;
 
     vldbread(addr, (char *)mhblockP, VL_ADDREXTBLK_SIZE);
 
-    mhblockP->ex_count = ntohl(mhblockP->ex_count);
-    mhblockP->ex_flags = ntohl(mhblockP->ex_flags);
-    for (i = 0; i < VL_MAX_ADDREXTBLKS; i++)
-	mhblockP->ex_contaddrs[i] = ntohl(mhblockP->ex_contaddrs[i]);
-
+    if (block == 0) {
+        mhblockP->ex_count = ntohl(mhblockP->ex_count);
+        mhblockP->ex_flags = ntohl(mhblockP->ex_flags);
+        for (i = 0; i < VL_MAX_ADDREXTBLKS; i++) {
+	    mhblockP->ex_contaddrs[i] = ntohl(mhblockP->ex_contaddrs[i]);
+        }
+    }
     for (i = 1; i < VL_MHSRV_PERBLK; i++) {
 	e = &(mhblockP[i]);
 
@@ -469,6 +479,33 @@ readentry(afs_int32 addr, struct nvlentry *vlentryp, afs_int32 *type)
 }
 
 void
+writeMH(afs_int32 addr, int block, struct extentaddr *mhblockP)
+{
+    int i, j;
+    struct extentaddr *e;
+
+    if (verbose) {
+	quiet_println("Writing back MH block % at addr %u\n", block,  addr);
+    }
+    if (block == 0) {
+	mhblockP->ex_count = htonl(mhblockP->ex_count);
+	mhblockP->ex_flags = htonl(mhblockP->ex_flags);
+	for (i = 0; i < VL_MAX_ADDREXTBLKS; i++) {
+	    mhblockP->ex_contaddrs[i] = htonl(mhblockP->ex_contaddrs[i]);
+	}
+    }
+    for (i = 1; i < VL_MHSRV_PERBLK; i++) {
+	e = &(mhblockP[i]);
+	/* hostuuid was not converted */
+	e->ex_uniquifier = htonl(e->ex_uniquifier);
+	for (j = 0; j < VL_MAXIPADDRS_PERMH; j++) {
+	    e->ex_addrs[j] = htonl(e->ex_addrs[j]);
+	}
+    }
+    vldbwrite(addr, (char *)mhblockP, VL_ADDREXTBLK_SIZE);
+}
+
+void
 writeentry(afs_int32 addr, struct nvlentry *vlentryp)
 {
     int i;
@@ -890,7 +927,6 @@ CheckIpAddrs(struct vlheader *header)
     int mhblocks = 0;
     afs_int32 i, j, m, rindex;
     afs_int32 mhentries, regentries;
-    afs_uint32 caddrs[VL_MAX_ADDREXTBLKS];
     char mhblock[VL_ADDREXTBLK_SIZE];
     struct extentaddr *MHblock = (struct extentaddr *)mhblock;
     struct extentaddr *e;
@@ -906,7 +942,7 @@ CheckIpAddrs(struct vlheader *header)
 	/* Read the first MH block and from it, gather the
 	 * addresses of all the mh blocks.
 	 */
-	readMH(header->SIT, MHblock);
+	readMH(header->SIT, 0, MHblock);
 	if (MHblock->ex_flags != VLCONTBLOCK) {
 	   log_error
 		(VLDB_CHECK_ERROR,"Multihomed Block 0: Bad entry at %u: Not a valid multihomed block\n",
@@ -914,32 +950,32 @@ CheckIpAddrs(struct vlheader *header)
 	}
 
 	for (i = 0; i < VL_MAX_ADDREXTBLKS; i++) {
-	    caddrs[i] = MHblock->ex_contaddrs[i];
+	    mhinfo[i].addr = MHblock->ex_contaddrs[i];
 	}
 
-	if (header->SIT != caddrs[0]) {
+	if (header->SIT != mhinfo[0].addr) {
 	   log_error
 		(VLDB_CHECK_ERROR,"MH block does not point to self %u in header, %u in block\n",
-		 header->SIT, caddrs[0]);
+		 header->SIT, mhinfo[0].addr);
 	}
 
 	/* Now read each MH block and record it in the record array */
 	for (i = 0; i < VL_MAX_ADDREXTBLKS; i++) {
-	    if (!caddrs[i])
+	    if (!mhinfo[i].addr)
 		continue;
 
-	    readMH(caddrs[i], MHblock);
+	    readMH(mhinfo[i].addr, i, MHblock);
 	    if (MHblock->ex_flags != VLCONTBLOCK) {
 	        log_error
 		    (VLDB_CHECK_ERROR,"Multihomed Block 0: Bad entry at %u: Not a valid multihomed block\n",
 		     header->SIT);
 	    }
 
-	    rindex = caddrs[i] / sizeof(vlentry);
-	    if (record[rindex].addr != caddrs[i] && record[rindex].addr) {
+	    rindex = mhinfo[i].addr / sizeof(vlentry);
+	    if (record[rindex].addr != mhinfo[i].addr && record[rindex].addr) {
 	        log_error
 		    (VLDB_CHECK_ERROR,"INTERNAL VLDB_CHECK_ERROR: addresses %u and %u use same record slot %d\n",
-		     record[rindex].addr, caddrs[i], rindex);
+		     record[rindex].addr, mhinfo[i].addr, rindex);
 	    }
 	    if (record[rindex].type & FRC) {
 	        log_error
@@ -957,23 +993,24 @@ CheckIpAddrs(struct vlheader *header)
 	     */
 	    mhentries = 0;
 	    for (j = 1; j < VL_MHSRV_PERBLK; j++) {
+		int first_ipindex = -1;
 		e = (struct extentaddr *)&(MHblock[j]);
 
-		/* Search the IpMappedAddr array for the reference to this entry */
-		for (ipindex = 0; ipindex < MAXSERVERID; ipindex++) {
-		    if (((header->IpMappedAddr[ipindex] & 0xff000000) ==
-			 0xff000000)
-			&&
-			(((header->
-			   IpMappedAddr[ipindex] & 0x00ff0000) >> 16) == i)
-			&& ((header->IpMappedAddr[ipindex] & 0x0000ffff) ==
-			    j)) {
-			break;
+		/* Search the IpMappedAddr array for all the references to this entry. */
+		/* Use the first reference for checking the ip addresses of this entry. */
+		for (ipindex = 0; ipindex <= MAXSERVERID; ipindex++) {
+		    if (((header->IpMappedAddr[ipindex] & 0xff000000) == 0xff000000)
+			&& (((header-> IpMappedAddr[ipindex] & 0x00ff0000) >> 16) == i)
+			&& ((header->IpMappedAddr[ipindex] & 0x0000ffff) == j)) {
+			if (first_ipindex == -1) {
+			    first_ipindex = ipindex;
+			} else {
+			    serverxref[ipindex] = first_ipindex;
+			}
 		    }
 		}
-		if (ipindex >= MAXSERVERID)
-		    ipindex = -1;
-		else
+		ipindex = first_ipindex;
+		if (ipindex != -1)
 		    serveraddrs[ipindex] = -1;
 
 		if (memcmp(&e->ex_hostuuid, &nulluuid, sizeof(afsUUID)) == 0) {
@@ -997,6 +1034,7 @@ CheckIpAddrs(struct vlheader *header)
 		if (ipaddrs) {
 		    mhentries++;
 		    if (ipindex == -1) {
+		        mhinfo[i].orphan[j] = 1;
 		        log_error
 			    (VLDB_CHECK_ERROR,"MH block %d, index %d: Not referenced by server addrs\n",
 			     i, j);
@@ -1043,6 +1081,9 @@ CheckIpAddrs(struct vlheader *header)
 		   log_error
 			(VLDB_CHECK_ERROR,"IP Addr for entry %d: Multihome block is bad (%d)\n",
 			 i, ((header->IpMappedAddr[i] & 0x00ff0000) >> 16));
+		if (mhinfo[(header->IpMappedAddr[i] & 0x00ff0000) >> 16].addr == 0)
+		    log_error(VLDB_CHECK_ERROR,"IP Addr for entry %d: No such multihome block (%d)\n",
+			 i, ((header->IpMappedAddr[i] & 0x00ff0000) >> 16));
 		if (((header->IpMappedAddr[i] & 0x0000ffff) > VL_MHSRV_PERBLK)
 		    || ((header->IpMappedAddr[i] & 0x0000ffff) < 1))
 		    log_error
@@ -1054,6 +1095,17 @@ CheckIpAddrs(struct vlheader *header)
 			 i);
 		    serveraddrs[i] = 0;
 		}
+		if (serverxref[i] != BADSERVERID) {
+		    log_error
+			(VLDB_CHECK_WARNING,
+			"warning: MH block %d, index %d is cross-linked by server numbers %d and %d.\n",
+			(header->IpMappedAddr[i] & 0x00ff0000) >> 16,
+			(header->IpMappedAddr[i] & 0x0000ffff),
+			i, serverxref[i]);
+		    /* set addresses found/not found for this server number,
+		     * using the first index to the mh we found above. */
+		    serveraddrs[i] = serveraddrs[serverxref[i]];
+		}
 		if (listservers) {
 		    quiet_println("   Server ip addr %d = MH block %d, index %d\n",
 			   i, (header->IpMappedAddr[i] & 0x00ff0000) >> 16,
@@ -1147,6 +1199,47 @@ reportHashChanges(struct vlheader *header, afs_uint32 oldnamehash[HASHSIZE], afs
     }
 }
 
+/**
+ * Remove unreferenced, duplicate multi-home address indices.
+ *
+ * Removes entries from IpMappedAddr which where found to be
+ * duplicates. Only entries which are not referenced by vl entries
+ * are removed on this pass.
+ *
+ * @param[inout] header the vldb header to be updated.
+ */
+void
+removeCrossLinkedAddresses(struct vlheader *header)
+{
+    int i;
+
+    for (i = 0; i <= MAXSERVERID; i++) {
+	if (serverref[i] == 0
+	    && (header->IpMappedAddr[i] & 0xff000000) == 0xff000000
+	    && serverxref[i] != BADSERVERID) {
+	    if (serverxref[i] == i) {
+		log_error(VLDB_CHECK_ERROR,
+			  "INTERNAL VLDB_CHECK_ERROR: serverxref points to self; index %d\n",
+			  i);
+	    } else if (header->IpMappedAddr[serverxref[i]] == 0) {
+		log_error(VLDB_CHECK_ERROR,
+			  "INTERNAL VLDB_CHECK_ERROR: serverxref points to empty addr; index %d, value %d\n",
+			  i, serverxref[i]);
+	    } else if (header->IpMappedAddr[serverxref[i]] != header->IpMappedAddr[i]) {
+		log_error(VLDB_CHECK_ERROR,
+			  "INTERNAL VLDB_CHECK_ERROR: invalid serverxref; index %d, value %d\n",
+			  i, serverxref[i]);
+	    } else {
+		quiet_println
+		    ("FIX: Removing unreferenced address index %d, which cross-links MH block %d, index %d\n",
+		     i, (header->IpMappedAddr[i] & 0x00ff0000) >> 16,
+		     (header->IpMappedAddr[i] & 0x0000ffff));
+		header->IpMappedAddr[i] = 0;
+	    }
+	}
+    }
+}
+
 int
 WorkerBee(struct cmd_syndesc *as, void *arock)
 {
@@ -1154,7 +1247,7 @@ WorkerBee(struct cmd_syndesc *as, void *arock)
     afs_int32 type;
     struct vlheader header;
     struct nvlentry vlentry, vlentry2;
-    int i, j;
+    int i, j, k;
     afs_uint32 oldnamehash[HASHSIZE];
     afs_uint32 oldidhash[MAXTYPES][HASHSIZE];
 
@@ -1195,6 +1288,11 @@ WorkerBee(struct cmd_syndesc *as, void *arock)
     record = (struct er *)malloc(maxentries * sizeof(struct er));
     memset(record, 0, (maxentries * sizeof(struct er)));
     memset(serveraddrs, 0, sizeof(serveraddrs));
+    memset(mhinfo, 0, sizeof(mhinfo));
+    memset(serverref, 0, sizeof(serverref));
+    for (i = 0; i <= MAXSERVERID; i++) {
+	serverxref[i] = BADSERVERID;
+    }
 
     /* Will fill in the record array of entries it found */
     ReadAllEntries(&header);
@@ -1337,11 +1435,17 @@ WorkerBee(struct cmd_syndesc *as, void *arock)
 	    }
 
 	    for (j = 0; j < NMAXNSERVERS; j++) {
-		if ((vlentry.serverNumber[j] != 255)
-		    && (serveraddrs[vlentry.serverNumber[j]] == 0)) {
-		   log_error
-			(VLDB_CHECK_ERROR,"Volume '%s', index %d points to empty server entry %d\n",
-			 vlentry.name, j, vlentry.serverNumber[j]);
+		if (vlentry.serverNumber[j] != BADSERVERID) {
+		    serverref[vlentry.serverNumber[j]] = 1;
+		    if (serveraddrs[vlentry.serverNumber[j]] == 0) {
+			log_error
+			    (VLDB_CHECK_ERROR,"Volume '%s', index %d points to empty server entry %d\n",
+			     vlentry.name, j, vlentry.serverNumber[j]);
+		    } else if (serverxref[vlentry.serverNumber[j]] != BADSERVERID) {
+			    log_error
+			    (VLDB_CHECK_ERROR,"Volume '%s', index %d points to server entry %d, which is cross-linked by %d\n",
+			     vlentry.name, j, vlentry.serverNumber[j], serverxref[vlentry.serverNumber[j]]);
+		    }
 		}
 	    }
 
@@ -1462,15 +1566,70 @@ WorkerBee(struct cmd_syndesc *as, void *arock)
 			}
 		    }
 
+		    /* Consolidate server numbers which point to the same mh entry.
+		     * The serverref flags are not reset here, since we want to make
+		     * sure the data is actually written before the server number is
+		     * considered unreferenced. */
+		    for (k = 0; k < NMAXNSERVERS; k++) {
+			if (vlentry.serverNumber[k] != BADSERVERID
+			    && serverxref[vlentry.serverNumber[k]] != BADSERVERID) {
+			    u_char oldsn = vlentry.serverNumber[k];
+			    u_char newsn = serverxref[oldsn];
+			    if (newsn == oldsn) {
+				log_error(VLDB_CHECK_ERROR,
+					  "INTERNAL VLDB_CHECK_ERROR: serverxref points to self; index %d\n",
+					  oldsn);
+			    } else if (header.IpMappedAddr[oldsn] == 0) {
+				log_error(VLDB_CHECK_ERROR,
+					  "INTERNAL VLDB_CHECK_ERROR: serverxref; points to empty address; index %d, value %d\n",
+					  oldsn, newsn);
+			    } else if (header.IpMappedAddr[newsn] != header.IpMappedAddr[oldsn]) {
+				log_error(VLDB_CHECK_ERROR,
+					  "INTERNAL VLDB_CHECK_ERROR: invalid serverxref; index %d\n",
+					  oldsn);
+			    } else {
+				quiet_println
+				    ("FIX: Volume '%s', index %d, server number was %d, is now %d\n",
+				     vlentry.name, k, oldsn, newsn);
+				vlentry.serverNumber[k] = newsn;
+			    }
+			}
+		    }
+
 		    vlentry.nextIdHash[j] = header.VolidHash[j][hash];
 		    header.VolidHash[j][hash] = record[i].addr;
 		}
 		writeentry(record[i].addr, &vlentry);
 	    }
 	}
+	else if (record[i].type & MH) {
+	    int block, index;
+	    char mhblock[VL_ADDREXTBLK_SIZE];
+	    struct extentaddr *MHblock = (struct extentaddr *)mhblock;
+
+	    if (fix) {
+		for (block = 0; block < VL_MAX_ADDREXTBLKS; block++) {
+		    if (mhinfo[block].addr == record[i].addr)
+			break;
+		}
+		if (block == VL_MAX_ADDREXTBLKS) {
+		    continue;  /* skip orphaned extent block */
+		}
+		readMH(record[i].addr, block, MHblock);
+		for (index = 0; index < VL_MHSRV_PERBLK; index++) {
+		    if (mhinfo[block].orphan[index]) {
+			quiet_println("FIX: Removing unreferenced mh entry; block %d, index %d\n",
+				block, index);
+			memset(&(MHblock[index]), 0, sizeof(struct extentaddr));
+		    }
+		}
+		writeMH(record[i].addr, block, MHblock);
+	    }
+	}
     }
     if (fix) {
 	reportHashChanges(&header, oldnamehash, oldidhash);
+	removeCrossLinkedAddresses(&header);
 	writeheader(&header);
     }
 
diff --git a/src/vlserver/vlprocs.c b/src/vlserver/vlprocs.c
index 9053fcd..3a53a25 100644
--- a/src/vlserver/vlprocs.c
+++ b/src/vlserver/vlprocs.c
@@ -2011,7 +2011,16 @@ SVL_GetAddrs(struct rx_call *rxcall,
     return (ubik_EndTrans(trans));
 }
 
-#define PADDR(addr) VLog(0,("%d.%d.%d.%d", (addr>>24)&0xff, (addr>>16)&0xff, (addr>>8) &0xff, addr&0xff));
+static_inline void
+append_addr(char *buffer, afs_uint32 addr, size_t buffer_size)
+{
+    int n = strlen(buffer);
+    if (buffer_size > n) {
+	snprintf(buffer + n, buffer_size - n, "%u.%u.%u.%u",
+		 (addr >> 24) & 0xff, (addr >> 16) & 0xff, (addr >> 8) & 0xff,
+		 addr & 0xff);
+    }
+}
 
 afs_int32
 SVL_RegisterAddrs(struct rx_call *rxcall, afsUUID *uuidp, afs_int32 spare1,
@@ -2021,6 +2030,7 @@ SVL_RegisterAddrs(struct rx_call *rxcall, afsUUID *uuidp, afs_int32 spare1,
     struct ubik_trans *trans;
     int cnt, h, i, j, k, m, base, index;
     struct extentaddr *exp = 0, *tex;
+    char addrbuf[256];
     afsUUID tuuid;
     afs_uint32 addrs[VL_MAXIPADDRS_PERMH];
     afs_int32 fbase;
@@ -2144,29 +2154,27 @@ SVL_RegisterAddrs(struct rx_call *rxcall, afsUUID *uuidp, afs_int32 spare1,
 	|| (!foundUuidEntry && (count > 1))) {
 	VLog(0,
 	     ("The following fileserver is being registered in the VLDB:\n"));
-	VLog(0, ("      ["));
-	for (k = 0; k < cnt; k++) {
+	for (addrbuf[0] = '\0', k = 0; k < cnt; k++) {
 	    if (k > 0)
-		VLog(0,(" "));
-	    PADDR(addrs[k]);
+		strlcat(addrbuf, " ", sizeof(addrbuf));
+	    append_addr(addrbuf, addrs[k], sizeof(addrbuf));
 	}
-	VLog(0,("]\n"));
+	VLog(0, ("      [%s]\n", addrbuf));
 
 	if (foundUuidEntry) {
 	    VLog(0,
 		 ("   It would have replaced the existing VLDB server entry:\n"));
-	    VLog(0, ("      entry %d: [", FoundUuid));
 	    base = (HostAddress[FoundUuid] >> 16) & 0xff;
 	    index = HostAddress[FoundUuid] & 0x0000ffff;
 	    exp = &ex_addr[base][index];
-	    for (mhidx = 0; mhidx < VL_MAXIPADDRS_PERMH; mhidx++) {
+	    for (addrbuf[0] = '\0', mhidx = 0; mhidx < VL_MAXIPADDRS_PERMH; mhidx++) {
 		if (!exp->ex_addrs[mhidx])
 		    continue;
 		if (mhidx > 0)
-		    VLog(0,(" "));
-		PADDR(ntohl(exp->ex_addrs[mhidx]));
+		    strlcat(addrbuf, " ", sizeof(addrbuf));
+		append_addr(addrbuf, ntohl(exp->ex_addrs[mhidx]), sizeof(addrbuf));
 	    }
-	    VLog(0, ("]\n"));
+	    VLog(0, ("      entry %d: [%s]\n", FoundUuid, addrbuf));
 	}
 
 	if (count == 1)
@@ -2175,9 +2183,9 @@ SVL_RegisterAddrs(struct rx_call *rxcall, afsUUID *uuidp, afs_int32 spare1,
 	    VLog(0, ("   Yet other VLDB server entries exist:\n"));
 	for (j = 0; j < count; j++) {
 	    srvidx = WillChange[j];
-	    VLog(0, ("      entry %d: ", srvidx));
+	    addrbuf[0] = '\0';
 	    if ((HostAddress[srvidx] & 0xff000000) == 0xff000000) {
-		VLog(0, ("["));
+		strlcat(addrbuf, "[", sizeof(addrbuf));
 		base = (HostAddress[srvidx] >> 16) & 0xff;
 		index = HostAddress[srvidx] & 0x0000ffff;
 		exp = &ex_addr[base][index];
@@ -2185,14 +2193,14 @@ SVL_RegisterAddrs(struct rx_call *rxcall, afsUUID *uuidp, afs_int32 spare1,
 		    if (!exp->ex_addrs[mhidx])
 			continue;
 		    if (mhidx > 0)
-			VLog(0, (" "));
-		    PADDR(ntohl(exp->ex_addrs[mhidx]));
+			strlcat(addrbuf, " ", sizeof(addrbuf));
+		    append_addr(addrbuf, ntohl(exp->ex_addrs[mhidx]), sizeof(addrbuf));
 		}
-		VLog(0, ("]"));
+		strlcat(addrbuf, "]", sizeof(addrbuf));
 	    } else {
-		PADDR(HostAddress[srvidx]);
+		append_addr(addrbuf, HostAddress[srvidx], sizeof(addrbuf));
 	    }
-	    VLog(0, ("\n"));
+	    VLog(0, ("      entry %d: %s\n", srvidx, addrbuf));
 	}
 
 	if (count == 1)
@@ -2235,26 +2243,24 @@ SVL_RegisterAddrs(struct rx_call *rxcall, afsUUID *uuidp, afs_int32 spare1,
     }
 
     VLog(0, ("The following fileserver is being registered in the VLDB:\n"));
-    VLog(0, ("      ["));
-    for (k = 0; k < cnt; k++) {
+    for (addrbuf[0] = '\0', k = 0; k < cnt; k++) {
 	if (k > 0)
-	    VLog(0, (" "));
-	PADDR(addrs[k]);
+	    strlcat(addrbuf, " ", sizeof(addrbuf));
+	append_addr(addrbuf, addrs[k], sizeof(addrbuf));
     }
-    VLog(0, ("]\n"));
+    VLog(0, ("      [%s]\n", addrbuf));
 
     if (foundUuidEntry) {
 	VLog(0,
 	    ("   It will replace the following existing entry in the VLDB (same uuid):\n"));
-	VLog(0, ("      entry %d: [", FoundUuid));
-	for (k = 0; k < VL_MAXIPADDRS_PERMH; k++) {
+	for (addrbuf[0] = '\0', k = 0; k < VL_MAXIPADDRS_PERMH; k++) {
 	    if (exp->ex_addrs[k] == 0)
 		continue;
 	    if (k > 0)
-		VLog(0, (" "));
-	    PADDR(ntohl(exp->ex_addrs[k]));
+		strlcat(addrbuf, " ", sizeof(addrbuf));
+	    append_addr(addrbuf, ntohl(exp->ex_addrs[k]), sizeof(addrbuf));
 	}
-	VLog(0, ("]\n"));
+	VLog(0, ("      entry %d: [%s]\n", FoundUuid, addrbuf));
     } else if (willReplaceCnt || (count == 1)) {
 	/* If we are not replacing an entry and there is only one entry to change,
 	 * then we will replace that entry.
@@ -2272,22 +2278,21 @@ SVL_RegisterAddrs(struct rx_call *rxcall, afsUUID *uuidp, afs_int32 spare1,
 
 	    VLog(0,
 		("   It will replace the following existing entry in the VLDB (new uuid):\n"));
-	    VLog(0, ("      entry %d: [", ReplaceEntry));
-	    for (k = 0; k < VL_MAXIPADDRS_PERMH; k++) {
+	    for (addrbuf[0] = '\0', k = 0; k < VL_MAXIPADDRS_PERMH; k++) {
 		if (exp->ex_addrs[k] == 0)
 		    continue;
 		if (k > 0)
-		    VLog(0, (" "));
-		PADDR(ntohl(exp->ex_addrs[k]));
+		    strlcat(addrbuf, " ", sizeof(addrbuf));
+		append_addr(addrbuf, ntohl(exp->ex_addrs[k]), sizeof(addrbuf));
 	    }
-	    VLog(0, ("]\n"));
+	    VLog(0, ("      entry %d: [%s]", ReplaceEntry, addrbuf));
 	} else {
 	    /* Not a mh entry. So we have to create a new mh entry and
 	     * put it on the ReplaceEntry slot of the HostAddress array.
 	     */
-	    VLog(0, ("   It will replace existing entry %d, ", ReplaceEntry));
-	    PADDR(HostAddress[ReplaceEntry]);
-	    VLog(0,(", in the VLDB (new uuid):\n"));
+	    addrbuf[0] = '\0';
+	    append_addr(addrbuf, HostAddress[ReplaceEntry], sizeof(addrbuf));
+	    VLog(0, ("   It will replace existing entry %d, [%s], in the VLDB (new uuid):\n", ReplaceEntry, addrbuf));
 
 	    code =
 		FindExtentBlock(trans, uuidp, 1, ReplaceEntry, &exp, &fbase);
@@ -2351,12 +2356,11 @@ SVL_RegisterAddrs(struct rx_call *rxcall, afsUUID *uuidp, afs_int32 spare1,
 	    VLog(0,
 		("   The following existing entries in the VLDB will be updated:\n"));
 
-	VLog(0, ("      entry %d: [", WillChange[i]));
-	for (h = j = 0; j < VL_MAXIPADDRS_PERMH; j++) {
+	for (addrbuf[0] = '\0', h = j = 0; j < VL_MAXIPADDRS_PERMH; j++) {
 	    if (tex->ex_addrs[j]) {
 		if (j > 0)
-		    printf(" ");
-		PADDR(ntohl(tex->ex_addrs[j]));
+		    strlcat(addrbuf, " ", sizeof(addrbuf));
+		append_addr(addrbuf, ntohl(tex->ex_addrs[j]), sizeof(addrbuf));
 	    }
 
 	    for (k = 0; k < cnt; k++) {
@@ -2372,7 +2376,7 @@ SVL_RegisterAddrs(struct rx_call *rxcall, afsUUID *uuidp, afs_int32 spare1,
 	for (j = h; j < VL_MAXIPADDRS_PERMH; j++) {
 	    tex->ex_addrs[j] = 0;	/* zero rest of mh entry */
 	}
-	VLog(0, ("]\n"));
+	VLog(0, ("      entry %d: [%s]\n", WillChange[i], addrbuf));
 
 	/* Write out the modified mh entry */
 	tex->ex_uniquifier = htonl(ntohl(tex->ex_uniquifier) + 1);
@@ -3213,6 +3217,8 @@ ChangeIPAddr(afs_uint32 ipaddr1, afs_uint32 ipaddr2, struct ubik_trans *atrans)
     int pollcount = 0;
     struct nvlentry tentry;
     int ipaddr1_id = -1, ipaddr2_id = -1;
+    char addrbuf1[256];
+    char addrbuf2[256];
 
     if (!atrans)
 	return VL_CREATEFAIL;
@@ -3312,25 +3318,22 @@ ChangeIPAddr(afs_uint32 ipaddr1, afs_uint32 ipaddr2, struct ubik_trans *atrans)
     VLog(0,
 	 ("The following IP address is being %s:\n",
 	  (ipaddr2 ? "changed" : "removed")));
-    VLog(0, ("      entry %d: ", i));
+    addrbuf1[0] = addrbuf2[0] = '\0';
     if (exp) {
-	VLog(0, ("["));
 	for (mhidx = 0; mhidx < VL_MAXIPADDRS_PERMH; mhidx++) {
 	    if (!exp->ex_addrs[mhidx])
 		continue;
 	    if (mhidx > 0)
-		VLog(0, (" "));
-	    PADDR(ntohl(exp->ex_addrs[mhidx]));
+		strlcat(addrbuf1, " ", sizeof(addrbuf1));
+	    append_addr(addrbuf1, ntohl(exp->ex_addrs[mhidx]), sizeof(addrbuf1));
 	}
-	VLog(0, ("]"));
     } else {
-	PADDR(ipaddr1);
+	append_addr(addrbuf1, ipaddr1, sizeof(addrbuf1));
     }
     if (ipaddr2) {
-	VLog(0, (" -> "));
-	PADDR(ipaddr2);
+	append_addr(addrbuf2, ipaddr2, sizeof(addrbuf2));
     }
-    VLog(0, ("\n"));
+    VLog(0, ("      entry %d: [%s] -> [%s]\n", i, addrbuf1, addrbuf2));
 
     /* Change the registered uuuid addresses */
     if (exp) {
diff --git a/src/vlserver/vlserver.c b/src/vlserver/vlserver.c
index ef51860..1eeae56 100644
--- a/src/vlserver/vlserver.c
+++ b/src/vlserver/vlserver.c
@@ -279,16 +279,16 @@ main(int argc, char **argv)
 
     tdir = afsconf_Open(AFSDIR_SERVER_ETC_DIRPATH);
     if (!tdir) {
-	printf
+	VLog(0,
 	    ("vlserver: can't open configuration files in dir %s, giving up.\n",
-	     AFSDIR_SERVER_ETC_DIRPATH);
+	     AFSDIR_SERVER_ETC_DIRPATH));
 	exit(1);
     }
 #ifdef AFS_NT40_ENV
     /* initialize winsock */
     if (afs_winsockInit() < 0) {
 	ReportErrorEventAlt(AFSEVT_SVR_WINSOCK_INIT_FAILED, 0, argv[0], 0);
-	fprintf(stderr, "vlserver: couldn't initialize winsock. \n");
+	VLog(0, ("vlserver: couldn't initialize winsock.\n"));
 	exit(1);
     }
 #endif
@@ -296,8 +296,8 @@ main(int argc, char **argv)
     gethostname(hostname, sizeof(hostname));
     th = gethostbyname(hostname);
     if (!th) {
-	printf("vlserver: couldn't get address of this host (%s).\n",
-	       hostname);
+	VLog(0, ("vlserver: couldn't get address of this host (%s).\n",
+	       hostname));
 	exit(1);
     }
     memcpy(&myHost, th->h_addr, sizeof(afs_uint32));
@@ -310,7 +310,7 @@ main(int argc, char **argv)
 	afsconf_GetExtendedCellInfo(tdir, NULL, AFSCONF_VLDBSERVICE, &info,
 				    clones);
     if (code) {
-	printf("vlserver: Couldn't get cell server list for 'afsvldb'.\n");
+	VLog(0, ("vlserver: Couldn't get cell server list for 'afsvldb'.\n"));
 	exit(2);
     }
 
@@ -392,7 +392,7 @@ main(int argc, char **argv)
 			  securityClasses, numClasses,
 			  RXSTATS_ExecuteRequest);
     if (tservice == (struct rx_service *)0) {
-	printf("vlserver: Could not create rpc stats rx service\n");
+	VLog(0, ("vlserver: Could not create rpc stats rx service\n"));
 	exit(3);
     }
     rx_SetMinProcs(tservice, 2);
diff --git a/src/vlserver/vlutils.c b/src/vlserver/vlutils.c
index 18c051d..4ab2478 100644
--- a/src/vlserver/vlutils.c
+++ b/src/vlserver/vlutils.c
@@ -329,7 +329,7 @@ UpdateCache(struct ubik_trans *trans, void *rock)
     /* now, if can't read, or header is wrong, write a new header */
     if (ubcode || vldbversion == 0) {
 	if (builddb) {
-	    printf("Can't read VLDB header, re-initialising...\n");
+	    VLog(0, ("Can't read VLDB header, re-initialising...\n"));
 
 	    /* try to write a good header */
 	    memset(&cheader, 0, sizeof(cheader));
@@ -344,7 +344,7 @@ UpdateCache(struct ubik_trans *trans, void *rock)
 	    }
 	    code = vlwrite(trans, 0, (char *)&cheader, sizeof(cheader));
 	    if (code) {
-		printf("Can't write VLDB header (error = %d)\n", code);
+		VLog(0, ("Can't write VLDB header (error = %d)\n", code));
 		ERROR_EXIT(VL_IO);
 	    }
 	    vldbversion = ntohl(cheader.vital_header.vldbversion);
@@ -355,9 +355,9 @@ UpdateCache(struct ubik_trans *trans, void *rock)
 
     if ((vldbversion != VLDBVERSION) && (vldbversion != OVLDBVERSION)
         && (vldbversion != VLDBVERSION_4)) {
-	printf
+	VLog(0,
 	    ("VLDB version %d doesn't match this software version(%d, %d or %d), quitting!\n",
-	     vldbversion, VLDBVERSION_4, VLDBVERSION, OVLDBVERSION);
+	     vldbversion, VLDBVERSION_4, VLDBVERSION, OVLDBVERSION));
 	return VL_BADVERSION;
     }
 
diff --git a/src/vol/fssync-server.c b/src/vol/fssync-server.c
index a9ba378..8678fd5 100644
--- a/src/vol/fssync-server.c
+++ b/src/vol/fssync-server.c
@@ -332,14 +332,16 @@ FSYNC_sync(void * args)
 	    CallHandler(FSYNC_readfds, nfds, POLLIN|POLLPRI);
 #else
 	int maxfd;
+#ifdef AFS_PTHREAD_ENV
 	struct timeval s_timeout;
+#endif
 	GetHandler(&FSYNC_readfds, &maxfd);
-	s_timeout.tv_sec = SYNC_SELECT_TIMEOUT;
-	s_timeout.tv_usec = 0;
 	/* Note: check for >= 1 below is essential since IOMGR_select
 	 * doesn't have exactly same semantics as select.
 	 */
 #ifdef AFS_PTHREAD_ENV
+	s_timeout.tv_sec = SYNC_SELECT_TIMEOUT;
+	s_timeout.tv_usec = 0;
 	if (select(maxfd + 1, &FSYNC_readfds, NULL, NULL, &s_timeout) >= 1)
 #else /* AFS_PTHREAD_ENV */
 	if (IOMGR_Select(maxfd + 1, &FSYNC_readfds, NULL, NULL, NULL) >= 1)
diff --git a/src/vol/namei_ops.c b/src/vol/namei_ops.c
index 89d740b..254e9a0 100644
--- a/src/vol/namei_ops.c
+++ b/src/vol/namei_ops.c
@@ -2840,6 +2840,8 @@ namei_ConvertROtoRWvolume(char *pname, afs_uint32 volumeId)
     struct DiskPartition64 *partP;
     struct ViceInodeInfo info;
     struct VolumeDiskHeader h;
+    char *rwpart, *rwname;
+    Error ec;
 # ifdef AFS_DEMAND_ATTACH_FS
     int locktype = 0;
 # endif /* AFS_DEMAND_ATTACH_FS */
@@ -2869,6 +2871,19 @@ namei_ConvertROtoRWvolume(char *pname, afs_uint32 volumeId)
 	goto done;
     }
 
+    /* check for existing RW on any partition on this server; */
+    /* if found, return EXDEV - invalid cross-device link */
+    VOL_LOCK;
+    VGetVolumePath(&ec, h.parent, &rwpart, &rwname);
+    if (ec == 0) {
+	Log("1 namei_ConvertROtoRWvolume: RW volume %lu already exists on server partition %s.\n",
+	    afs_printable_uint32_lu(h.parent), rwpart);
+	code = EXDEV;
+	VOL_UNLOCK;
+	goto done;
+    }
+    VOL_UNLOCK;
+
     FSYNC_VolOp(volumeId, pname, FSYNC_VOL_BREAKCBKS, 0, NULL);
 
     ino = namei_MakeSpecIno(h.parent, VI_LINKTABLE);
diff --git a/src/vol/vol-salvage.c b/src/vol/vol-salvage.c
index e21630c..21b4198 100644
--- a/src/vol/vol-salvage.c
+++ b/src/vol/vol-salvage.c
@@ -2580,7 +2580,6 @@ SalvageIndex(struct SalvInfo *salvinfo, Inode ino, VnodeClass class, int RW,
 	     struct ViceInodeInfo *ip, int nInodes,
              struct VolumeSummary *volSummary, int check)
 {
-    VolumeId volumeNumber;
     char buf[SIZEOF_LARGEDISKVNODE];
     struct VnodeDiskObject *vnode = (struct VnodeDiskObject *)buf;
     int err = 0;
@@ -2594,7 +2593,6 @@ SalvageIndex(struct SalvInfo *salvinfo, Inode ino, VnodeClass class, int RW,
     IHandle_t *handle;
     FdHandle_t *fdP;
 
-    volumeNumber = volSummary->header.id;
     IH_INIT(handle, salvinfo->fileSysDevice, volSummary->header.parent, ino);
     fdP = IH_OPEN(handle);
     osi_Assert(fdP != NULL);
@@ -3685,7 +3683,7 @@ CreateRootDir(struct SalvInfo *salvinfo, VolumeDiskData *volHeader,
     Inode *ip;
     afs_sfsize_t bytes;
     struct VnodeEssence *vep;
-    Inode readmeinode;
+    Inode readmeinode = 0;
     time_t now = time(NULL);
 
     if (!salvinfo->vnodeInfo[vLarge].vnodes && !salvinfo->vnodeInfo[vSmall].vnodes) {
diff --git a/src/vol/volume.c b/src/vol/volume.c
index c6fa1e8..e11e6c4 100644
--- a/src/vol/volume.c
+++ b/src/vol/volume.c
@@ -3005,6 +3005,9 @@ attach_volume_header(Error *ec, Volume *vp, struct DiskPartition64 *partp,
     }
 
     if (*ec) {
+	VOL_LOCK;
+	FreeVolumeHeader(vp);
+	VOL_UNLOCK;
 	return;
     }
     if (retry) {
@@ -3136,11 +3139,11 @@ attach2(Error * ec, VolId volumeId, char *path, struct DiskPartition64 *partp,
     /* have we read in the header successfully? */
     int read_header = 0;
 
+#ifdef AFS_DEMAND_ATTACH_FS
     /* should we FreeVolume(vp) instead of VCheckFree(vp) in the error
      * cleanup? */
     int forcefree = 0;
 
-#ifdef AFS_DEMAND_ATTACH_FS
     /* in the case of an error, to what state should the volume be
      * transitioned? */
     VolState error_state = VOL_STATE_ERROR;
@@ -3327,10 +3330,10 @@ attach2(Error * ec, VolId volumeId, char *path, struct DiskPartition64 *partp,
 	VRequestSalvage_r(ec, vp, SALVSYNC_ERROR, VOL_SALVAGE_NO_OFFLINE);
 	VChangeState_r(vp, VOL_STATE_ERROR);
 	vp->nUsers = 0;
+	forcefree = 1;
 #endif /* AFS_DEMAND_ATTACH_FS */
 	Log("VAttachVolume: volume %s is junk; it should be destroyed at next salvage\n", path);
 	*ec = VNOVOL;
-	forcefree = 1;
 	goto locked_error;
     }
 
@@ -3980,18 +3983,18 @@ GetVolume(Error * ec, Error * client_ec, VolId volumeId, Volume * hint,
 	 *   - VOL_STATE_SHUTTING_DOWN
 	 */
 	if ((V_attachState(vp) == VOL_STATE_ERROR) ||
-	    (V_attachState(vp) == VOL_STATE_SHUTTING_DOWN) ||
-	    (V_attachState(vp) == VOL_STATE_GOING_OFFLINE)) {
+	    (V_attachState(vp) == VOL_STATE_SHUTTING_DOWN)) {
 	    *ec = VNOVOL;
 	    vp = NULL;
 	    break;
 	}
 
 	/*
-	 * short circuit with VOFFLINE for VOL_STATE_UNATTACHED and
+	 * short circuit with VOFFLINE for VOL_STATE_UNATTACHED/GOING_OFFLINE and
 	 *                    VNOVOL   for VOL_STATE_DELETED
 	 */
        if ((V_attachState(vp) == VOL_STATE_UNATTACHED) ||
+           (V_attachState(vp) == VOL_STATE_GOING_OFFLINE) ||
            (V_attachState(vp) == VOL_STATE_DELETED)) {
 	   if (vp->specialStatus) {
 	       *ec = vp->specialStatus;
@@ -4044,9 +4047,17 @@ GetVolume(Error * ec, Error * client_ec, VolId volumeId, Volume * hint,
 		    if (!vp->pending_vol_op) {
 			endloop = 1;
 		    }
+		    if (vp->specialStatus) {
+			*ec = vp->specialStatus;
+		    }
 		    break;
+
 		default:
-		    *ec = VNOVOL;
+		    if (vp->specialStatus) {
+			*ec = vp->specialStatus;
+		    } else {
+			*ec = VNOVOL;
+		    }
 		    endloop = 1;
 		}
 		if (endloop) {
@@ -4107,14 +4118,7 @@ GetVolume(Error * ec, Error * client_ec, VolId volumeId, Volume * hint,
 	       }
 	   } else {
 	       if (client_ec) {
-		   /* see CheckVnode() in afsfileprocs.c for an explanation
-		    * of this error code logic */
-		   afs_uint32 now = FT_ApproxTime();
-		   if ((vp->stats.last_vol_op + (10 * 60)) >= now) {
-		       *client_ec = VBUSY;
-		   } else {
-		       *client_ec = VRESTARTING;
-		   }
+		   *client_ec = VOFFLINE;
 	       }
 	       *ec = VOFFLINE;
 	   }
@@ -4466,12 +4470,12 @@ VOffline(Volume * vp, char *message)
 void
 VDetachVolume_r(Error * ec, Volume * vp)
 {
+#ifdef FSSYNC_BUILD_CLIENT
     VolumeId volume;
     struct DiskPartition64 *tpartp;
     int notifyServer = 0;
     int  useDone = FSYNC_VOL_ON;
 
-    *ec = 0;			/* always "succeeds" */
     if (VCanUseFSSYNC()) {
 	notifyServer = vp->needsPutBack;
 	if (V_destroyMe(vp) == DESTROY_ME)
@@ -4489,6 +4493,8 @@ VDetachVolume_r(Error * ec, Volume * vp)
 # endif
     tpartp = vp->partition;
     volume = V_id(vp);
+#endif /* FSSYNC_BUILD_CLIENT */
+    *ec = 0;			/* always "succeeds" */
     DeleteVolumeFromHashTable(vp);
     vp->shuttingDown = 1;
 #ifdef AFS_DEMAND_ATTACH_FS
@@ -8628,7 +8634,7 @@ VVByPListWait_r(struct DiskPartition64 * dp)
 void
 VPrintCacheStats_r(void)
 {
-    afs_uint32 get_hi, get_lo, load_hi, load_lo;
+    afs_uint32 get_hi AFS_UNUSED, get_lo, load_hi AFS_UNUSED, load_lo;
     struct VnodeClassInfo *vcp;
     vcp = &VnodeClassInfo[vLarge];
     Log("Large vnode cache, %d entries, %d allocs, %d gets (%d reads), %d writes\n", vcp->cacheSize, vcp->allocs, vcp->gets, vcp->reads, vcp->writes);
diff --git a/src/vol/vutil.c b/src/vol/vutil.c
index acda92a..7b2cd8b 100644
--- a/src/vol/vutil.c
+++ b/src/vol/vutil.c
@@ -136,7 +136,7 @@ VCreateVolume_r(Error * ec, char *partname, VolId volumeId, VolId parentId)
     struct VolumeDiskHeader diskHeader;
     IHandle_t *handle;
     FdHandle_t *fdP;
-    Inode nearInode = 0;
+    Inode nearInode AFS_UNUSED = 0;
     char *part, *name;
     struct stat st;
     afs_ino_str_t stmp;
diff --git a/src/volser/dumpstuff.c b/src/volser/dumpstuff.c
index caa2c40..53aa8b8 100644
--- a/src/volser/dumpstuff.c
+++ b/src/volser/dumpstuff.c
@@ -1312,7 +1312,7 @@ ReadVnodes(struct iod *iodp, Volume * vp, int incremental,
     struct VnodeClassInfo *vcp;
     IHandle_t *tmpH;
     FdHandle_t *fdP;
-    Inode nearInode;
+    Inode nearInode AFS_UNUSED;
     afs_int32 critical = 0;
 
     tag = iod_getc(iodp);
diff --git a/src/volser/restorevol.c b/src/volser/restorevol.c
index f8f198e..86d720e 100644
--- a/src/volser/restorevol.c
+++ b/src/volser/restorevol.c
@@ -147,7 +147,7 @@ ReadDumpHeader(struct DumpHeader *dh)
 {
     int i, done;
     char tag, c;
-    afs_int32 magic;
+    afs_int32 magic AFS_UNUSED;
 
 /*  memset(&dh, 0, sizeof(dh)); */
 
diff --git a/src/volser/vol_split.c b/src/volser/vol_split.c
index 7522b9b..d486e24 100644
--- a/src/volser/vol_split.c
+++ b/src/volser/vol_split.c
@@ -404,7 +404,7 @@ afs_int32 copyVnodes(struct Msg *m, Volume *vol, Volume *newvol,
 	        ino = VNDISK_GET_INO(vnode);
 	        if (ino) {
 		    IHandle_t *h, *newh;
-		    Inode nearInode;
+		    Inode nearInode AFS_UNUSED;
 #if defined(NEARINODE_HINT) && !defined(AFS_NAMEI_ENV)
 		    V_pref(vol,nearInode)
 #endif
diff --git a/src/volser/volprocs.c b/src/volser/volprocs.c
index 95339ad..46b43b7 100644
--- a/src/volser/volprocs.c
+++ b/src/volser/volprocs.c
@@ -129,6 +129,21 @@ static afs_int32 VolSetIdsTypes(struct rx_call *, afs_int32, char [],
 				afs_uint32);
 static afs_int32 VolSetDate(struct rx_call *, afs_int32, afs_int32);
 
+/**
+ * Return the host address of the caller as a string.
+ *
+ * @param[in]  acid    incoming rx call
+ * @param[out] buffer  buffer to be filled with the addess string
+ *
+ * @return address as formatted by inet_ntoa
+ */
+static_inline char *
+callerAddress(struct rx_call *acid, char *buffer)
+{
+    afs_uint32 ip = rx_HostOf(rx_PeerOf(rx_ConnectionOf(acid)));
+    return afs_inet_ntoa_r(ip, buffer);
+}
+
 /* this call unlocks all of the partition locks we've set */
 int
 VPFullUnlock_r(void)
@@ -327,7 +342,7 @@ ViceCreateRoot(Volume *vp)
     DirHandle dir;
     struct acl_accessList *ACL;
     AFSFid did;
-    Inode inodeNumber, nearInode;
+    Inode inodeNumber, nearInode AFS_UNUSED;
     struct VnodeDiskObject *vnode;
     struct VnodeClassInfo *vcp = &VnodeClassInfo[vLarge];
     IHandle_t *h;
@@ -486,8 +501,11 @@ VolNukeVolume(struct rx_call *acid, afs_int32 apartID, afs_uint32 avolID)
     /* check for access */
     if (!afsconf_SuperUser(tdir, acid, caller))
 	return VOLSERBAD_ACCESS;
-    if (DoLogging)
-	Log("%s is executing VolNukeVolume %u\n", caller, avolID);
+    if (DoLogging) {
+	char buffer[16];
+	Log("%s on %s is executing VolNukeVolume %u\n", caller,
+	    callerAddress(acid, buffer), avolID);
+    }
 
     if (volutil_PartitionName2_r(apartID, partName, sizeof(partName)) != 0)
 	return VOLSERNOVOL;
@@ -541,8 +559,11 @@ VolCreateVolume(struct rx_call *acid, afs_int32 apart, char *aname,
 	return VOLSERBADNAME;
     if (!afsconf_SuperUser(tdir, acid, caller))
 	return VOLSERBAD_ACCESS;
-    if (DoLogging)
-	Log("%s is executing CreateVolume '%s'\n", caller, aname);
+    if (DoLogging) {
+	char buffer[16];
+	Log("%s on %s is executing CreateVolume '%s'\n", caller,
+	    callerAddress(acid, buffer), aname);
+    }
     if ((error = ConvertPartition(apart, ppath, sizeof(ppath))))
 	return error;		/*a standard unix error */
     if (atype != readwriteVolume && atype != readonlyVolume
@@ -643,8 +664,11 @@ VolDeleteVolume(struct rx_call *acid, afs_int32 atrans)
 	TRELE(tt);
 	return ENOENT;
     }
-    if (DoLogging)
-	Log("%s is executing Delete Volume %u\n", caller, tt->volid);
+    if (DoLogging) {
+	char buffer[16];
+	Log("%s on %s is executing Delete Volume %u\n", caller,
+	    callerAddress(acid, buffer), tt->volid);
+    }
     TSetRxCall(tt, acid, "DeleteVolume");
     VPurgeVolume(&error, tt->volume);	/* don't check error code, it is not set! */
     V_destroyMe(tt->volume) = DESTROY_ME;
@@ -703,8 +727,11 @@ VolClone(struct rx_call *acid, afs_int32 atrans, afs_uint32 purgeId,
 	return VOLSERBADNAME;
     if (!afsconf_SuperUser(tdir, acid, caller))
 	return VOLSERBAD_ACCESS;	/*not a super user */
-    if (DoLogging)
-	Log("%s is executing Clone Volume new name=%s\n", caller, newName);
+    if (DoLogging) {
+	char buffer[16];
+	Log("%s on %s is executing Clone Volume new name=%s\n", caller,
+	    callerAddress(acid, buffer), newName);
+    }
     error = 0;
     originalvp = (Volume *) 0;
     purgevp = (Volume *) 0;
@@ -886,8 +913,11 @@ VolReClone(struct rx_call *acid, afs_int32 atrans, afs_int32 cloneId)
     /*not a super user */
     if (!afsconf_SuperUser(tdir, acid, caller))
 	return VOLSERBAD_ACCESS;
-    if (DoLogging)
-	Log("%s is executing Reclone Volume %u\n", caller, cloneId);
+    if (DoLogging) {
+	char buffer[16];
+	Log("%s on %s is executing Reclone Volume %u\n", caller,
+	    callerAddress(acid, buffer), cloneId);
+    }
     error = 0;
     clonevp = originalvp = (Volume *) 0;
     tt = (struct volser_trans *)0;
diff --git a/src/volser/vos.c b/src/volser/vos.c
index 3ee98e4..20fe319 100644
--- a/src/volser/vos.c
+++ b/src/volser/vos.c
@@ -5457,13 +5457,13 @@ SetAddrs(struct cmd_syndesc *as, void *arock)
     if (vcode) {
 	if (vcode == VL_MULTIPADDR) {
 	    fprintf(STDERR, "vos: VL_RegisterAddrs rpc failed; The IP address exists on a different server; repair it\n");
-	    PrintError("", vcode);
-	    return vcode;
 	} else if (vcode == RXGEN_OPCODE) {
 	    fprintf(STDERR, "vlserver doesn't support VL_RegisterAddrs rpc; ignored\n");
-	    PrintError("", vcode);
-	    return vcode;
+	} else {
+	    fprintf(STDERR, "vos: VL_RegisterAddrs rpc failed\n");
 	}
+	PrintError("", vcode);
+	return vcode;
     }
     if (verbose) {
 	fprintf(STDOUT, "vos: Changed UUID with addresses:\n");
@@ -5506,7 +5506,7 @@ ConvertRO(struct cmd_syndesc *as, void *arock)
     afs_uint32 volid;
     afs_uint32 server;
     afs_int32 code, i, same;
-    struct nvldbentry entry, storeEntry;
+    struct nvldbentry entry, checkEntry, storeEntry;
     afs_int32 vcode;
     afs_int32 rwindex = 0;
     afs_uint32 rwserver = 0;
@@ -5545,23 +5545,23 @@ ConvertRO(struct cmd_syndesc *as, void *arock)
 	    PrintError("", code);
 	else
 	    fprintf(STDERR, "Unknown volume ID or name '%s'\n",
-		    as->parms[0].items->data);
+		    as->parms[2].items->data);
 	return -1;
     }
     if (as->parms[3].items)
 	force = 1;
 
+    memset(&entry, 0, sizeof(entry));
     vcode = VLDB_GetEntryByID(volid, -1, &entry);
     if (vcode) {
 	fprintf(STDERR,
 		"Could not fetch the entry for volume %lu from VLDB\n",
 		(unsigned long)volid);
-	PrintError("convertROtoRW", code);
+	PrintError("convertROtoRW ", vcode);
 	return vcode;
     }
 
     /* use RO volid even if user specified RW or BK volid */
-
     if (volid != entry.volumeId[ROVOL])
 	volid = entry.volumeId[ROVOL];
 
@@ -5571,8 +5571,9 @@ ConvertRO(struct cmd_syndesc *as, void *arock)
 	    rwindex = i;
 	    rwserver = entry.serverNumber[i];
 	    rwpartition = entry.serverPartition[i];
-	}
-	if (entry.serverFlags[i] & ITSROVOL) {
+	    if (roserver)
+		break;
+	} else if ((entry.serverFlags[i] & ITSROVOL) && !roserver) {
 	    same = VLDB_IsSameAddrs(server, entry.serverNumber[i], &code);
 	    if (code) {
 		fprintf(STDERR,
@@ -5584,14 +5585,15 @@ ConvertRO(struct cmd_syndesc *as, void *arock)
 		roindex = i;
 		roserver = entry.serverNumber[i];
 		ropartition = entry.serverPartition[i];
-		break;
+		if (rwserver)
+		     break;
 	    }
 	}
     }
     if (!roserver) {
 	fprintf(STDERR, "Warning: RO volume didn't exist in vldb!\n");
     }
-    if (ropartition != partition) {
+    if (roserver && (ropartition != partition)) {
 	fprintf(STDERR,
 		"Warning: RO volume should be in partition %d instead of %d (vldb)\n",
 		ropartition, partition);
@@ -5617,6 +5619,37 @@ ConvertRO(struct cmd_syndesc *as, void *arock)
     vcode =
 	ubik_VL_SetLock(cstruct, 0, entry.volumeId[RWVOL], RWVOL,
 		  VLOP_MOVE);
+    if (vcode) {
+	fprintf(STDERR,
+		"Unable to lock volume %lu, code %d\n",
+		(unsigned long)entry.volumeId[RWVOL],vcode);
+	PrintError("", vcode);
+	return -1;
+    }
+
+    /* make sure the VLDB entry hasn't changed since we started */
+    memset(&checkEntry, 0, sizeof(checkEntry));
+    vcode = VLDB_GetEntryByID(volid, -1, &checkEntry);
+    if (vcode) {
+	fprintf(STDERR,
+                "Could not fetch the entry for volume %lu from VLDB\n",
+                (unsigned long)volid);
+	PrintError("convertROtoRW ", vcode);
+	code = vcode;
+	goto error_exit;
+    }
+
+    MapHostToNetwork(&checkEntry);
+    entry.flags &= ~VLOP_ALLOPERS;  /* clear any stale lock operation flags */
+    entry.flags |= VLOP_MOVE;        /* set to match SetLock operation above */
+    if (memcmp(&entry, &checkEntry, sizeof(entry)) != 0) {
+        fprintf(STDERR,
+                "VLDB entry for volume %lu has changed; please reissue the command.\n",
+                (unsigned long)volid);
+        code = -1;
+        goto error_exit;
+    }
+
     aconn = UV_Bind(server, AFSCONF_VOLUMEPORT);
     code = AFSVolConvertROtoRWvolume(aconn, partition, volid);
     if (code) {
@@ -5624,11 +5657,31 @@ ConvertRO(struct cmd_syndesc *as, void *arock)
 		"Converting RO volume %lu to RW volume failed with code %d\n",
 		(unsigned long)volid, code);
 	PrintError("convertROtoRW ", code);
-	return -1;
+	goto error_exit;
+    }
+    /* Update the VLDB to match what we did on disk as much as possible.  */
+    /* If the converted RO was in the VLDB, make it look like the new RW. */
+    if (roserver) {
+	entry.serverFlags[roindex] = ITSRWVOL;
+    } else {
+	/* Add a new site entry for the newly created RW.  It's possible
+	 * (but unlikely) that we are already at MAXNSERVERS and that this
+	 * new site will invalidate the whole VLDB entry;  however,
+	 * VLDB_ReplaceEntry will detect this and return VL_BADSERVER,
+	 * so we need no extra guard logic here.
+	 */
+	afs_int32 newrwindex = entry.nServers;
+	(entry.nServers)++;
+	entry.serverNumber[newrwindex] = server;
+	entry.serverPartition[newrwindex] = partition;
+	entry.serverFlags[newrwindex] = ITSRWVOL;
     }
-    entry.serverFlags[roindex] = ITSRWVOL;
     entry.flags |= RW_EXISTS;
     entry.flags &= ~BACK_EXISTS;
+
+    /* if the old RW was in the VLDB, remove it by decrementing the number */
+    /* of servers, replacing the RW entry with the last entry, and zeroing */
+    /* out the last entry. */
     if (rwserver) {
 	(entry.nServers)--;
 	if (rwindex != entry.nServers) {
@@ -5658,9 +5711,14 @@ ConvertRO(struct cmd_syndesc *as, void *arock)
 		"Warning: volume converted, but vldb update failed with code %d!\n",
 		code);
     }
+
+  error_exit:
     vcode = UV_LockRelease(entry.volumeId[RWVOL]);
     if (vcode) {
-	PrintDiagnostics("unlock", vcode);
+	fprintf(STDERR,
+		"Unable to unlock volume %lu, code %d\n",
+		(unsigned long)entry.volumeId[RWVOL],vcode);
+	PrintError("", vcode);
     }
     return code;
 }
diff --git a/src/xstat/xstat_fs_test.c b/src/xstat/xstat_fs_test.c
index 3be314e..ba9677b 100644
--- a/src/xstat/xstat_fs_test.c
+++ b/src/xstat/xstat_fs_test.c
@@ -279,14 +279,6 @@ PrintOverallPerfInfo(struct afs_PerfStats *a_ovP)
 void
 PrintOpTiming(int a_opIdx, struct fs_stats_opTimingData *a_opTimeP)
 {
-    double fSumTime, avg;
-
-    fSumTime =
-	((double)(a_opTimeP->sumTime.tv_sec)) +
-	(((double)(a_opTimeP->sumTime.tv_usec)) / ((double)(1000000)));
-/*    printf("Double sum time is %f\n", fSumTime);*/
-    avg = fSumTime / ((double)(a_opTimeP->numSuccesses));
-
     printf
 	("%15s: %u ops (%u OK); sum=%lu.%06lu, sqr=%lu.%06lu, min=%lu.%06lu, max=%lu.%06lu\n",
 	 opNames[a_opIdx], a_opTimeP->numOps, a_opTimeP->numSuccesses,
@@ -320,14 +312,6 @@ PrintOpTiming(int a_opIdx, struct fs_stats_opTimingData *a_opTimeP)
 void
 PrintXferTiming(int a_opIdx, struct fs_stats_xferData *a_xferP)
 {
-    double fSumTime, avg;
-
-    fSumTime =
-	((double)(a_xferP->sumTime.tv_sec)) +
-	((double)(a_xferP->sumTime.tv_usec)) / ((double)(1000000));
-
-    avg = fSumTime / ((double)(a_xferP->numSuccesses));
-
     printf
 	("%s: %u xfers (%u OK), time sum=%lu.%06lu, sqr=%lu.%06lu, min=%lu.%06lu, max=%lu.%06lu\n",
 	 xferOpNames[a_opIdx], a_xferP->numXfers, a_xferP->numSuccesses,
